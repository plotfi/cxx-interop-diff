import Combine
@_exported import CoreFoundation
import CoreGraphics
import Darwin
import Darwin.uuid
import Dispatch
@_exported import Foundation.FoundationErrors
@_exported import Foundation.FoundationLegacySwiftCompatibility
@_exported import Foundation.NSArray
@_exported import Foundation.NSAttributedString
@_exported import Foundation.NSAutoreleasePool
@_exported import Foundation.NSBundle
@_exported import Foundation.NSByteCountFormatter
@_exported import Foundation.NSByteOrder
@_exported import Foundation.NSCache
@_exported import Foundation.NSCalendar
@_exported import Foundation.NSCharacterSet
@_exported import Foundation.NSCoder
@_exported import Foundation.NSComparisonPredicate
@_exported import Foundation.NSCompoundPredicate
@_exported import Foundation.NSData
@_exported import Foundation.NSDate
@_exported import Foundation.NSDateComponentsFormatter
@_exported import Foundation.NSDateFormatter
@_exported import Foundation.NSDateInterval
@_exported import Foundation.NSDateIntervalFormatter
@_exported import Foundation.NSDecimal
@_exported import Foundation.NSDecimalNumber
@_exported import Foundation.NSDictionary
@_exported import Foundation.NSEnergyFormatter
@_exported import Foundation.NSEnumerator
@_exported import Foundation.NSError
@_exported import Foundation.NSException
@_exported import Foundation.NSExpression
@_exported import Foundation.NSExtensionContext
@_exported import Foundation.NSExtensionItem
@_exported import Foundation.NSExtensionRequestHandling
@_exported import Foundation.NSFileCoordinator
@_exported import Foundation.NSFileHandle
@_exported import Foundation.NSFileManager
@_exported import Foundation.NSFilePresenter
@_exported import Foundation.NSFileVersion
@_exported import Foundation.NSFileWrapper
@_exported import Foundation.NSFormatter
@_exported import Foundation.NSHTTPCookie
@_exported import Foundation.NSHTTPCookieStorage
@_exported import Foundation.NSHashTable
@_exported import Foundation.NSISO8601DateFormatter
@_exported import Foundation.NSIndexPath
@_exported import Foundation.NSIndexSet
@_exported import Foundation.NSInflectionRule
@_exported import Foundation.NSInvocation
@_exported import Foundation.NSItemProvider
@_exported import Foundation.NSJSONSerialization
@_exported import Foundation.NSKeyValueCoding
@_exported import Foundation.NSKeyValueObserving
@_exported import Foundation.NSKeyedArchiver
@_exported import Foundation.NSLengthFormatter
@_exported import Foundation.NSLinguisticTagger
@_exported import Foundation.NSListFormatter
@_exported import Foundation.NSLocale
@_exported import Foundation.NSLock
@_exported import Foundation.NSMapTable
@_exported import Foundation.NSMassFormatter
@_exported import Foundation.NSMeasurement
@_exported import Foundation.NSMeasurementFormatter
@_exported import Foundation.NSMetadata
@_exported import Foundation.NSMetadataAttributes
@_exported import Foundation.NSMethodSignature
@_exported import Foundation.NSMorphology
@_exported import Foundation.NSNetServices
@_exported import Foundation.NSNotification
@_exported import Foundation.NSNotificationQueue
@_exported import Foundation.NSNull
@_exported import Foundation.NSNumberFormatter
@_exported import Foundation.NSObjCRuntime
@_exported import Foundation.NSObject
@_exported import Foundation.NSOperation
import Foundation.NSOrderedCollectionChange
import Foundation.NSOrderedCollectionDifference
@_exported import Foundation.NSOrderedSet
@_exported import Foundation.NSOrthography
@_exported import Foundation.NSPathUtilities
@_exported import Foundation.NSPersonNameComponents
@_exported import Foundation.NSPersonNameComponentsFormatter
@_exported import Foundation.NSPointerArray
@_exported import Foundation.NSPointerFunctions
@_exported import Foundation.NSPort
@_exported import Foundation.NSPredicate
@_exported import Foundation.NSProcessInfo
@_exported import Foundation.NSProgress
@_exported import Foundation.NSPropertyList
@_exported import Foundation.NSProxy
@_exported import Foundation.NSRange
@_exported import Foundation.NSRegularExpression
@_exported import Foundation.NSRelativeDateTimeFormatter
@_exported import Foundation.NSRunLoop
@_exported import Foundation.NSScanner
@_exported import Foundation.NSSet
@_exported import Foundation.NSSortDescriptor
@_exported import Foundation.NSStream
@_exported import Foundation.NSString
@_exported import Foundation.NSTextCheckingResult
@_exported import Foundation.NSThread
@_exported import Foundation.NSTimeZone
@_exported import Foundation.NSTimer
@_exported import Foundation.NSURL
@_exported import Foundation.NSURLAuthenticationChallenge
@_exported import Foundation.NSURLCache
@_exported import Foundation.NSURLConnection
@_exported import Foundation.NSURLCredential
@_exported import Foundation.NSURLCredentialStorage
@_exported import Foundation.NSURLError
@_exported import Foundation.NSURLProtectionSpace
@_exported import Foundation.NSURLProtocol
@_exported import Foundation.NSURLRequest
@_exported import Foundation.NSURLResponse
@_exported import Foundation.NSURLSession
@_exported import Foundation.NSUUID
@_exported import Foundation.NSUbiquitousKeyValueStore
@_exported import Foundation.NSUndoManager
@_exported import Foundation.NSUnit
@_exported import Foundation.NSUserActivity
@_exported import Foundation.NSUserDefaults
@_exported import Foundation.NSValue
@_exported import Foundation.NSValueTransformer
@_exported import Foundation.NSXMLParser
@_exported import Foundation.NSXPCConnection
@_exported import Foundation.NSZone
import ObjectiveC
import _Concurrency

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct AsyncCharacterSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {
  typealias Element = Character
  @frozen struct AsyncIterator : AsyncIteratorProtocol {
    @usableFromInline
    var remaining: AsyncUnicodeScalarSequence<Base>.AsyncIterator
    @usableFromInline
    var accumulator: String
    @inlinable @inline(__always) mutating func next() async rethrows -> Character?
    typealias Element = Character
  }
  func makeAsyncIterator() -> AsyncCharacterSequence<Base>.AsyncIterator
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct AsyncLineSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {
  typealias Element = String
  struct AsyncIterator : AsyncIteratorProtocol {
    typealias Element = String
    mutating func next() async rethrows -> String?
  }
  func makeAsyncIterator() -> AsyncLineSequence<Base>.AsyncIterator
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct AsyncUnicodeScalarSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {
  typealias Element = UnicodeScalar
  @frozen struct AsyncIterator : AsyncIteratorProtocol {
    @usableFromInline
    var _base: Base.AsyncIterator
    @usableFromInline
    var _leftover: UInt8?
    @inlinable @inline(__always) func _expectedContinuationCountForByte(_ byte: UInt8) -> Int?
    @inlinable mutating func _nextComplexScalar(_ first: UInt8) async rethrows -> UnicodeScalar?
    @inlinable @inline(__always) mutating func next() async rethrows -> UnicodeScalar?
    typealias Element = Unicode.Scalar
  }
  func makeAsyncIterator() -> AsyncUnicodeScalarSequence<Base>.AsyncIterator
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup struct AttributeContainer : Equatable, CustomStringConvertible {
  static func == (lhs: AttributeContainer, rhs: AttributeContainer) -> Bool
  var description: String { get }
  subscript<T>(_: T.Type) -> T.Value? where T : AttributedStringKey
  subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey
  subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope
  static subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> AttributeContainer.Builder<K> where K : AttributedStringKey { get }
  @_disfavoredOverload subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> AttributeContainer.Builder<K> where K : AttributedStringKey { get }
  struct Builder<T> where T : AttributedStringKey {
    func callAsFunction(_ value: T.Value) -> AttributeContainer
  }
  init()
  mutating func merge(_ other: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)
  func merging(_ other: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew) -> AttributeContainer
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer : CodableWithConfiguration {
  func encode(to encoder: Encoder, configuration: AttributeScopeCodableConfiguration) throws
  init(from decoder: Decoder, configuration: AttributeScopeCodableConfiguration) throws
  typealias DecodingConfiguration = AttributeScopeCodableConfiguration
  typealias EncodingConfiguration = AttributeScopeCodableConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer {
  init(_ dictionary: [NSAttributedString.Key : Any])
  init<S>(_ dictionary: [NSAttributedString.Key : Any], including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope
  init<S>(_ dictionary: [NSAttributedString.Key : Any], including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup @frozen enum AttributeDynamicLookup {
  subscript<T>(_: T.Type) -> T where T : AttributedStringKey { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeDynamicLookup {
  subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.FoundationAttributes, T>) -> T where T : AttributedStringKey { get }
  subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.FoundationAttributes.NumberFormatAttributes, T>) -> T where T : AttributedStringKey { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeDynamicLookup : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol AttributeScope : DecodingConfigurationProviding, EncodingConfigurationProviding {
  static var decodingConfiguration: AttributeScopeCodableConfiguration { get }
  static var encodingConfiguration: AttributeScopeCodableConfiguration { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScope {
  static var encodingConfiguration: AttributeScopeCodableConfiguration { get }
  static var decodingConfiguration: AttributeScopeCodableConfiguration { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
struct AttributeScopeCodableConfiguration {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@frozen enum AttributeScopes {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes {
  var foundation: AttributeScopes.FoundationAttributes.Type { get }
  struct FoundationAttributes : AttributeScope {
    let link: AttributeScopes.FoundationAttributes.LinkAttribute
    let morphology: AttributeScopes.FoundationAttributes.MorphologyAttribute
    let inflect: AttributeScopes.FoundationAttributes.InflectionRuleAttribute
    let languageIdentifier: AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute
    let personNameComponent: AttributeScopes.FoundationAttributes.PersonNameComponentAttribute
    let numberFormat: AttributeScopes.FoundationAttributes.NumberFormatAttributes
    let dateField: AttributeScopes.FoundationAttributes.DateFieldAttribute
    let inlinePresentationIntent: AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute
    let presentationIntent: AttributeScopes.FoundationAttributes.PresentationIntentAttribute
    let alternateDescription: AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute
    let imageURL: AttributeScopes.FoundationAttributes.ImageURLAttribute
    let replacementIndex: AttributeScopes.FoundationAttributes.ReplacementIndexAttribute
    let measurement: AttributeScopes.FoundationAttributes.MeasurementAttribute
    let inflectionAlternative: AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute
    let byteCount: AttributeScopes.FoundationAttributes.ByteCountAttribute
    typealias DecodingConfiguration = AttributeScopeCodableConfiguration
    typealias EncodingConfiguration = AttributeScopeCodableConfiguration
  }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum LinkAttribute : CodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {
    typealias Value = URL
    typealias ObjectiveCValue = NSObject
    static var name: String
    static func objectiveCValue(for value: URL) throws -> NSObject
    static func value(for object: NSObject) throws -> URL
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum MorphologyAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {
    typealias Value = Morphology
    static let name: String
    static let markdownName: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum InflectionRuleAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {
    typealias Value = InflectionRule
    static let name: String
    static let markdownName: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum LanguageIdentifierAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {
    typealias Value = String
    static let name: String
    static let markdownName: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum PersonNameComponentAttribute : CodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {
    typealias Value = AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component
    typealias ObjectiveCValue = NSString
    static let name: String
    enum Component : String, Codable {
      case givenName
      case familyName
      case middleName
      case namePrefix
      case nameSuffix
      case nickname
      case delimiter
      init?(rawValue: String)
      typealias RawValue = String
      var rawValue: String { get }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  struct NumberFormatAttributes : AttributeScope {
    let numberSymbol: AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute
    let numberPart: AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute
    @frozen enum NumberPartAttribute : CodableAttributedStringKey {
      enum NumberPart : Int, Codable {
        case integer
        case fraction
        init?(rawValue: Int)
        typealias RawValue = Int
        var rawValue: Int { get }
      }
      static let name: String
      typealias Value = AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart
    }
    @frozen enum SymbolAttribute : CodableAttributedStringKey {
      enum Symbol : Int, Codable {
        case groupingSeparator
        case sign
        case decimalSeparator
        case currency
        case percent
        init?(rawValue: Int)
        typealias RawValue = Int
        var rawValue: Int { get }
      }
      static let name: String
      typealias Value = AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol
    }
    typealias DecodingConfiguration = AttributeScopeCodableConfiguration
    typealias EncodingConfiguration = AttributeScopeCodableConfiguration
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum DateFieldAttribute : CodableAttributedStringKey {
    enum Field : Hashable, Codable {
      case era
      case year
      /// For non-Gregorian calendars, this corresponds to the extended Gregorian year in which the calendar’s year begins.
      case relatedGregorianYear
      case quarter
      case month
      case weekOfYear
      case weekOfMonth
      case weekday
      /// The ordinal position of the weekday unit within the month unit. For example, `2` in "2nd Wednesday in July"
      case weekdayOrdinal
      case day
      case dayOfYear
      case amPM
      case hour
      case minute
      case second
      case secondFraction
      case timeZone
      init(from decoder: Decoder) throws
      func encode(to encoder: Encoder) throws
      static func == (a: AttributeScopes.FoundationAttributes.DateFieldAttribute.Field, b: AttributeScopes.FoundationAttributes.DateFieldAttribute.Field) -> Bool
      func hash(into hasher: inout Hasher)
      var hashValue: Int { get }
    }
    static let name: String
    typealias Value = AttributeScopes.FoundationAttributes.DateFieldAttribute.Field
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum InflectionAlternativeAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {
    typealias Value = AttributedString
    typealias ObjectiveCValue = NSObject
    static let name: String
    static let markdownName: String
    static func decodeMarkdown(from decoder: Decoder) throws -> AttributedString
    static func objectiveCValue(for value: AttributedString) throws -> NSObject
    static func value(for object: NSObject) throws -> AttributedString
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum InlinePresentationIntentAttribute : CodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {
    typealias Value = InlinePresentationIntent
    typealias ObjectiveCValue = NSNumber
    static let name: String
    static func objectiveCValue(for value: InlinePresentationIntent) throws -> NSNumber
    static func value(for object: NSNumber) throws -> InlinePresentationIntent
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum PresentationIntentAttribute : CodableAttributedStringKey {
    typealias Value = PresentationIntent
    static let name: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum AlternateDescriptionAttribute : CodableAttributedStringKey {
    typealias Value = String
    static let name: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum ImageURLAttribute : CodableAttributedStringKey {
    typealias Value = URL
    static let name: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum ReplacementIndexAttribute : CodableAttributedStringKey {
    typealias Value = Int
    static let name: String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  struct MeasurementAttribute : CodableAttributedStringKey {
    typealias Value = AttributeScopes.FoundationAttributes.MeasurementAttribute.Component
    static let name: String
    enum Component : Int, Codable {
      case value
      case unit
      init?(rawValue: Int)
      typealias RawValue = Int
      var rawValue: Int { get }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen enum ByteCountAttribute : CodableAttributedStringKey {
    typealias Value = AttributeScopes.FoundationAttributes.ByteCountAttribute.Component
    static let name: String
    enum Component : Codable, Hashable {
      case value
      case spelledOutValue
      case unit(AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit)
      case actualByteCount
      func hash(into hasher: inout Hasher)
      static func == (a: AttributeScopes.FoundationAttributes.ByteCountAttribute.Component, b: AttributeScopes.FoundationAttributes.ByteCountAttribute.Component) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    enum Unit : Codable {
      case byte
      case kb
      case mb
      case gb
      case tb
      case pb
      case eb
      case zb
      case yb
      static func == (a: AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit, b: AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit) -> Bool
      func hash(into hasher: inout Hasher)
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
  }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LinkAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MorphologyAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InflectionRuleAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.DateFieldAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PresentationIntentAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ImageURLAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup struct AttributedString : AttributedStringProtocol {
  enum AttributeMergePolicy {
    case keepNew
    case keepCurrent
    static func == (a: AttributedString.AttributeMergePolicy, b: AttributedString.AttributeMergePolicy) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey
  subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey
  subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope
  mutating func setAttributes(_ attributes: AttributeContainer)
  mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)
  mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
  func transformingAttributes<K>(_ k: K.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K>) -> Void) -> AttributedString where K : AttributedStringKey
  func transformingAttributes<K1, K2>(_ k: K1.Type, _ k2: K2.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey
  func transformingAttributes<K1, K2, K3>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey
  func transformingAttributes<K1, K2, K3, K4>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey
  func transformingAttributes<K1, K2, K3, K4, K5>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ k5: K5.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>, inout AttributedString.SingleAttributeTransformer<K5>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K5 : AttributedStringKey
  func transformingAttributes<K>(_ k: KeyPath<AttributeDynamicLookup, K>, _ c: (inout AttributedString.SingleAttributeTransformer<K>) -> Void) -> AttributedString where K : AttributedStringKey
  func transformingAttributes<K1, K2>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey
  func transformingAttributes<K1, K2, K3>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey
  func transformingAttributes<K1, K2, K3, K4>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ k4: KeyPath<AttributeDynamicLookup, K4>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey
  func transformingAttributes<K1, K2, K3, K4, K5>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ k4: KeyPath<AttributeDynamicLookup, K4>, _ k5: KeyPath<AttributeDynamicLookup, K5>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>, inout AttributedString.SingleAttributeTransformer<K5>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K5 : AttributedStringKey
  struct SingleAttributeTransformer<T> where T : AttributedStringKey {
    var range: Range<AttributedString.Index>
    var value: T.Value?
    mutating func replace<U>(with key: U.Type, value: U.Value) where U : AttributedStringKey
    mutating func replace<U>(with keyPath: KeyPath<AttributeDynamicLookup, U>, value: U.Value) where U : AttributedStringKey
  }
  struct Index : Comparable {
    static func < (lhs: AttributedString.Index, rhs: AttributedString.Index) -> Bool
    static func == (a: AttributedString.Index, b: AttributedString.Index) -> Bool
  }
  struct Runs : BidirectionalCollection, Equatable, CustomStringConvertible {
    struct Index : Comparable, Strideable {
      static func < (lhs: AttributedString.Runs.Index, rhs: AttributedString.Runs.Index) -> Bool
      func distance(to other: AttributedString.Runs.Index) -> Int
      func advanced(by n: Int) -> AttributedString.Runs.Index
      typealias Stride = Int
    }
    @dynamicMemberLookup struct Run : Equatable, CustomStringConvertible {
      var range: Range<AttributedString.Index> { get }
      static func == (lhs: AttributedString.Runs.Run, rhs: AttributedString.Runs.Run) -> Bool
      var description: String { get }
      subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey { get }
      subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey { get }
      subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope { get }
      var attributes: AttributeContainer { get }
    }
    typealias Element = AttributedString.Runs.Run
    static func == (lhs: AttributedString.Runs, rhs: AttributedString.Runs) -> Bool
    var description: String { get }
    func index(before i: AttributedString.Runs.Index) -> AttributedString.Runs.Index
    func index(after i: AttributedString.Runs.Index) -> AttributedString.Runs.Index
    var startIndex: AttributedString.Runs.Index { get }
    var endIndex: AttributedString.Runs.Index { get }
    subscript(position: AttributedString.Runs.Index) -> AttributedString.Runs.Run { get }
    subscript(position: AttributedString.Index) -> AttributedString.Runs.Run { get }
    struct AttributesSlice1<T> : BidirectionalCollection where T : AttributedStringKey {
      typealias Index = AttributedString.Index
      typealias Element = (T.Value?, Range<AttributedString.Index>)
      struct Iterator : IteratorProtocol {
        typealias Element = AttributedString.Runs.AttributesSlice1<T>.Element
        mutating func next() -> AttributedString.Runs.AttributesSlice1<T>.Iterator.Element?
      }
      func makeIterator() -> AttributedString.Runs.AttributesSlice1<T>.Iterator
      var startIndex: AttributedString.Runs.AttributesSlice1<T>.Index { get }
      var endIndex: AttributedString.Runs.AttributesSlice1<T>.Index { get }
      func index(before i: AttributedString.Runs.AttributesSlice1<T>.Index) -> AttributedString.Runs.AttributesSlice1<T>.Index
      func index(after i: AttributedString.Runs.AttributesSlice1<T>.Index) -> AttributedString.Runs.AttributesSlice1<T>.Index
      subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice1<T>.Element { get }
      typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice1<T>>
      typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice1<T>>
    }
    struct AttributesSlice2<T, U> : BidirectionalCollection where T : AttributedStringKey, U : AttributedStringKey {
      typealias Index = AttributedString.Index
      typealias Element = (T.Value?, U.Value?, Range<AttributedString.Index>)
      struct Iterator : IteratorProtocol {
        typealias Element = AttributedString.Runs.AttributesSlice2<T, U>.Element
        mutating func next() -> AttributedString.Runs.AttributesSlice2<T, U>.Iterator.Element?
      }
      func makeIterator() -> AttributedString.Runs.AttributesSlice2<T, U>.Iterator
      var startIndex: AttributedString.Runs.AttributesSlice2<T, U>.Index { get }
      var endIndex: AttributedString.Runs.AttributesSlice2<T, U>.Index { get }
      func index(before i: AttributedString.Runs.AttributesSlice2<T, U>.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Index
      func index(after i: AttributedString.Runs.AttributesSlice2<T, U>.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Index
      subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Element { get }
      typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice2<T, U>>
      typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice2<T, U>>
    }
    struct AttributesSlice3<T, U, V> : BidirectionalCollection where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey {
      typealias Index = AttributedString.Index
      typealias Element = (T.Value?, U.Value?, V.Value?, Range<AttributedString.Index>)
      struct Iterator : IteratorProtocol {
        typealias Element = AttributedString.Runs.AttributesSlice3<T, U, V>.Element
        mutating func next() -> AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator.Element?
      }
      func makeIterator() -> AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator
      var startIndex: AttributedString.Runs.AttributesSlice3<T, U, V>.Index { get }
      var endIndex: AttributedString.Runs.AttributesSlice3<T, U, V>.Index { get }
      func index(before i: AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      func index(after i: AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Index
      subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Element { get }
      typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice3<T, U, V>>
      typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice3<T, U, V>>
    }
    struct AttributesSlice4<T, U, V, W> : BidirectionalCollection where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey {
      typealias Index = AttributedString.Index
      typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, Range<AttributedString.Index>)
      struct Iterator : IteratorProtocol {
        typealias Element = AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element
        mutating func next() -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator.Element?
      }
      func makeIterator() -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator
      var startIndex: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index { get }
      var endIndex: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index { get }
      func index(before i: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      func index(after i: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
      subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element { get }
      typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice4<T, U, V, W>>
      typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice4<T, U, V, W>>
    }
    struct AttributesSlice5<T, U, V, W, X> : BidirectionalCollection where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey {
      typealias Index = AttributedString.Index
      typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, X.Value?, Range<AttributedString.Index>)
      struct Iterator : IteratorProtocol {
        typealias Element = AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element
        mutating func next() -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator.Element?
      }
      func makeIterator() -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator
      var startIndex: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index { get }
      var endIndex: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index { get }
      func index(before i: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      func index(after i: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
      subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element { get }
      typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
      typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
    }
    subscript<T, U, V, W, X>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>, w: KeyPath<AttributeDynamicLookup, W>, x: KeyPath<AttributeDynamicLookup, X>) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey { get }
    subscript<T, U, V, W>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>, w: KeyPath<AttributeDynamicLookup, W>) -> AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey { get }
    subscript<T, U, V>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>) -> AttributedString.Runs.AttributesSlice3<T, U, V> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey { get }
    subscript<T, U>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>) -> AttributedString.Runs.AttributesSlice2<T, U> where T : AttributedStringKey, U : AttributedStringKey { get }
    subscript<T>(keyPath: KeyPath<AttributeDynamicLookup, T>) -> AttributedString.Runs.AttributesSlice1<T> where T : AttributedStringKey { get }
    subscript<T, U, V, W, X>(t: T.Type, u: U.Type, v: V.Type, w: W.Type, x: X.Type) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey { get }
    subscript<T, U, V, W>(t: T.Type, u: U.Type, v: V.Type, w: W.Type) -> AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey { get }
    subscript<T, U, V>(t: T.Type, u: U.Type, v: V.Type) -> AttributedString.Runs.AttributesSlice3<T, U, V> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey { get }
    subscript<T, U>(t: T.Type, u: U.Type) -> AttributedString.Runs.AttributesSlice2<T, U> where T : AttributedStringKey, U : AttributedStringKey { get }
    subscript<T>(t: T.Type) -> AttributedString.Runs.AttributesSlice1<T> where T : AttributedStringKey { get }
    typealias Indices = DefaultIndices<AttributedString.Runs>
    typealias Iterator = IndexingIterator<AttributedString.Runs>
    typealias SubSequence = Slice<AttributedString.Runs>
  }
  var runs: AttributedString.Runs { get }
  struct CharacterView : BidirectionalCollection, RangeReplaceableCollection {
    typealias Element = Character
    typealias Index = AttributedString.Index
    init()
    var startIndex: AttributedString.Index { get }
    var endIndex: AttributedString.Index { get }
    func index(before i: AttributedString.Index) -> AttributedString.Index
    func index(after i: AttributedString.Index) -> AttributedString.Index
    subscript(index: AttributedString.Index) -> Character
    subscript(bounds: Range<AttributedString.Index>) -> Slice<AttributedString.CharacterView>
    mutating func replaceSubrange<C>(_ subrange: Range<AttributedString.CharacterView.Index>, with newElements: C) where C : Collection, C.Element == Character
    typealias Indices = DefaultIndices<AttributedString.CharacterView>
    typealias Iterator = IndexingIterator<AttributedString.CharacterView>
    typealias SubSequence = Slice<AttributedString.CharacterView>
  }
  struct UnicodeScalarView : RangeReplaceableCollection, BidirectionalCollection {
    typealias Element = UnicodeScalar
    typealias Index = AttributedString.Index
    init()
    var startIndex: AttributedString.Index { get }
    var endIndex: AttributedString.Index { get }
    func index(before i: AttributedString.Index) -> AttributedString.Index
    func index(after i: AttributedString.Index) -> AttributedString.Index
    func index(_ i: AttributedString.Index, offsetBy distance: Int) -> AttributedString.Index
    subscript(index: AttributedString.Index) -> UnicodeScalar { get }
    subscript(bounds: Range<AttributedString.Index>) -> Slice<AttributedString.UnicodeScalarView> { get }
    mutating func replaceSubrange<C>(_ subrange: Range<AttributedString.UnicodeScalarView.Index>, with newElements: C) where C : Collection, C.Element == Unicode.Scalar
    typealias Indices = DefaultIndices<AttributedString.UnicodeScalarView>
    typealias Iterator = IndexingIterator<AttributedString.UnicodeScalarView>
    typealias SubSequence = Slice<AttributedString.UnicodeScalarView>
  }
  var characters: AttributedString.CharacterView
  var unicodeScalars: AttributedString.UnicodeScalarView
  static func == (lhs: AttributedString, rhs: AttributedString) -> Bool
  init()
  /// Creates a new attributed string with the given `String` value associated with the given
  /// attributes.
  init(_ string: String, attributes: AttributeContainer = .init())
  /// Creates a new attributed string with the given `Substring` value associated with the given
  /// attributes.
  init(_ substring: Substring, attributes: AttributeContainer = .init())
  init<S>(_ elements: S, attributes: AttributeContainer = .init()) where S : Sequence, S.Element == Character
  init(_ substring: AttributedSubstring)
  init<S, T>(_ other: T, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope, T : AttributedStringProtocol
  init<S, T>(_ other: T, including scope: S.Type) where S : AttributeScope, T : AttributedStringProtocol
  static func + <T>(lhs: AttributedString, rhs: T) -> AttributedString where T : AttributedStringProtocol
  static func += <T>(lhs: inout AttributedString, rhs: T) where T : AttributedStringProtocol
  static func + (lhs: AttributedString, rhs: AttributedString) -> AttributedString
  static func += (lhs: inout AttributedString, rhs: AttributedString)
  subscript<R>(bounds: R) -> AttributedSubstring where R : RangeExpression, R.Bound == AttributedString.Index
  mutating func append<S>(_ s: S) where S : AttributedStringProtocol
  mutating func insert<S>(_ s: S, at index: AttributedString.Index) where S : AttributedStringProtocol
  mutating func removeSubrange<R>(_ range: R) where R : RangeExpression, R.Bound == AttributedString.Index
  mutating func replaceSubrange<R, S>(_ range: R, with s: S) where R : RangeExpression, S : AttributedStringProtocol, R.Bound == AttributedString.Index
  var startIndex: AttributedString.Index { get }
  var endIndex: AttributedString.Index { get }
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : Codable {
  func encode(to encoder: Encoder) throws
  init(from decoder: Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : CodableWithConfiguration {
  func encode(to encoder: Encoder, configuration: AttributeScopeCodableConfiguration) throws
  init(from decoder: Decoder, configuration: AttributeScopeCodableConfiguration) throws
  typealias DecodingConfiguration = AttributeScopeCodableConfiguration
  typealias EncodingConfiguration = AttributeScopeCodableConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  func inflected() -> AttributedString
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
  init(_ nsStr: NSAttributedString)
  init<S>(_ nsStr: NSAttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope
  init<S>(_ nsStr: NSAttributedString, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : ExpressibleByStringLiteral {
  init(stringLiteral value: String)
  typealias ExtendedGraphemeClusterLiteralType = String
  typealias StringLiteralType = String
  typealias UnicodeScalarLiteralType = String
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
  struct MarkdownParsingOptions {
    enum FailurePolicy : Int {
      case throwError
      case returnPartiallyParsedIfPossible
      init?(rawValue: Int)
      typealias RawValue = Int
      var rawValue: Int { get }
    }
    enum InterpretedSyntax : Int {
      case full
      case inlineOnly
      case inlineOnlyPreservingWhitespace
      init?(rawValue: Int)
      typealias RawValue = Int
      var rawValue: Int { get }
    }
    var allowsExtendedAttributes: Bool
    var interpretedSyntax: AttributedString.MarkdownParsingOptions.InterpretedSyntax
    var failurePolicy: AttributedString.MarkdownParsingOptions.FailurePolicy
    var languageCode: String?
    init(allowsExtendedAttributes: Bool = false, interpretedSyntax: AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: String? = nil)
  }
  init<S>(markdown: String, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
  init(markdown: String, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
  init<S>(markdown: String, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
  init<S>(markdown: Data, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
  init(markdown: Data, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
  init<S>(markdown: Data, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
  init<S>(contentsOf url: URL, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
  init(contentsOf url: URL, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
  init<S>(contentsOf url: URL, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {
  /// Options that affect the localized formatting of AttributedString
  struct FormattingOptions : OptionSet {
    let rawValue: UInt
    init(rawValue: UInt)
    /// This option causes ReplacementStringAttribute attributes to be applied to the string to indicate the ranges of the inserted arguments. The values of these attributes will begin with 1 for the first interpolated argument in the `StringLocalizationValue`, 2 for the second, and so-on. However, because localizers are able to change the order in which arguments appear in the final string, these index values may appear in a different order.
    static let applyReplacementIndexAttribute: AttributedString.FormattingOptions
    typealias ArrayLiteralElement = AttributedString.FormattingOptions
    typealias Element = AttributedString.FormattingOptions
    typealias RawValue = UInt
  }
  /// Options that affect how an AttributedString is interpolated during localized formatting.
  struct InterpolationOptions : OptionSet {
    let rawValue: UInt
    init(rawValue: UInt)
    /// By default, interpolating an AttributedString will result in the final string having all attributes present at its interpolation point, plus all attributes from the beginning of the interpolated AttributedString.
    /// Specify this option to instead indicate that pre-existing attributes at the point of interpolation (e.g., those specified with Markdown syntax) must be ignored. The result will only have the attributes from the interpolated AttributedString.
    /// This option has no effect when formatting a plain-text String, since all attributes will be stripped anyway.
    static let insertAttributesWithoutMerging: AttributedString.InterpolationOptions
    typealias ArrayLiteralElement = AttributedString.InterpolationOptions
    typealias Element = AttributedString.InterpolationOptions
    typealias RawValue = UInt
  }
  @_semantics("attributed_string.init_localized") init(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil)
  @_semantics("attributed_string.init_localized") init<S>(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope
  @_semantics("attributed_string.init_localized") init<S>(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: S.Type) where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.AttributeMergePolicy : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.AttributeMergePolicy : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Index {
  init?<S>(_ sourcePosition: String.Index, within target: S) where S : AttributedStringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> __NSAttributedStringMarkdownParsingOptions
  static func _forceBridgeFromObjectiveC(_ x: __NSAttributedStringMarkdownParsingOptions, result: inout AttributedString.MarkdownParsingOptions?)
  static func _conditionallyBridgeFromObjectiveC(_ x: __NSAttributedStringMarkdownParsingOptions, result: inout AttributedString.MarkdownParsingOptions?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: __NSAttributedStringMarkdownParsingOptions?) -> AttributedString.MarkdownParsingOptions
  typealias _ObjectiveCType = __NSAttributedStringMarkdownParsingOptions
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol AttributedStringAttributeMutation {
  mutating func setAttributes(_ attributes: AttributeContainer)
  mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy)
  mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol AttributedStringKey {
  associatedtype Value : Hashable
  static var name: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringKey {
  var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup protocol AttributedStringProtocol : AttributedStringAttributeMutation, CustomStringConvertible, Hashable {
  var startIndex: AttributedString.Index { get }
  var endIndex: AttributedString.Index { get }
  var runs: AttributedString.Runs { get }
  var characters: AttributedString.CharacterView { get }
  var unicodeScalars: AttributedString.UnicodeScalarView { get }
  subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey { get set }
  subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey { get set }
  subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope { get set }
  subscript<R>(bounds: R) -> AttributedSubstring where R : RangeExpression, R.Bound == AttributedString.Index { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
  func settingAttributes(_ attributes: AttributeContainer) -> AttributedString
  func mergingAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew) -> AttributedString
  func replacingAttributes(_ attributes: AttributeContainer, with others: AttributeContainer) -> AttributedString
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
  var description: String { get }
  func hash(into hasher: inout Hasher)
  static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : AttributedStringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
  func index(afterCharacter i: AttributedString.Index) -> AttributedString.Index
  func index(beforeCharacter i: AttributedString.Index) -> AttributedString.Index
  func index(_ i: AttributedString.Index, offsetByCharacters distance: Int) -> AttributedString.Index
  func index(afterUnicodeScalar i: AttributedString.Index) -> AttributedString.Index
  func index(beforeUnicodeScalar i: AttributedString.Index) -> AttributedString.Index
  func index(_ i: AttributedString.Index, offsetByUnicodeScalars distance: Int) -> AttributedString.Index
  func index(afterRun i: AttributedString.Index) -> AttributedString.Index
  func index(beforeRun i: AttributedString.Index) -> AttributedString.Index
  func index(_ i: AttributedString.Index, offsetByRuns distance: Int) -> AttributedString.Index
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {
  func range<T>(of stringToFind: T, options: String.CompareOptions = [], locale: Locale? = nil) -> Range<AttributedString.Index>? where T : StringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup struct AttributedSubstring {
  init()
  var base: AttributedString { get }
  var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring : AttributedStringProtocol {
  var startIndex: AttributedString.Index { get }
  var endIndex: AttributedString.Index { get }
  static func == (lhs: AttributedSubstring, rhs: AttributedSubstring) -> Bool
  mutating func setAttributes(_ attributes: AttributeContainer)
  mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)
  mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
  var runs: AttributedString.Runs { get }
  var characters: AttributedString.CharacterView { get }
  var unicodeScalars: AttributedString.UnicodeScalarView { get }
  subscript<R>(bounds: R) -> AttributedSubstring where R : RangeExpression, R.Bound == AttributedString.Index { get }
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring {
  subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey
  subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey
  subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct ByteCountFormatStyle : FormatStyle {
  var style: ByteCountFormatStyle.Style
  var allowedUnits: ByteCountFormatStyle.Units
  var spellsOutZero: Bool
  var includesActualByteCount: Bool
  var locale: Locale
  var attributed: ByteCountFormatStyle.Attributed
  func format(_ value: Int64) -> String
  func locale(_ locale: Locale) -> ByteCountFormatStyle
  init(style: ByteCountFormatStyle.Style = .file, allowedUnits: ByteCountFormatStyle.Units = .all, spellsOutZero: Bool = true, includesActualByteCount: Bool = false, locale: Locale = .autoupdatingCurrent)
  enum Style : Int, Codable, Hashable {
    case file
    case memory
    case decimal
    case binary
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  struct Units : OptionSet, Codable, Hashable {
    var rawValue: UInt
    init(rawValue: UInt)
    static var bytes: ByteCountFormatStyle.Units { get }
    static var kb: ByteCountFormatStyle.Units { get }
    static var mb: ByteCountFormatStyle.Units { get }
    static var gb: ByteCountFormatStyle.Units { get }
    static var tb: ByteCountFormatStyle.Units { get }
    static var pb: ByteCountFormatStyle.Units { get }
    static var eb: ByteCountFormatStyle.Units { get }
    static var zb: ByteCountFormatStyle.Units { get }
    static var ybOrHigher: ByteCountFormatStyle.Units { get }
    static var all: ByteCountFormatStyle.Units { get }
    static var `default`: ByteCountFormatStyle.Units { get }
    typealias ArrayLiteralElement = ByteCountFormatStyle.Units
    typealias Element = ByteCountFormatStyle.Units
    typealias RawValue = UInt
  }
  struct Attributed : FormatStyle {
    var style: ByteCountFormatStyle.Style
    var allowedUnits: ByteCountFormatStyle.Units
    var spellsOutZero: Bool
    var includesActualByteCount: Bool
    var locale: Locale
    func locale(_ locale: Locale) -> ByteCountFormatStyle.Attributed
    func format(_ value: Int64) -> AttributedString
    func hash(into hasher: inout Hasher)
    static func == (a: ByteCountFormatStyle.Attributed, b: ByteCountFormatStyle.Attributed) -> Bool
    typealias FormatInput = Int64
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  func hash(into hasher: inout Hasher)
  static func == (a: ByteCountFormatStyle, b: ByteCountFormatStyle) -> Bool
  typealias FormatInput = Int64
  typealias FormatOutput = String
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ByteCountFormatStyle.Style : RawRepresentable {
}

/**
 `Calendar` encapsulates information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. It provides information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.
*/
struct Calendar : Hashable, Equatable, ReferenceConvertible {
  typealias ReferenceType = NSCalendar
  /// Calendar supports many different kinds of calendars. Each is identified by an identifier here.
  enum Identifier {
    /// The common calendar in Europe, the Western Hemisphere, and elsewhere.
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    /// A simple tabular Islamic calendar using the astronomical/Thursday epoch of CE 622 July 15
    @available(macOS 10.10, iOS 8.0, *)
    case islamicTabular
    /// The Islamic Umm al-Qura calendar used in Saudi Arabia. This is based on astronomical calculation, instead of tabular behavior.
    @available(macOS 10.10, iOS 8.0, *)
    case islamicUmmAlQura
    static func == (a: Calendar.Identifier, b: Calendar.Identifier) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// An enumeration for the various components of a calendar date.
  ///
  /// Several `Calendar` APIs use either a single unit or a set of units as input to a search algorithm.
  ///
  /// - seealso: `DateComponents`
  enum Component {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    static func == (a: Calendar.Component, b: Calendar.Component) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// Returns the user's current calendar.
  ///
  /// This calendar does not track changes that the user makes to their preferences.
  static var current: Calendar { get }
  /// A Calendar that tracks changes to user's preferred calendar.
  ///
  /// If mutated, this calendar will no longer track the user's preferred calendar.
  ///
  /// - note: The autoupdating Calendar will only compare equal to another autoupdating Calendar.
  static var autoupdatingCurrent: Calendar { get }
  /// Returns a new Calendar.
  ///
  /// - parameter identifier: The kind of calendar to use.
  init(identifier: __shared Calendar.Identifier)
  /// The identifier of the calendar.
  var identifier: Calendar.Identifier { get }
  /// The locale of the calendar.
  var locale: Locale?
  /// The time zone of the calendar.
  var timeZone: TimeZone
  /// The first weekday of the calendar.
  var firstWeekday: Int
  /// The number of minimum days in the first week.
  var minimumDaysInFirstWeek: Int
  /// A list of eras in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["BC", "AD"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var eraSymbols: [String] { get }
  /// A list of longer-named eras in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Before Christ", "Anno Domini"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var longEraSymbols: [String] { get }
  /// A list of months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var monthSymbols: [String] { get }
  /// A list of shorter-named months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortMonthSymbols: [String] { get }
  /// A list of very-shortly-named months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var veryShortMonthSymbols: [String] { get }
  /// A list of standalone months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var standaloneMonthSymbols: [String] { get }
  /// A list of shorter-named standalone months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortStandaloneMonthSymbols: [String] { get }
  /// A list of very-shortly-named standalone months in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var veryShortStandaloneMonthSymbols: [String] { get }
  /// A list of weekdays in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var weekdaySymbols: [String] { get }
  /// A list of shorter-named weekdays in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortWeekdaySymbols: [String] { get }
  /// A list of very-shortly-named weekdays in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["S", "M", "T", "W", "T", "F", "S"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var veryShortWeekdaySymbols: [String] { get }
  /// A list of standalone weekday names in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var standaloneWeekdaySymbols: [String] { get }
  /// A list of shorter-named standalone weekdays in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortStandaloneWeekdaySymbols: [String] { get }
  /// A list of very-shortly-named weekdays in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["S", "M", "T", "W", "T", "F", "S"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var veryShortStandaloneWeekdaySymbols: [String] { get }
  /// A list of quarter names in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var quarterSymbols: [String] { get }
  /// A list of shorter-named quarters in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Q1", "Q2", "Q3", "Q4"]`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortQuarterSymbols: [String] { get }
  /// A list of standalone quarter names in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var standaloneQuarterSymbols: [String] { get }
  /// A list of shorter-named standalone quarters in this calendar, localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `["Q1", "Q2", "Q3", "Q4"]`.
  /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var shortStandaloneQuarterSymbols: [String] { get }
  /// The symbol used to represent "AM", localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `"AM"`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var amSymbol: String { get }
  /// The symbol used to represent "PM", localized to the Calendar's `locale`.
  ///
  /// For example, for English in the Gregorian calendar, returns `"PM"`.
  ///
  /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
  var pmSymbol: String { get }
  /// Returns the minimum range limits of the values that a given component can take on in the receiver.
  ///
  /// As an example, in the Gregorian calendar the minimum range of values for the Day component is 1-28.
  /// - parameter component: A component to calculate a range for.
  /// - returns: The range, or nil if it could not be calculated.
  func minimumRange(of component: Calendar.Component) -> Range<Int>?
  /// The maximum range limits of the values that a given component can take on in the receive
  ///
  /// As an example, in the Gregorian calendar the maximum range of values for the Day component is 1-31.
  /// - parameter component: A component to calculate a range for.
  /// - returns: The range, or nil if it could not be calculated.
  func maximumRange(of component: Calendar.Component) -> Range<Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  func range(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> NSRange
  /// Returns the range of absolute time values that a smaller calendar component (such as a day) can take on in a larger calendar component (such as a month) that includes a specified absolute time.
  ///
  /// You can use this method to calculate, for example, the range the `day` component can take on in the `month` in which `date` lies.
  /// - parameter smaller: The smaller calendar component.
  /// - parameter larger: The larger calendar component.
  /// - parameter date: The absolute time for which the calculation is performed.
  /// - returns: The range of absolute time values smaller can take on in larger at the time specified by date. Returns `nil` if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined).
  func range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Range<Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  func range(of unit: NSCalendar.Unit, start datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, for date: Date) -> Bool
  /// Returns, via two inout parameters, the starting time and duration of a given calendar component that contains a given date.
  ///
  /// - seealso: `range(of:for:)`
  /// - seealso: `dateInterval(of:for:)`
  /// - parameter component: A calendar component.
  /// - parameter start: Upon return, the starting time of the calendar component that contains the date.
  /// - parameter interval: Upon return, the duration of the calendar component that contains the date.
  /// - parameter date: The specified date.
  /// - returns: `true` if the starting time and duration of a component could be calculated, otherwise `false`.
  func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -> Bool
  /// Returns the starting time and duration of a given calendar component that contains a given date.
  ///
  /// - parameter component: A calendar component.
  /// - parameter date: The specified date.
  /// - returns: A new `DateInterval` if the starting time and duration of a component could be calculated, otherwise `nil`.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  func dateInterval(of component: Calendar.Component, for date: Date) -> DateInterval?
  /// Returns, for a given absolute time, the ordinal number of a smaller calendar component (such as a day) within a specified larger calendar component (such as a week).
  ///
  /// The ordinality is in most cases not the same as the decomposed value of the component. Typically return values are 1 and greater. For example, the time 00:45 is in the first hour of the day, and for components `hour` and `day` respectively, the result would be 1. An exception is the week-in-month calculation, which returns 0 for days before the first week in the month containing the date.
  ///
  /// - note: Some computations can take a relatively long time.
  /// - parameter smaller: The smaller calendar component.
  /// - parameter larger: The larger calendar component.
  /// - parameter date: The absolute time for which the calculation is performed.
  /// - returns: The ordinal number of smaller within larger at the time specified by date. Returns `nil` if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined).
  func ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Int?
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, year yearValuePointer: UnsafeMutablePointer<Int>?, month monthValuePointer: UnsafeMutablePointer<Int>?, day dayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, yearForWeekOfYear yearValuePointer: UnsafeMutablePointer<Int>?, weekOfYear weekValuePointer: UnsafeMutablePointer<Int>?, weekday weekdayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  func getHour(_ hourValuePointer: UnsafeMutablePointer<Int>?, minute minuteValuePointer: UnsafeMutablePointer<Int>?, second secondValuePointer: UnsafeMutablePointer<Int>?, nanosecond nanosecondValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  func date(byAdding unit: NSCalendar.Unit, value: Int, to date: Date, options: NSCalendar.Options = []) -> Date?
  /// Returns a new `Date` representing the date calculated by adding components to a given date.
  ///
  /// - parameter components: A set of values to add to the date.
  /// - parameter date: The starting date.
  /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
  /// - returns: A new date, or nil if a date could not be calculated with the given input.
  func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -> Date?
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  func date(byAdding comps: DateComponents, to date: Date, options opts: NSCalendar.Options = []) -> Date?
  /// Returns a new `Date` representing the date calculated by adding an amount of a specific component to a given date.
  ///
  /// - parameter component: A single component to add.
  /// - parameter value: The value of the specified component to add.
  /// - parameter date: The starting date.
  /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
  /// - returns: A new date, or nil if a date could not be calculated with the given input.
  @available(iOS 8.0, *)
  func date(byAdding component: Calendar.Component, value: Int, to date: Date, wrappingComponents: Bool = false) -> Date?
  /// Returns a date created from the specified components.
  ///
  /// - parameter components: Used as input to the search algorithm for finding a corresponding date.
  /// - returns: A new `Date`, or nil if a date could not be found which matches the components.
  func date(from components: DateComponents) -> Date?
  @available(*, unavailable, renamed: "dateComponents(_:from:)")
  func components(_ unitFlags: NSCalendar.Unit, from date: Date) -> DateComponents
  /// Returns all the date components of a date, using the calendar time zone.
  ///
  /// - note: If you want "date information in a given time zone" in order to display it, you should use `DateFormatter` to format the date.
  /// - parameter date: The `Date` to use.
  /// - returns: The date components of the specified date.
  func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(in:from:)")
  func components(in timezone: TimeZone, from date: Date) -> DateComponents
  /// Returns all the date components of a date, as if in a given time zone (instead of the `Calendar` time zone).
  ///
  /// The time zone overrides the time zone of the `Calendar` for the purposes of this calculation.
  /// - note: If you want "date information in a given time zone" in order to display it, you should use `DateFormatter` to format the date.
  /// - parameter timeZone: The `TimeZone` to use.
  /// - parameter date: The `Date` to use.
  /// - returns: All components, calculated using the `Calendar` and `TimeZone`.
  @available(iOS 8.0, *)
  func dateComponents(in timeZone: TimeZone, from date: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  func components(_ unitFlags: NSCalendar.Unit, from startingDate: Date, to resultDate: Date, options opts: NSCalendar.Options = []) -> DateComponents
  /// Returns the difference between two dates.
  ///
  /// - parameter components: Which components to compare.
  /// - parameter start: The starting date.
  /// - parameter end: The ending date.
  /// - returns: The result of calculating the difference from start to end.
  func dateComponents(_ components: Set<Calendar.Component>, from start: Date, to end: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  func components(_ unitFlags: NSCalendar.Unit, from startingDateComp: DateComponents, to resultDateComp: DateComponents, options: NSCalendar.Options = []) -> DateComponents
  /// Returns the difference between two dates specified as `DateComponents`.
  ///
  /// For components which are not specified in each `DateComponents`, but required to specify an absolute date, the base value of the component is assumed.  For example, for an `DateComponents` with just a `year` and a `month` specified, a `day` of 1, and an `hour`, `minute`, `second`, and `nanosecond` of 0 are assumed.
  /// Calendrical calculations with unspecified `year` or `year` value prior to the start of a calendar are not advised.
  /// For each `DateComponents`, if its `timeZone` property is set, that time zone is used for it. If the `calendar` property is set, that is used rather than the receiving calendar, and if both the `calendar` and `timeZone` are set, the `timeZone` property value overrides the time zone of the `calendar` property.
  ///
  /// - parameter components: Which components to compare.
  /// - parameter start: The starting date components.
  /// - parameter end: The ending date components.
  /// - returns: The result of calculating the difference from start to end.
  @available(iOS 8.0, *)
  func dateComponents(_ components: Set<Calendar.Component>, from start: DateComponents, to end: DateComponents) -> DateComponents
  /// Returns the value for one component of a date.
  ///
  /// - parameter component: The component to calculate.
  /// - parameter date: The date to use.
  /// - returns: The value for the component.
  @available(iOS 8.0, *)
  func component(_ component: Calendar.Component, from date: Date) -> Int
  @available(*, unavailable, message: "Use date(from:) instead")
  func date(era: Int, year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, nanosecond: Int) -> Date?
  @available(*, unavailable, message: "Use date(from:) instead")
  func date(era: Int, yearForWeekOfYear: Int, weekOfYear: Int, weekday: Int, hour: Int, minute: Int, second: Int, nanosecond: Int) -> Date?
  /// Returns the first moment of a given Date, as a Date.
  ///
  /// For example, pass in `Date()`, if you want the start of today.
  /// If there were two midnights, it returns the first.  If there was none, it returns the first moment that did exist.
  /// - parameter date: The date to search.
  /// - returns: The first moment of the given date.
  @available(iOS 8.0, *)
  func startOfDay(for date: Date) -> Date
  @available(*, unavailable, renamed: "compare(_:to:toGranularity:)")
  func compare(_ date1: Date, to date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> ComparisonResult
  /// Compares the given dates down to the given component, reporting them `orderedSame` if they are the same in the given component and all larger components, otherwise either `orderedAscending` or `orderedDescending`.
  ///
  /// - parameter date1: A date to compare.
  /// - parameter date2: A date to compare.
  /// - parameter: component: A granularity to compare. For example, pass `.hour` to check if two dates are in the same hour.
  @available(iOS 8.0, *)
  func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -> ComparisonResult
  @available(*, unavailable, renamed: "isDate(_:equalTo:toGranularity:)")
  func isDate(_ date1: Date, equalTo date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> Bool
  /// Compares the given dates down to the given component, reporting them equal if they are the same in the given component and all larger components.
  ///
  /// - parameter date1: A date to compare.
  /// - parameter date2: A date to compare.
  /// - parameter component: A granularity to compare. For example, pass `.hour` to check if two dates are in the same hour.
  /// - returns: `true` if the given date is within tomorrow.
  @available(iOS 8.0, *)
  func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Calendar.Component) -> Bool
  /// Returns `true` if the given date is within the same day as another date, as defined by the calendar and calendar's locale.
  ///
  /// - parameter date1: A date to check for containment.
  /// - parameter date2: A date to check for containment.
  /// - returns: `true` if `date1` and `date2` are in the same day.
  @available(iOS 8.0, *)
  func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool
  /// Returns `true` if the given date is within today, as defined by the calendar and calendar's locale.
  ///
  /// - parameter date: The specified date.
  /// - returns: `true` if the given date is within today.
  @available(iOS 8.0, *)
  func isDateInToday(_ date: Date) -> Bool
  /// Returns `true` if the given date is within yesterday, as defined by the calendar and calendar's locale.
  ///
  /// - parameter date: The specified date.
  /// - returns: `true` if the given date is within yesterday.
  @available(iOS 8.0, *)
  func isDateInYesterday(_ date: Date) -> Bool
  /// Returns `true` if the given date is within tomorrow, as defined by the calendar and calendar's locale.
  ///
  /// - parameter date: The specified date.
  /// - returns: `true` if the given date is within tomorrow.
  @available(iOS 8.0, *)
  func isDateInTomorrow(_ date: Date) -> Bool
  /// Returns `true` if the given date is within a weekend period, as defined by the calendar and calendar's locale.
  ///
  /// - parameter date: The specified date.
  /// - returns: `true` if the given date is within a weekend.
  @available(iOS 8.0, *)
  func isDateInWeekend(_ date: Date) -> Bool
  @available(*, unavailable, message: "use dateIntervalOfWeekend(containing:start:interval:) instead")
  func range(ofWeekendStart datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, containing date: Date) -> Bool
  /// Find the range of the weekend around the given date, returned via two by-reference parameters.
  ///
  /// Note that a given entire day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
  /// - seealso: `dateIntervalOfWeekend(containing:)`
  /// - parameter date: The date at which to start the search.
  /// - parameter start: When the result is `true`, set
  /// - returns: `true` if a date range could be found, and `false` if the date is not in a weekend.
  @available(iOS 8.0, *)
  func dateIntervalOfWeekend(containing date: Date, start: inout Date, interval: inout TimeInterval) -> Bool
  /// Returns a `DateInterval` of the weekend contained by the given date, or nil if the date is not in a weekend.
  ///
  /// - parameter date: The date contained in the weekend.
  /// - returns: A `DateInterval`, or nil if the date is not in a weekend.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  func dateIntervalOfWeekend(containing date: Date) -> DateInterval?
  @available(*, unavailable, message: "use nextWeekend(startingAfter:start:interval:direction:) instead")
  func nextWeekendStart(_ datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, options: NSCalendar.Options = [], after date: Date) -> Bool
  /// Returns the range of the next weekend via two inout parameters. The weekend starts strictly after the given date.
  ///
  /// If `direction` is `.backward`, then finds the previous weekend range strictly before the given date.
  ///
  /// Note that a given entire Day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
  /// - parameter date: The date at which to begin the search.
  /// - parameter direction: Which direction in time to search. The default value is `.forward`.
  /// - returns: A `DateInterval`, or nil if the weekend could not be found.
  @available(iOS 8.0, *)
  func nextWeekend(startingAfter date: Date, start: inout Date, interval: inout TimeInterval, direction: Calendar.SearchDirection = .forward) -> Bool
  /// Returns a `DateInterval` of the next weekend, which starts strictly after the given date.
  ///
  /// If `direction` is `.backward`, then finds the previous weekend range strictly before the given date.
  ///
  /// Note that a given entire Day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
  /// - parameter date: The date at which to begin the search.
  /// - parameter direction: Which direction in time to search. The default value is `.forward`.
  /// - returns: A `DateInterval`, or nil if weekends do not exist in the specific calendar or locale.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  func nextWeekend(startingAfter date: Date, direction: Calendar.SearchDirection = .forward) -> DateInterval?
  /// The direction in time to search.
  enum SearchDirection {
    /// Search for a date later in time than the start date.
    case forward
    /// Search for a date earlier in time than the start date.
    case backward
    static func == (a: Calendar.SearchDirection, b: Calendar.SearchDirection) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// Determines which result to use when a time is repeated on a day in a calendar (for example, during a daylight saving transition when the times between 2:00am and 3:00am may happen twice).
  enum RepeatedTimePolicy {
    /// If there are two or more matching times (all the components are the same, including isLeapMonth) before the end of the next instance of the next higher component to the highest specified component, then the algorithm will return the first occurrence.
    case first
    /// If there are two or more matching times (all the components are the same, including isLeapMonth) before the end of the next instance of the next higher component to the highest specified component, then the algorithm will return the last occurrence.
    case last
    static func == (a: Calendar.RepeatedTimePolicy, b: Calendar.RepeatedTimePolicy) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// A hint to the search algorithm to control the method used for searching for dates.
  enum MatchingPolicy {
    /// If there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the algorithm will return the next existing time which exists.
    ///
    /// For example, during a daylight saving transition there may be no 2:37am. The result would then be 3:00am, if that does exist.
    case nextTime
    /// If specified, and there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the method will return the next existing value of the missing component and preserves the lower components' values (e.g., no 2:37am results in 3:37am, if that exists).
    case nextTimePreservingSmallerComponents
    /// If there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the algorithm will return the previous existing value of the missing component and preserves the lower components' values.
    ///
    /// For example, during a daylight saving transition there may be no 2:37am. The result would then be 1:37am, if that does exist.
    case previousTimePreservingSmallerComponents
    /// If specified, the algorithm travels as far forward or backward as necessary looking for a match.
    ///
    /// For example, if searching for Feb 29 in the Gregorian calendar, the algorithm may choose March 1 instead (for example, if the year is not a leap year). If you wish to find the next Feb 29 without the algorithm adjusting the next higher component in the specified `DateComponents`, then use the `strict` option.
    /// - note: There are ultimately implementation-defined limits in how far distant the search will go.
    case strict
    static func == (a: Calendar.MatchingPolicy, b: Calendar.MatchingPolicy) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  @available(*, unavailable, message: "use nextWeekend(startingAfter:matching:matchingPolicy:repeatedTimePolicy:direction:using:) instead")
  func enumerateDates(startingAfter start: Date, matching comps: DateComponents, options opts: NSCalendar.Options = [], using block: (Date?, Bool, UnsafeMutablePointer<ObjCBool>) -> Void)
  /// Computes the dates which match (or most closely match) a given set of components, and calls the closure once for each of them, until the enumeration is stopped.
  ///
  /// There will be at least one intervening date which does not match all the components (or the given date itself must not match) between the given date and any result.
  ///
  /// If `direction` is set to `.backward`, this method finds the previous match before the given date. The intent is that the same matches as for a `.forward` search will be found (that is, if you are enumerating forwards or backwards for each hour with minute "27", the seconds in the date you will get in forwards search would obviously be 00, and the same will be true in a backwards search in order to implement this rule.  Similarly for DST backwards jumps which repeats times, you'll get the first match by default, where "first" is defined from the point of view of searching forwards.  So, when searching backwards looking for a particular hour, with no minute and second specified, you don't get a minute and second of 59:59 for the matching hour (which would be the nominal first match within a given hour, given the other rules here, when searching backwards).
  ///
  /// If an exact match is not possible, and requested with the `strict` option, nil is passed to the closure and the enumeration ends.  (Logically, since an exact match searches indefinitely into the future, if no match is found there's no point in continuing the enumeration.)
  ///
  /// Result dates have an integer number of seconds (as if 0 was specified for the nanoseconds property of the `DateComponents` matching parameter), unless a value was set in the nanoseconds property, in which case the result date will have that number of nanoseconds (or as close as possible with floating point numbers).
  ///
  /// The enumeration is stopped by setting `stop` to `true` in the closure and returning. It is not necessary to set `stop` to `false` to keep the enumeration going.
  /// - parameter start: The `Date` at which to start the search.
  /// - parameter components: The `DateComponents` to use as input to the search algorithm.
  /// - parameter matchingPolicy: Determines the behavior of the search algorithm when the input produces an ambiguous result.
  /// - parameter repeatedTimePolicy: Determines the behavior of the search algorithm when the input produces a time that occurs twice on a particular day.
  /// - parameter direction: Which direction in time to search. The default value is `.forward`, which means later in time.
  /// - parameter block: A closure that is called with search results.
  @available(iOS 8.0, *)
  func enumerateDates(startingAfter start: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward, using block: (_ result: Date?, _ exactMatch: Bool, _ stop: inout Bool) -> Void)
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  func nextDate(after date: Date, matching comps: DateComponents, options: NSCalendar.Options = []) -> Date?
  /// Computes the next date which matches (or most closely matches) a given set of components.
  ///
  /// The general semantics follow those of the `enumerateDates` function.
  /// To compute a sequence of results, use the `enumerateDates` function, rather than looping and calling this method with the previous loop iteration's result.
  /// - parameter date: The starting date.
  /// - parameter components: The components to search for.
  /// - parameter matchingPolicy: Specifies the technique the search algorithm uses to find results. Default value is `.nextTime`.
  /// - parameter repeatedTimePolicy: Specifies the behavior when multiple matches are found. Default value is `.first`.
  /// - parameter direction: Specifies the direction in time to search. Default is `.forward`.
  /// - returns: A `Date` representing the result of the search, or `nil` if a result could not be found.
  @available(iOS 8.0, *)
  func nextDate(after date: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  func nextDate(after date: Date, matchingHour hourValue: Int, minute minuteValue: Int, second secondValue: Int, options: NSCalendar.Options = []) -> Date?
  @available(*, unavailable, renamed: "date(bySetting:value:of:)")
  func date(bySettingUnit unit: NSCalendar.Unit, value v: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?
  /// Returns a new `Date` representing the date calculated by setting a specific component to a given time, and trying to keep lower components the same.  If the component already has that value, this may result in a date which is the same as the given date.
  ///
  /// Changing a component's value often will require higher or coupled components to change as well.  For example, setting the Weekday to Thursday usually will require the Day component to change its value, and possibly the Month and Year as well.
  /// If no such time exists, the next available time is returned (which could, for example, be in a different day, week, month, ... than the nominal target date).  Setting a component to something which would be inconsistent forces other components to change; for example, setting the Weekday to Thursday probably shifts the Day and possibly Month and Year.
  /// The exact behavior of this method is implementation-defined. For example, if changing the weekday to Thursday, does that move forward to the next, backward to the previous, or to the nearest Thursday? The algorithm will try to produce a result which is in the next-larger component to the one given (there's a table of this mapping at the top of this document).  So for the "set to Thursday" example, find the Thursday in the Week in which the given date resides (which could be a forwards or backwards move, and not necessarily the nearest Thursday). For more control over the exact behavior, use `nextDate(after:matching:matchingPolicy:behavior:direction:)`.
  @available(iOS 8.0, *)
  func date(bySetting component: Calendar.Component, value: Int, of date: Date) -> Date?
  @available(*, unavailable, message: "use date(bySettingHour:minute:second:of:matchingPolicy:repeatedTimePolicy:direction:) instead")
  func date(bySettingHour h: Int, minute m: Int, second s: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?
  /// Returns a new `Date` representing the date calculated by setting hour, minute, and second to a given time on a specified `Date`.
  ///
  /// If no such time exists, the next available time is returned (which could, for example, be in a different day than the nominal target date).
  /// The intent is to return a date on the same day as the original date argument.  This may result in a date which is backward than the given date, of course.
  /// - parameter hour: A specified hour.
  /// - parameter minute: A specified minute.
  /// - parameter second: A specified second.
  /// - parameter date: The date to start calculation with.
  /// - parameter matchingPolicy: Specifies the technique the search algorithm uses to find results. Default value is `.nextTime`.
  /// - parameter repeatedTimePolicy: Specifies the behavior when multiple matches are found. Default value is `.first`.
  /// - parameter direction: Specifies the direction in time to search. Default is `.forward`.
  /// - returns: A `Date` representing the result of the search, or `nil` if a result could not be found.
  @available(iOS 8.0, *)
  func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?
  /// Determine if the `Date` has all of the specified `DateComponents`.
  ///
  /// It may be useful to test the return value of `nextDate(after:matching:matchingPolicy:behavior:direction:)` to find out if the components were obeyed or if the method had to fudge the result value due to missing time (for example, a daylight saving time transition).
  ///
  /// - returns: `true` if the date matches all of the components, otherwise `false`.
  @available(iOS 8.0, *)
  func date(_ date: Date, matchesComponents components: DateComponents) -> Bool
  func hash(into hasher: inout Hasher)
  static func == (lhs: Calendar, rhs: Calendar) -> Bool
  var hashValue: Int { get }
}

extension Calendar : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension Calendar : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSCalendar
  static func _forceBridgeFromObjectiveC(_ input: NSCalendar, result: inout Calendar?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSCalendar, result: inout Calendar?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSCalendar?) -> Calendar
  typealias _ObjectiveCType = NSCalendar
}

extension Calendar : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension Calendar.Identifier : Equatable {
}

extension Calendar.Identifier : Hashable {
}

extension Calendar.Component : Equatable {
}

extension Calendar.Component : Hashable {
}

extension Calendar.SearchDirection : Equatable {
}

extension Calendar.SearchDirection : Hashable {
}

extension Calendar.RepeatedTimePolicy : Equatable {
}

extension Calendar.RepeatedTimePolicy : Hashable {
}

extension Calendar.MatchingPolicy : Equatable {
}

extension Calendar.MatchingPolicy : Hashable {
}

/**
 A `CharacterSet` represents a set of Unicode-compliant characters. Foundation types use `CharacterSet` to group characters together for searching operations, so that they can find any of a particular set of characters during a search.
 
 This type provides "copy-on-write" behavior, and is also bridged to the Objective-C `NSCharacterSet` class.
*/
struct CharacterSet : ReferenceConvertible, Equatable, Hashable, SetAlgebra {
  typealias ReferenceType = NSCharacterSet
  /// Initialize an empty instance.
  init()
  /// Initialize with a range of integers.
  ///
  /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
  init(charactersIn range: Range<Unicode.Scalar>)
  /// Initialize with a closed range of integers.
  ///
  /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
  init(charactersIn range: ClosedRange<Unicode.Scalar>)
  /// Initialize with the characters in the given string.
  ///
  /// - parameter string: The string content to inspect for characters.
  init(charactersIn string: __shared String)
  /// Initialize with a bitmap representation.
  ///
  /// This method is useful for creating a character set object with data from a file or other external data source.
  /// - parameter data: The bitmap representation.
  init(bitmapRepresentation data: __shared Data)
  /// Initialize with the contents of a file.
  ///
  /// Returns `nil` if there was an error reading the file.
  /// - parameter file: The file to read.
  init?(contentsOfFile file: __shared String)
  /// Returns a character set containing the characters in Unicode General Category Cc and Cf.
  static var controlCharacters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category Zs and `CHARACTER TABULATION (U+0009)`.
  static var whitespaces: CharacterSet { get }
  /// Returns a character set containing characters in Unicode General Category Z*, `U+000A ~ U+000D`, and `U+0085`.
  static var whitespacesAndNewlines: CharacterSet { get }
  /// Returns a character set containing the characters in the category of Decimal Numbers.
  static var decimalDigits: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category L* & M*.
  static var letters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category Ll.
  static var lowercaseLetters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category Lu and Lt.
  static var uppercaseLetters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category M*.
  static var nonBaseCharacters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Categories L*, M*, and N*.
  static var alphanumerics: CharacterSet { get }
  /// Returns a character set containing individual Unicode characters that can also be represented as composed character sequences (such as for letters with accents), by the definition of "standard decomposition" in version 3.2 of the Unicode character encoding standard.
  static var decomposables: CharacterSet { get }
  /// Returns a character set containing values in the category of Non-Characters or that have not yet been defined in version 3.2 of the Unicode standard.
  static var illegalCharacters: CharacterSet { get }
  @available(*, unavailable, renamed: "punctuationCharacters")
  static var punctuation: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category P*.
  static var punctuationCharacters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category Lt.
  static var capitalizedLetters: CharacterSet { get }
  /// Returns a character set containing the characters in Unicode General Category S*.
  static var symbols: CharacterSet { get }
  /// Returns a character set containing the newline characters (`U+000A ~ U+000D`, `U+0085`, `U+2028`, and `U+2029`).
  static var newlines: CharacterSet { get }
  /// Returns the character set for characters allowed in a user URL subcomponent.
  static var urlUserAllowed: CharacterSet { get }
  /// Returns the character set for characters allowed in a password URL subcomponent.
  static var urlPasswordAllowed: CharacterSet { get }
  /// Returns the character set for characters allowed in a host URL subcomponent.
  static var urlHostAllowed: CharacterSet { get }
  /// Returns the character set for characters allowed in a path URL component.
  static var urlPathAllowed: CharacterSet { get }
  /// Returns the character set for characters allowed in a query URL component.
  static var urlQueryAllowed: CharacterSet { get }
  /// Returns the character set for characters allowed in a fragment URL component.
  static var urlFragmentAllowed: CharacterSet { get }
  /// Returns a representation of the `CharacterSet` in binary format.
  @nonobjc var bitmapRepresentation: Data { get }
  /// Returns an inverted copy of the receiver.
  @nonobjc var inverted: CharacterSet { get }
  /// Returns true if the `CharacterSet` has a member in the specified plane.
  ///
  /// This method makes it easier to find the plane containing the members of the current character set. The Basic Multilingual Plane (BMP) is plane 0.
  func hasMember(inPlane plane: UInt8) -> Bool
  /// Insert a range of integer values in the `CharacterSet`.
  ///
  /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
  mutating func insert(charactersIn range: Range<Unicode.Scalar>)
  /// Insert a closed range of integer values in the `CharacterSet`.
  ///
  /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
  mutating func insert(charactersIn range: ClosedRange<Unicode.Scalar>)
  /// Remove a range of integer values from the `CharacterSet`.
  mutating func remove(charactersIn range: Range<Unicode.Scalar>)
  /// Remove a closed range of integer values from the `CharacterSet`.
  mutating func remove(charactersIn range: ClosedRange<Unicode.Scalar>)
  /// Insert the values from the specified string into the `CharacterSet`.
  mutating func insert(charactersIn string: String)
  /// Remove the values from the specified string from the `CharacterSet`.
  mutating func remove(charactersIn string: String)
  /// Invert the contents of the `CharacterSet`.
  mutating func invert()
  /// Insert a `Unicode.Scalar` representation of a character into the `CharacterSet`.
  ///
  /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
  @discardableResult
  mutating func insert(_ character: Unicode.Scalar) -> (inserted: Bool, memberAfterInsert: Unicode.Scalar)
  /// Insert a `Unicode.Scalar` representation of a character into the `CharacterSet`.
  ///
  /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
  @discardableResult
  mutating func update(with character: Unicode.Scalar) -> Unicode.Scalar?
  /// Remove a `Unicode.Scalar` representation of a character from the `CharacterSet`.
  ///
  /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
  @discardableResult
  mutating func remove(_ character: Unicode.Scalar) -> Unicode.Scalar?
  /// Test for membership of a particular `Unicode.Scalar` in the `CharacterSet`.
  func contains(_ member: Unicode.Scalar) -> Bool
  /// Returns a union of the `CharacterSet` with another `CharacterSet`.
  func union(_ other: CharacterSet) -> CharacterSet
  /// Sets the value to a union of the `CharacterSet` with another `CharacterSet`.
  mutating func formUnion(_ other: CharacterSet)
  /// Returns an intersection of the `CharacterSet` with another `CharacterSet`.
  func intersection(_ other: CharacterSet) -> CharacterSet
  /// Sets the value to an intersection of the `CharacterSet` with another `CharacterSet`.
  mutating func formIntersection(_ other: CharacterSet)
  /// Returns a `CharacterSet` created by removing elements in `other` from `self`.
  func subtracting(_ other: CharacterSet) -> CharacterSet
  /// Sets the value to a `CharacterSet` created by removing elements in `other` from `self`.
  mutating func subtract(_ other: CharacterSet)
  /// Returns an exclusive or of the `CharacterSet` with another `CharacterSet`.
  func symmetricDifference(_ other: CharacterSet) -> CharacterSet
  /// Sets the value to an exclusive or of the `CharacterSet` with another `CharacterSet`.
  mutating func formSymmetricDifference(_ other: CharacterSet)
  /// Returns true if `self` is a superset of `other`.
  func isSuperset(of other: CharacterSet) -> Bool
  func hash(into hasher: inout Hasher)
  /// Returns true if the two `CharacterSet`s are equal.
  static func == (lhs: CharacterSet, rhs: CharacterSet) -> Bool
  typealias ArrayLiteralElement = Unicode.Scalar
  typealias Element = Unicode.Scalar
  var hashValue: Int { get }
}

extension CharacterSet : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSCharacterSet
  static func _forceBridgeFromObjectiveC(_ input: NSCharacterSet, result: inout CharacterSet?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSCharacterSet, result: inout CharacterSet?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSCharacterSet?) -> CharacterSet
  typealias _ObjectiveCType = NSCharacterSet
}

extension CharacterSet : CustomStringConvertible, CustomDebugStringConvertible {
  var description: String { get }
  var debugDescription: String { get }
}

extension CharacterSet : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/// Describes errors within the Cocoa error domain.
struct CocoaError : _BridgedStoredNSError {
  let _nsError: NSError
  init(_nsError error: NSError)
  static var errorDomain: String { get }
  var hashValue: Int { get }
  /// The error code itself.
  struct Code : RawRepresentable, Hashable, _ErrorCodeProtocol {
    typealias _ErrorType = CocoaError
    let rawValue: Int
    init(rawValue: Int)
    typealias RawValue = Int
  }
}

extension CocoaError {
  /// The file path associated with the error, if any.
  var filePath: String? { get }
  /// The string encoding associated with this error, if any.
  var stringEncoding: String.Encoding? { get }
  /// The underlying error behind this error, if any.
  var underlying: Error? { get }
  /// A list of underlying errors, if any. It includes the values of both NSUnderlyingErrorKey and NSMultipleUnderlyingErrorsKey. If there are no underlying errors, returns an empty array.
  var underlyingErrors: [Error] { get }
  /// The URL associated with this error, if any.
  var url: URL? { get }
}

extension CocoaError {
  static func error(_ code: CocoaError.Code, userInfo: [AnyHashable : Any]? = nil, url: URL? = nil) -> Error
}

extension CocoaError {
  static var fileNoSuchFile: CocoaError.Code { get }
  static var fileLocking: CocoaError.Code { get }
  static var fileReadUnknown: CocoaError.Code { get }
  static var fileReadNoPermission: CocoaError.Code { get }
  static var fileReadInvalidFileName: CocoaError.Code { get }
  static var fileReadCorruptFile: CocoaError.Code { get }
  static var fileReadNoSuchFile: CocoaError.Code { get }
  static var fileReadInapplicableStringEncoding: CocoaError.Code { get }
  static var fileReadUnsupportedScheme: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var fileReadTooLarge: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var fileReadUnknownStringEncoding: CocoaError.Code { get }
  static var fileWriteUnknown: CocoaError.Code { get }
  static var fileWriteNoPermission: CocoaError.Code { get }
  static var fileWriteInvalidFileName: CocoaError.Code { get }
  @available(macOS 10.7, iOS 5.0, *)
  static var fileWriteFileExists: CocoaError.Code { get }
  static var fileWriteInapplicableStringEncoding: CocoaError.Code { get }
  static var fileWriteUnsupportedScheme: CocoaError.Code { get }
  static var fileWriteOutOfSpace: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var fileWriteVolumeReadOnly: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  static var fileManagerUnmountUnknown: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  static var fileManagerUnmountBusy: CocoaError.Code { get }
  static var keyValueValidation: CocoaError.Code { get }
  static var formatting: CocoaError.Code { get }
  static var userCancelled: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var featureUnsupported: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableNotLoadable: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableArchitectureMismatch: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableRuntimeMismatch: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableLoad: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableLink: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadCorrupt: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadUnknownVersion: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadStream: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListWriteStream: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var propertyListWriteInvalid: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionInterrupted: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionInvalid: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionReplyInvalid: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileUnavailable: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityHandoffFailed: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityConnectionUnavailable: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityRemoteApplicationTimedOut: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityHandoffUserInfoTooLarge: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var coderReadCorrupt: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var coderValueNotFound: CocoaError.Code { get }
  static var coderInvalidValue: CocoaError.Code { get }
}

extension CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  static var fileNoSuchFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileLocking")
  static var fileLockingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadUnknown")
  static var fileReadUnknownError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  static var fileReadNoPermissionError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  static var fileReadInvalidFileNameError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  static var fileReadCorruptFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  static var fileReadNoSuchFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  static var fileReadInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  static var fileReadUnsupportedSchemeError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  static var fileReadTooLargeError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  static var fileReadUnknownStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  static var fileWriteUnknownError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  static var fileWriteNoPermissionError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  static var fileWriteInvalidFileNameError: CocoaError.Code { get }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  static var fileWriteFileExistsError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  static var fileWriteInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  static var fileWriteUnsupportedSchemeError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  static var fileWriteOutOfSpaceError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  static var fileWriteVolumeReadOnlyError: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  static var fileManagerUnmountUnknownError: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  static var fileManagerUnmountBusyError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "keyValueValidation")
  static var keyValueValidationError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "formatting")
  static var formattingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "userCancelled")
  static var userCancelledError: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  static var featureUnsupportedError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  static var executableNotLoadableError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  static var executableArchitectureMismatchError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  static var executableRuntimeMismatchError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  static var executableLoadError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  static var executableLinkError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  static var propertyListReadCorruptError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  static var propertyListReadUnknownVersionError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  static var propertyListReadStreamError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  static var propertyListWriteStreamError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  static var propertyListWriteInvalidError: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  static var ubiquitousFileUnavailableError: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  static var userActivityHandoffFailedError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  static var userActivityConnectionUnavailableError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  static var userActivityRemoteApplicationTimedOutError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  static var coderReadCorruptError: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  static var coderValueNotFoundError: CocoaError.Code { get }
}

extension CocoaError {
  @available(macOS 10.11, iOS 9.0, *)
  var isCoderError: Bool { get }
  @available(macOS 10.5, iOS 2.0, *)
  var isExecutableError: Bool { get }
  var isFileError: Bool { get }
  var isFormattingError: Bool { get }
  @available(macOS 10.6, iOS 4.0, *)
  var isPropertyListError: Bool { get }
  @available(macOS 10.9, iOS 7.0, *)
  var isUbiquitousFileError: Bool { get }
  @available(macOS 10.10, iOS 8.0, *)
  var isUserActivityError: Bool { get }
  var isValidationError: Bool { get }
  @available(macOS 10.8, iOS 6.0, *)
  var isXPCConnectionError: Bool { get }
}

extension CocoaError.Code {
  static var fileNoSuchFile: CocoaError.Code { get }
  static var fileLocking: CocoaError.Code { get }
  static var fileReadUnknown: CocoaError.Code { get }
  static var fileReadNoPermission: CocoaError.Code { get }
  static var fileReadInvalidFileName: CocoaError.Code { get }
  static var fileReadCorruptFile: CocoaError.Code { get }
  static var fileReadNoSuchFile: CocoaError.Code { get }
  static var fileReadInapplicableStringEncoding: CocoaError.Code { get }
  static var fileReadUnsupportedScheme: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var fileReadTooLarge: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var fileReadUnknownStringEncoding: CocoaError.Code { get }
  static var fileWriteUnknown: CocoaError.Code { get }
  static var fileWriteNoPermission: CocoaError.Code { get }
  static var fileWriteInvalidFileName: CocoaError.Code { get }
  @available(macOS 10.7, iOS 5.0, *)
  static var fileWriteFileExists: CocoaError.Code { get }
  static var fileWriteInapplicableStringEncoding: CocoaError.Code { get }
  static var fileWriteUnsupportedScheme: CocoaError.Code { get }
  static var fileWriteOutOfSpace: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var fileWriteVolumeReadOnly: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  static var fileManagerUnmountUnknown: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  static var fileManagerUnmountBusy: CocoaError.Code { get }
  static var keyValueValidation: CocoaError.Code { get }
  static var formatting: CocoaError.Code { get }
  static var userCancelled: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var featureUnsupported: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableNotLoadable: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableArchitectureMismatch: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableRuntimeMismatch: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableLoad: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var executableLink: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadCorrupt: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadUnknownVersion: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListReadStream: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  static var propertyListWriteStream: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var propertyListWriteInvalid: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionInterrupted: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionInvalid: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  static var xpcConnectionReplyInvalid: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileUnavailable: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityHandoffFailed: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityConnectionUnavailable: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityRemoteApplicationTimedOut: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var userActivityHandoffUserInfoTooLarge: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var coderReadCorrupt: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var coderValueNotFound: CocoaError.Code { get }
  static var coderInvalidValue: CocoaError.Code { get }
}

extension CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  static var fileNoSuchFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileLocking")
  static var fileLockingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadUnknown")
  static var fileReadUnknownError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  static var fileReadNoPermissionError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  static var fileReadInvalidFileNameError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  static var fileReadCorruptFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  static var fileReadNoSuchFileError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  static var fileReadInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  static var fileReadUnsupportedSchemeError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  static var fileReadTooLargeError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  static var fileReadUnknownStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  static var fileWriteUnknownError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  static var fileWriteNoPermissionError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  static var fileWriteInvalidFileNameError: CocoaError.Code { get }
  @available(macOS 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  static var fileWriteFileExistsError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  static var fileWriteInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  static var fileWriteUnsupportedSchemeError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  static var fileWriteOutOfSpaceError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  static var fileWriteVolumeReadOnlyError: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  static var fileManagerUnmountUnknownError: CocoaError.Code { get }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  static var fileManagerUnmountBusyError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "keyValueValidation")
  static var keyValueValidationError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "formatting")
  static var formattingError: CocoaError.Code { get }
  @available(*, deprecated, renamed: "userCancelled")
  static var userCancelledError: CocoaError.Code { get }
  @available(macOS 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  static var featureUnsupportedError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  static var executableNotLoadableError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  static var executableArchitectureMismatchError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  static var executableRuntimeMismatchError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  static var executableLoadError: CocoaError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  static var executableLinkError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  static var propertyListReadCorruptError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  static var propertyListReadUnknownVersionError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  static var propertyListReadStreamError: CocoaError.Code { get }
  @available(macOS 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  static var propertyListWriteStreamError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  static var propertyListWriteInvalidError: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  static var ubiquitousFileUnavailableError: CocoaError.Code { get }
  @available(macOS 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  static var userActivityHandoffFailedError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  static var userActivityConnectionUnavailableError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  static var userActivityRemoteApplicationTimedOutError: CocoaError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  static var coderReadCorruptError: CocoaError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  static var coderValueNotFoundError: CocoaError.Code { get }
}

extension CocoaError.Code {
  @available(*, unavailable, renamed: "fileNoSuchFile")
  static var FileNoSuchFileError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileLocking")
  static var FileLockingError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadUnknown")
  static var FileReadUnknownError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadNoPermission")
  static var FileReadNoPermissionError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadInvalidFileName")
  static var FileReadInvalidFileNameError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadCorruptFile")
  static var FileReadCorruptFileError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadNoSuchFile")
  static var FileReadNoSuchFileError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadInapplicableStringEncoding")
  static var FileReadInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadUnsupportedScheme")
  static var FileReadUnsupportedSchemeError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadTooLarge")
  static var FileReadTooLargeError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileReadUnknownStringEncoding")
  static var FileReadUnknownStringEncodingError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteUnknown")
  static var FileWriteUnknownError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteNoPermission")
  static var FileWriteNoPermissionError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteInvalidFileName")
  static var FileWriteInvalidFileNameError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteFileExists")
  static var FileWriteFileExistsError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteInapplicableStringEncoding")
  static var FileWriteInapplicableStringEncodingError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteUnsupportedScheme")
  static var FileWriteUnsupportedSchemeError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteOutOfSpace")
  static var FileWriteOutOfSpaceError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileWriteVolumeReadOnly")
  static var FileWriteVolumeReadOnlyError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileManagerUnmountUnknown")
  static var FileManagerUnmountUnknownError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "fileManagerUnmountBusy")
  static var FileManagerUnmountBusyError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "keyValueValidation")
  static var KeyValueValidationError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "formatting")
  static var FormattingError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "userCancelled")
  static var UserCancelledError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "featureUnsupported")
  static var FeatureUnsupportedError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "executableNotLoadable")
  static var ExecutableNotLoadableError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "executableArchitectureMismatch")
  static var ExecutableArchitectureMismatchError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "executableRuntimeMismatch")
  static var ExecutableRuntimeMismatchError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "executableLoad")
  static var ExecutableLoadError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "executableLink")
  static var ExecutableLinkError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "propertyListReadCorrupt")
  static var PropertyListReadCorruptError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "propertyListReadUnknownVersion")
  static var PropertyListReadUnknownVersionError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "propertyListReadStream")
  static var PropertyListReadStreamError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "propertyListWriteStream")
  static var PropertyListWriteStreamError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "propertyListWriteInvalid")
  static var PropertyListWriteInvalidError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "xpcConnectionInterrupted")
  static var XPCConnectionInterrupted: CocoaError.Code { get }
  @available(*, unavailable, renamed: "xpcConnectionInvalid")
  static var XPCConnectionInvalid: CocoaError.Code { get }
  @available(*, unavailable, renamed: "xpcConnectionReplyInvalid")
  static var XPCConnectionReplyInvalid: CocoaError.Code { get }
  @available(*, unavailable, renamed: "ubiquitousFileUnavailable")
  static var UbiquitousFileUnavailableError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "ubiquitousFileNotUploadedDueToQuota")
  static var UbiquitousFileNotUploadedDueToQuotaError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "ubiquitousFileUbiquityServerNotAvailable")
  static var UbiquitousFileUbiquityServerNotAvailable: CocoaError.Code { get }
  @available(*, unavailable, renamed: "userActivityHandoffFailed")
  static var UserActivityHandoffFailedError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "userActivityConnectionUnavailable")
  static var UserActivityConnectionUnavailableError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "userActivityRemoteApplicationTimedOut")
  static var UserActivityRemoteApplicationTimedOutError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "userActivityHandoffUserInfoTooLarge")
  static var UserActivityHandoffUserInfoTooLargeError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "coderReadCorrupt")
  static var CoderReadCorruptError: CocoaError.Code { get }
  @available(*, unavailable, renamed: "coderValueNotFound")
  static var CoderValueNotFoundError: CocoaError.Code { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
typealias CodableAttributedStringKey = DecodableAttributedStringKey & EncodableAttributedStringKey

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@propertyWrapper struct CodableConfiguration<T, ConfigurationProvider> : Codable where T : DecodableWithConfiguration, T : EncodableWithConfiguration, ConfigurationProvider : DecodingConfigurationProviding, ConfigurationProvider : EncodingConfigurationProviding, T.DecodingConfiguration == ConfigurationProvider.DecodingConfiguration, T.EncodingConfiguration == ConfigurationProvider.EncodingConfiguration {
  var wrappedValue: T
  init(wrappedValue: T)
  init(wrappedValue: T, from configurationProvider: ConfigurationProvider.Type)
  func encode(to encoder: Encoder) throws
  init(from decoder: Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration : Equatable where T : Equatable {
  static func == (a: CodableConfiguration<T, ConfigurationProvider>, b: CodableConfiguration<T, ConfigurationProvider>) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration : Hashable where T : Hashable {
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration where ConfigurationProvider : AttributeScope {
  init(wrappedValue: T, from keyPath: KeyPath<AttributeScopes, ConfigurationProvider.Type>)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
typealias CodableWithConfiguration = DecodableWithConfiguration & EncodableWithConfiguration

/// Compares `Comparable` types using their comparable implementation.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
struct ComparableComparator<Compared> : SortComparator where Compared : Comparable {
  var order: SortOrder
  func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult
  func hash(into hasher: inout Hasher)
  static func == (a: ComparableComparator<Compared>, b: ComparableComparator<Compared>) -> Bool
  var hashValue: Int { get }
  typealias Compared = Compared
}

/// Indicates that the conforming type is a contiguous collection of raw bytes
/// whose underlying storage is directly accessible by withUnsafeBytes.
protocol ContiguousBytes {
  /// Calls the given closure with the contents of underlying storage.
  ///
  /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
  ///         the same buffer pointer will be passed in every time.
  /// - warning: The buffer argument to the body should not be stored or used
  ///            outside of the lifetime of the call to the closure.
  func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
enum CurrencyFormatStyleConfiguration {
  typealias Grouping = NumberFormatStyleConfiguration.Grouping
  typealias Precision = NumberFormatStyleConfiguration.Precision
  typealias DecimalSeparatorDisplayStrategy = NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy
  typealias RoundingRule = NumberFormatStyleConfiguration.RoundingRule
  struct SignDisplayStrategy : Codable, Hashable {
    static var automatic: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }
    static var never: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }
    static func always(showZero: Bool = true) -> CurrencyFormatStyleConfiguration.SignDisplayStrategy
    static var accounting: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }
    static func accountingAlways(showZero: Bool = false) -> CurrencyFormatStyleConfiguration.SignDisplayStrategy
    func hash(into hasher: inout Hasher)
    static func == (a: CurrencyFormatStyleConfiguration.SignDisplayStrategy, b: CurrencyFormatStyleConfiguration.SignDisplayStrategy) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct Presentation : Codable, Hashable {
    static var narrow: CurrencyFormatStyleConfiguration.Presentation { get }
    static var standard: CurrencyFormatStyleConfiguration.Presentation { get }
    static var isoCode: CurrencyFormatStyleConfiguration.Presentation { get }
    static var fullName: CurrencyFormatStyleConfiguration.Presentation { get }
    func hash(into hasher: inout Hasher)
    static func == (a: CurrencyFormatStyleConfiguration.Presentation, b: CurrencyFormatStyleConfiguration.Presentation) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

/// Describes an error type that specifically provides a domain, code,
/// and user-info dictionary.
protocol CustomNSError : Error {
  /// The domain of the error.
  static var errorDomain: String { get }
  /// The error code within the given domain.
  var errorCode: Int { get }
  /// The user-info dictionary.
  var errorUserInfo: [String : Any] { get }
}

extension CustomNSError {
  /// Default domain of the error.
  static var errorDomain: String { get }
  /// The error code within the given domain.
  var errorCode: Int { get }
  /// The default user-info dictionary.
  var errorUserInfo: [String : Any] { get }
}

extension CustomNSError where Self : RawRepresentable, Self.RawValue : FixedWidthInteger {
  var errorCode: Int { get }
}

@frozen struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessCollection, MutableCollection, RangeReplaceableCollection, MutableDataProtocol, ContiguousBytes {
  typealias ReferenceType = NSData
  typealias ReadingOptions = NSData.ReadingOptions
  typealias WritingOptions = NSData.WritingOptions
  typealias SearchOptions = NSData.SearchOptions
  typealias Base64EncodingOptions = NSData.Base64EncodingOptions
  typealias Base64DecodingOptions = NSData.Base64DecodingOptions
  typealias Index = Int
  typealias Indices = Range<Int>
  @usableFromInline
  @frozen struct InlineData {
    @usableFromInline
    typealias Buffer = (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
    @usableFromInline
    var bytes: Data.InlineData.Buffer
    @usableFromInline
    var length: UInt8
    @inlinable static func canStore(count: Int) -> Bool
    @inlinable init(_ srcBuffer: UnsafeRawBufferPointer)
    @inlinable init(count: Int = 0)
    @inlinable init(_ slice: Data.InlineSlice, count: Int)
    @inlinable init(_ slice: Data.LargeSlice, count: Int)
    @inlinable var capacity: Int { get }
    @inlinable var count: Int
    @inlinable var startIndex: Int { get }
    @inlinable var endIndex: Int { get }
    @inlinable func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func append(byte: UInt8)
    @inlinable mutating func append(contentsOf buffer: UnsafeRawBufferPointer)
    @inlinable subscript(index: Data.Index) -> UInt8
    @inlinable mutating func resetBytes(in range: Range<Data.Index>)
    @usableFromInline
    mutating func replaceSubrange(_ subrange: Range<Data.Index>, with replacementBytes: UnsafeRawPointer?, count replacementLength: Int)
    @inlinable func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  }
  @usableFromInline
  typealias HalfInt = Int32
  @usableFromInline
  @frozen struct InlineSlice {
    @usableFromInline
    var slice: Range<Data.HalfInt>
    @usableFromInline
    var storage: __DataStorage
    @inlinable static func canStore(count: Int) -> Bool
    @inlinable init(_ buffer: UnsafeRawBufferPointer)
    @inlinable init(capacity: Int)
    @inlinable init(count: Int)
    @inlinable init(_ inline: Data.InlineData)
    @inlinable init(_ inline: Data.InlineData, range: Range<Int>)
    @inlinable init(_ large: Data.LargeSlice)
    @inlinable init(_ large: Data.LargeSlice, range: Range<Int>)
    @inlinable init(_ storage: __DataStorage, count: Int)
    @inlinable init(_ storage: __DataStorage, range: Range<Int>)
    @inlinable mutating func ensureUniqueReference()
    @inlinable var startIndex: Int { get }
    @inlinable var endIndex: Int { get }
    @inlinable var capacity: Int { get }
    @inlinable mutating func reserveCapacity(_ minimumCapacity: Int)
    @inlinable var count: Int
    @inlinable var range: Range<Int>
    @inlinable func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func append(contentsOf buffer: UnsafeRawBufferPointer)
    @inlinable subscript(index: Data.Index) -> UInt8
    @inlinable func bridgedReference() -> NSData
    @inlinable mutating func resetBytes(in range: Range<Data.Index>)
    @inlinable mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer?, count cnt: Int)
    @inlinable func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  }
  @usableFromInline
  final class RangeReference {
    @usableFromInline
    final var range: Range<Int>
    @inlinable @inline(__always) final var lowerBound: Int { get }
    @inlinable @inline(__always) final var upperBound: Int { get }
    @inlinable @inline(__always) final var count: Int { get }
    @inlinable @inline(__always) init(_ range: Range<Int>)
  }
  @usableFromInline
  @frozen struct LargeSlice {
    @usableFromInline
    var slice: Data.RangeReference
    @usableFromInline
    var storage: __DataStorage
    @inlinable init(_ buffer: UnsafeRawBufferPointer)
    @inlinable init(capacity: Int)
    @inlinable init(count: Int)
    @inlinable init(_ inline: Data.InlineData)
    @inlinable init(_ slice: Data.InlineSlice)
    @inlinable init(_ storage: __DataStorage, count: Int)
    @inlinable mutating func ensureUniqueReference()
    @inlinable var startIndex: Int { get }
    @inlinable var endIndex: Int { get }
    @inlinable var capacity: Int { get }
    @inlinable mutating func reserveCapacity(_ minimumCapacity: Int)
    @inlinable var count: Int
    @inlinable var range: Range<Int> { get }
    @inlinable func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func append(contentsOf buffer: UnsafeRawBufferPointer)
    @inlinable subscript(index: Data.Index) -> UInt8
    @inlinable func bridgedReference() -> NSData
    @inlinable mutating func resetBytes(in range: Range<Int>)
    @inlinable mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer?, count cnt: Int)
    @inlinable func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  }
  @usableFromInline
  @frozen enum _Representation {
    case empty
    case inline(Data.InlineData)
    case slice(Data.InlineSlice)
    case large(Data.LargeSlice)
    @inlinable init(_ buffer: UnsafeRawBufferPointer)
    @inlinable init(_ buffer: UnsafeRawBufferPointer, owner: AnyObject)
    @inlinable init(capacity: Int)
    @inlinable init(count: Int)
    @inlinable init(_ storage: __DataStorage, count: Int)
    @usableFromInline
    mutating func reserveCapacity(_ minimumCapacity: Int)
    @inlinable var count: Int
    @inlinable func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable mutating func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
    @inlinable func withInteriorPointerReference<T>(_ work: (NSData) throws -> T) rethrows -> T
    @usableFromInline
    func enumerateBytes(_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Data.Index, _ stop: inout Bool) -> Void)
    @inlinable mutating func append(contentsOf buffer: UnsafeRawBufferPointer)
    @inlinable mutating func resetBytes(in range: Range<Data.Index>)
    @usableFromInline
    mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer?, count cnt: Int)
    @inlinable subscript(index: Data.Index) -> UInt8
    @inlinable subscript(bounds: Range<Data.Index>) -> Data { get }
    @inlinable var startIndex: Int { get }
    @inlinable var endIndex: Int { get }
    @inlinable func bridgedReference() -> NSData
    @inlinable func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  }
  @usableFromInline
  var _representation: Data._Representation
  ///
  /// When creating a `Data` with the no-copy initializer, you may specify a `Data.Deallocator` to customize the behavior of how the backing store is deallocated.
  enum Deallocator {
    case virtualMemory
    /// Use `munmap`.
    case unmap
    /// Use `free`.
    case free
    /// Do nothing upon deallocation.
    case none
    /// A custom deallocator.
    case custom((UnsafeMutableRawPointer, Int) -> Void)
    @usableFromInline
    var _deallocator: ((UnsafeMutableRawPointer, Int) -> Void) { get }
  }
  /// Initialize a `Data` with copied memory content.
  ///
  /// - parameter bytes: A pointer to the memory. It will be copied.
  /// - parameter count: The number of bytes to copy.
  @inlinable init(bytes: UnsafeRawPointer, count: Int)
  /// Initialize a `Data` with copied memory content.
  ///
  /// - parameter buffer: A buffer pointer to copy. The size is calculated from `SourceType` and `buffer.count`.
  @inlinable init<SourceType>(buffer: UnsafeBufferPointer<SourceType>)
  /// Initialize a `Data` with copied memory content.
  ///
  /// - parameter buffer: A buffer pointer to copy. The size is calculated from `SourceType` and `buffer.count`.
  @inlinable init<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>)
  /// Initialize a `Data` with a repeating byte pattern
  ///
  /// - parameter repeatedValue: A byte to initialize the pattern
  /// - parameter count: The number of bytes the data initially contains initialized to the repeatedValue
  @inlinable init(repeating repeatedValue: UInt8, count: Int)
  /// Initialize a `Data` with the specified size.
  ///
  /// This initializer doesn't necessarily allocate the requested memory right away. `Data` allocates additional memory as needed, so `capacity` simply establishes the initial capacity. When it does allocate the initial memory, though, it allocates the specified amount.
  ///
  /// This method sets the `count` of the data to 0.
  ///
  /// If the capacity specified in `capacity` is greater than four memory pages in size, this may round the amount of requested memory up to the nearest full page.
  ///
  /// - parameter capacity: The size of the data.
  @inlinable init(capacity: Int)
  /// Initialize a `Data` with the specified count of zeroed bytes.
  ///
  /// - parameter count: The number of bytes the data initially contains.
  @inlinable init(count: Int)
  /// Initialize an empty `Data`.
  @inlinable init()
  /// Initialize a `Data` without copying the bytes.
  ///
  /// If the result is mutated and is not a unique reference, then the `Data` will still follow copy-on-write semantics. In this case, the copy will use its own deallocator. Therefore, it is usually best to only use this initializer when you either enforce immutability with `let` or ensure that no other references to the underlying data are formed.
  /// - parameter bytes: A pointer to the bytes.
  /// - parameter count: The size of the bytes.
  /// - parameter deallocator: Specifies the mechanism to free the indicated buffer, or `.none`.
  @inlinable init(bytesNoCopy bytes: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)
  @inlinable init(contentsOf url: __shared URL, options: Data.ReadingOptions = []) throws
  @inlinable init?(base64Encoded base64String: __shared String, options: Data.Base64DecodingOptions = [])
  @inlinable init?(base64Encoded base64Data: __shared Data, options: Data.Base64DecodingOptions = [])
  /// Initialize a `Data` by adopting a reference type.
  ///
  /// You can use this initializer to create a `struct Data` that wraps a `class NSData`. `struct Data` will use the `class NSData` for all operations. Other initializers (including casting using `as Data`) may choose to hold a reference or not, based on a what is the most efficient representation.
  ///
  /// If the resulting value is mutated, then `Data` will invoke the `mutableCopy()` function on the reference to copy the contents. You may customize the behavior of that function if you wish to return a specialized mutable subclass.
  ///
  /// - parameter reference: The instance of `NSData` that you wish to wrap. This instance will be copied by `struct Data`.
  init(referencing reference: __shared NSData)
  @inlinable init<S>(_ elements: S) where S : Sequence, S.Element == UInt8
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  init<S>(bytes elements: S) where S : Sequence, S.Element == UInt8
  @available(swift, obsoleted: 4.2)
  init(bytes: Array<UInt8>)
  @available(swift, obsoleted: 4.2)
  init(bytes: ArraySlice<UInt8>)
  @inlinable init(representation: Data._Representation)
  @inlinable mutating func reserveCapacity(_ minimumCapacity: Int)
  /// The number of bytes in the data.
  @inlinable var count: Int
  @inlinable var regions: CollectionOfOne<Data> { get }
  /// Access the bytes in the data.
  ///
  /// - warning: The byte pointer argument should not be stored and used outside of the lifetime of the call to the closure.
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  func withUnsafeBytes<ResultType, ContentType>(_ body: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
  /// Mutate the bytes in the data.
  ///
  /// This function assumes that you are mutating the contents.
  /// - warning: The byte pointer argument should not be stored and used outside of the lifetime of the call to the closure.
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable mutating func withUnsafeMutableBytes<ResultType>(_ body: (UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType
  /// Copy the contents of the data to a pointer.
  ///
  /// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
  /// - parameter count: The number of bytes to copy.
  /// - warning: This method does not verify that the contents at pointer have enough space to hold `count` bytes.
  @inlinable func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, count: Int)
  @inlinable func _copyBytesHelper(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  /// Copy a subset of the contents of the data to a pointer.
  ///
  /// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
  /// - parameter range: The range in the `Data` to copy.
  /// - warning: This method does not verify that the contents at pointer have enough space to hold the required number of bytes.
  @inlinable func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, from range: Range<Data.Index>)
  ///
  /// This function copies the bytes in `range` from the data into the buffer. If the count of the `range` is greater than `MemoryLayout<DestinationType>.stride * buffer.count` then the first N bytes will be copied into the buffer.
  /// - precondition: The range must be within the bounds of the data. Otherwise `fatalError` is called.
  /// - parameter buffer: A buffer to copy the data into.
  /// - parameter range: A range in the data to copy into the buffer. If the range is empty, this function will return 0 without copying anything. If the range is nil, as much data as will fit into `buffer` is copied.
  /// - returns: Number of bytes copied into the destination buffer.
  @inlinable func copyBytes<DestinationType>(to buffer: UnsafeMutableBufferPointer<DestinationType>, from range: Range<Data.Index>? = nil) -> Int
  func write(to url: URL, options: Data.WritingOptions = []) throws
  func range(of dataToFind: Data, options: Data.SearchOptions = [], in range: Range<Data.Index>? = nil) -> Range<Data.Index>?
  /// Enumerate the contents of the data.
  ///
  /// In some cases, (for example, a `Data` backed by a `dispatch_data_t`, the bytes may be stored discontiguously. In those cases, this function invokes the closure for each contiguous region of bytes.
  /// - parameter block: The closure to invoke for each region of data. You may stop the enumeration by setting the `stop` parameter to `true`.
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  func enumerateBytes(_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Data.Index, _ stop: inout Bool) -> Void)
  @inlinable mutating func _append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>)
  @inlinable mutating func append(_ bytes: UnsafePointer<UInt8>, count: Int)
  mutating func append(_ other: Data)
  /// Append a buffer of bytes to the data.
  ///
  /// - parameter buffer: The buffer of bytes to append. The size is calculated from `SourceType` and `buffer.count`.
  @inlinable mutating func append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>)
  @inlinable mutating func append(contentsOf bytes: [UInt8])
  @inlinable mutating func append<S>(contentsOf elements: S) where S : Sequence, S.Element == UInt8
  /// Set a region of the data to `0`.
  ///
  /// If `range` exceeds the bounds of the data, then the data is resized to fit.
  /// - parameter range: The range in the data to set to `0`.
  @inlinable mutating func resetBytes(in range: Range<Data.Index>)
  /// Replace a region of bytes in the data with new data.
  ///
  /// This will resize the data if required, to fit the entire contents of `data`.
  ///
  /// - precondition: The bounds of `subrange` must be valid indices of the collection.
  /// - parameter subrange: The range in the data to replace. If `subrange.lowerBound == data.count && subrange.count == 0` then this operation is an append.
  /// - parameter data: The replacement data.
  @inlinable mutating func replaceSubrange(_ subrange: Range<Data.Index>, with data: Data)
  /// Replace a region of bytes in the data with new bytes from a buffer.
  ///
  /// This will resize the data if required, to fit the entire contents of `buffer`.
  ///
  /// - precondition: The bounds of `subrange` must be valid indices of the collection.
  /// - parameter subrange: The range in the data to replace.
  /// - parameter buffer: The replacement bytes.
  @inlinable mutating func replaceSubrange<SourceType>(_ subrange: Range<Data.Index>, with buffer: UnsafeBufferPointer<SourceType>)
  /// Replace a region of bytes in the data with new bytes from a collection.
  ///
  /// This will resize the data if required, to fit the entire contents of `newElements`.
  ///
  /// - precondition: The bounds of `subrange` must be valid indices of the collection.
  /// - parameter subrange: The range in the data to replace.
  /// - parameter newElements: The replacement bytes.
  @inlinable mutating func replaceSubrange<ByteCollection>(_ subrange: Range<Data.Index>, with newElements: ByteCollection) where ByteCollection : Collection, ByteCollection.Element == UInt8
  @inlinable mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer, count cnt: Int)
  /// Return a new copy of the data in a specified range.
  ///
  /// - parameter range: The range to copy.
  func subdata(in range: Range<Data.Index>) -> Data
  @inlinable func base64EncodedString(options: Data.Base64EncodingOptions = []) -> String
  @inlinable func base64EncodedData(options: Data.Base64EncodingOptions = []) -> Data
  /// The hash value for the data.
  @inline(never) func hash(into hasher: inout Hasher)
  func advanced(by amount: Int) -> Data
  /// Sets or returns the byte at the specified index.
  @inlinable subscript(index: Data.Index) -> UInt8
  @inlinable subscript(bounds: Range<Data.Index>) -> Data
  @inlinable subscript<R>(rangeExpression: R) -> Data where R : RangeExpression, R.Bound : FixedWidthInteger
  /// The start `Index` in the data.
  @inlinable var startIndex: Data.Index { get }
  /// The end `Index` into the data.
  ///
  /// This is the "one-past-the-end" position, and will always be equal to the `count`.
  @inlinable var endIndex: Data.Index { get }
  @inlinable func index(before i: Data.Index) -> Data.Index
  @inlinable func index(after i: Data.Index) -> Data.Index
  @inlinable var indices: Range<Int> { get }
  @inlinable func _copyContents(initializing buffer: UnsafeMutableBufferPointer<UInt8>) -> (Data.Iterator, UnsafeMutableBufferPointer<UInt8>.Index)
  /// An iterator over the contents of the data.
  ///
  /// The iterator will increment byte-by-byte.
  @inlinable func makeIterator() -> Data.Iterator
  struct Iterator : IteratorProtocol {
    @usableFromInline
    typealias Buffer = (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
    @usableFromInline
    let _data: Data
    @usableFromInline
    var _buffer: Data.Iterator.Buffer
    @usableFromInline
    var _idx: Data.Index
    @usableFromInline
    let _endIdx: Data.Index
    @usableFromInline
    init(_ data: Data, at loc: Data.Index)
    mutating func next() -> UInt8?
    typealias Element = UInt8
  }
  @available(*, unavailable, renamed: "count")
  var length: Int
  @available(*, unavailable, message: "use withUnsafeBytes instead")
  var bytes: UnsafeRawPointer { get }
  @available(*, unavailable, message: "use withUnsafeMutableBytes instead")
  var mutableBytes: UnsafeMutableRawPointer { get }
  /// Returns `true` if the two `Data` arguments are equal.
  @inlinable static func == (d1: Data, d2: Data) -> Bool
  typealias Element = UInt8
  typealias Regions = CollectionOfOne<Data>
  typealias SubSequence = Data
  var hashValue: Int { get }
}

extension Data : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  /// A human-readable description for the data.
  var description: String { get }
  /// A human-readable debug description for the data.
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension Data {
  @available(*, unavailable, renamed: "copyBytes(to:count:)")
  func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, length: Int) where UnsafeMutablePointerVoid : _Pointer
  @available(*, unavailable, renamed: "copyBytes(to:from:)")
  func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, range: NSRange) where UnsafeMutablePointerVoid : _Pointer
}

/// Provides bridging functionality for struct Data to class NSData and vice-versa.
extension Data : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSData
  static func _forceBridgeFromObjectiveC(_ input: NSData, result: inout Data?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSData, result: inout Data?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSData?) -> Data
  typealias _ObjectiveCType = NSData
}

extension Data : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension Data.InlineData : Sendable {
}

protocol DataProtocol : RandomAccessCollection where Self.Element == UInt8, Self.SubSequence : DataProtocol {
  associatedtype Regions : BidirectionalCollection where Self.Regions.Element : ContiguousBytes, Self.Regions.Element : DataProtocol, Self.Regions.Element.SubSequence : ContiguousBytes
  /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
  /// discontiguous buffer of memory.  Each region is a contiguous buffer of
  /// bytes.
  ///
  /// The sum of the lengths of the associated regions must equal `self.count`
  /// (such that iterating `regions` and iterating `self` produces the same
  /// sequence of indices in the same number of index advancements).
  var regions: Self.Regions { get }
  /// Returns the first found range of the given data buffer.
  ///
  /// A default implementation is given in terms of `self.regions`.
  func firstRange<D, R>(of: D, in: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound
  /// Returns the last found range of the given data buffer.
  ///
  /// A default implementation is given in terms of `self.regions`.
  func lastRange<D, R>(of: D, in: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound
  /// Copies `count` bytes from the start of the buffer to the destination
  /// buffer.
  ///
  /// A default implementation is given in terms of `copyBytes(to:from:)`.
  @discardableResult
  func copyBytes(to: UnsafeMutableRawBufferPointer, count: Int) -> Int
  /// Copies `count` bytes from the start of the buffer to the destination
  /// buffer.
  ///
  /// A default implementation is given in terms of `copyBytes(to:from:)`.
  @discardableResult
  func copyBytes<DestinationType>(to: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int
  /// Copies the bytes from the given range to the destination buffer.
  ///
  /// A default implementation is given in terms of `self.regions`.
  @discardableResult
  func copyBytes<R>(to: UnsafeMutableRawBufferPointer, from: R) -> Int where R : RangeExpression, Self.Index == R.Bound
  /// Copies the bytes from the given range to the destination buffer.
  ///
  /// A default implementation is given in terms of `self.regions`.
  @discardableResult
  func copyBytes<DestinationType, R>(to: UnsafeMutableBufferPointer<DestinationType>, from: R) -> Int where R : RangeExpression, Self.Index == R.Bound
}

extension DataProtocol {
  func firstRange<D>(of data: D) -> Range<Self.Index>? where D : DataProtocol
  func lastRange<D>(of data: D) -> Range<Self.Index>? where D : DataProtocol
  @discardableResult
  func copyBytes(to ptr: UnsafeMutableRawBufferPointer) -> Int
  @discardableResult
  func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>) -> Int
  @discardableResult
  func copyBytes(to ptr: UnsafeMutableRawBufferPointer, count: Int) -> Int
  @discardableResult
  func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int
  @discardableResult
  func copyBytes<R>(to ptr: UnsafeMutableRawBufferPointer, from range: R) -> Int where R : RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Int where R : RangeExpression, Self.Index == R.Bound
  func firstRange<D, R>(of data: D, in range: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of data: D, in range: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound
}

extension DataProtocol where Self : ContiguousBytes {
  func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : RangeExpression, Self.Index == R.Bound
}

/**
 `Date` represents a single point in time.
 
 A `Date` is independent of a particular calendar or time zone. To represent a `Date` to a user, you must interpret it in the context of a `Calendar`.
*/
struct Date : ReferenceConvertible, Comparable, Equatable {
  typealias ReferenceType = NSDate
  /// The number of seconds from 1 January 1970 to the reference date, 1 January 2001.
  static let timeIntervalBetween1970AndReferenceDate: Double
  /// The interval between 00:00:00 UTC on 1 January 2001 and the current date and time. 
  static var timeIntervalSinceReferenceDate: TimeInterval { get }
  /// Returns a `Date` initialized to the current date and time.
  init()
  /// Returns a `Date` initialized relative to the current date and time by a given number of seconds.
  init(timeIntervalSinceNow: TimeInterval)
  /// Returns a `Date` initialized relative to 00:00:00 UTC on 1 January 1970 by a given number of seconds.
  init(timeIntervalSince1970: TimeInterval)
  /**
  Returns a `Date` initialized relative to another given date by a given number of seconds.
  
  - Parameter timeInterval: The number of seconds to add to `date`. A negative value means the receiver will be earlier than `date`.
  - Parameter date: The reference date.
  */
  init(timeInterval: TimeInterval, since date: Date)
  /// Returns a `Date` initialized relative to 00:00:00 UTC on 1 January 2001 by a given number of seconds.
  init(timeIntervalSinceReferenceDate ti: TimeInterval)
  /**
  Returns the interval between the date object and 00:00:00 UTC on 1 January 2001.
  
  This property's value is negative if the date object is earlier than the system's absolute reference date (00:00:00 UTC on 1 January 2001).
  */
  var timeIntervalSinceReferenceDate: TimeInterval { get }
  /**
      Returns the interval between the receiver and another given date.
  
      - Parameter another: The date with which to compare the receiver.
  
      - Returns: The interval between the receiver and the `another` parameter. If the receiver is earlier than `anotherDate`, the return value is negative. If `anotherDate` is `nil`, the results are undefined.
  
      - SeeAlso: `timeIntervalSince1970`
      - SeeAlso: `timeIntervalSinceNow`
      - SeeAlso: `timeIntervalSinceReferenceDate`
      */
  func timeIntervalSince(_ date: Date) -> TimeInterval
  /**
      The time interval between the date and the current date and time.
  
      If the date is earlier than the current date and time, this property's value is negative.
  
      - SeeAlso: `timeIntervalSince(_:)`
      - SeeAlso: `timeIntervalSince1970`
      - SeeAlso: `timeIntervalSinceReferenceDate`
      */
  var timeIntervalSinceNow: TimeInterval { get }
  /**
      The interval between the date object and 00:00:00 UTC on 1 January 1970.
  
      This property's value is negative if the date object is earlier than 00:00:00 UTC on 1 January 1970.
  
      - SeeAlso: `timeIntervalSince(_:)`
      - SeeAlso: `timeIntervalSinceNow`
      - SeeAlso: `timeIntervalSinceReferenceDate`
      */
  var timeIntervalSince1970: TimeInterval { get }
  /// Return a new `Date` by adding a `TimeInterval` to this `Date`.
  ///
  /// - parameter timeInterval: The value to add, in seconds.
  /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
  func addingTimeInterval(_ timeInterval: TimeInterval) -> Date
  /// Add a `TimeInterval` to this `Date`.
  ///
  /// - parameter timeInterval: The value to add, in seconds.
  /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
  mutating func addTimeInterval(_ timeInterval: TimeInterval)
  /**
  Creates and returns a Date value representing a date in the distant future.
  
  The distant future is in terms of centuries.
  */
  static let distantFuture: Date
  /**
  Creates and returns a Date value representing a date in the distant past.
  
  The distant past is in terms of centuries.
  */
  static let distantPast: Date
  /// Returns a `Date` initialized to the current date and time.
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  static var now: Date { get }
  func hash(into hasher: inout Hasher)
  /// Compare two `Date` values.
  func compare(_ other: Date) -> ComparisonResult
  /// Returns true if the two `Date` values represent the same point in time.
  static func == (lhs: Date, rhs: Date) -> Bool
  /// Returns true if the left hand `Date` is earlier in time than the right hand `Date`.
  static func < (lhs: Date, rhs: Date) -> Bool
  /// Returns true if the left hand `Date` is later in time than the right hand `Date`.
  static func > (lhs: Date, rhs: Date) -> Bool
  /// Returns a `Date` with a specified amount of time added to it.
  static func + (lhs: Date, rhs: TimeInterval) -> Date
  /// Returns a `Date` with a specified amount of time subtracted from it.
  static func - (lhs: Date, rhs: TimeInterval) -> Date
  /// Add a `TimeInterval` to a `Date`.
  ///
  /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
  static func += (lhs: inout Date, rhs: TimeInterval)
  /// Subtract a `TimeInterval` from a `Date`.
  ///
  /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
  static func -= (lhs: inout Date, rhs: TimeInterval)
  var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Date {
  typealias Stride = TimeInterval
  func distance(to other: Date) -> TimeInterval
  func advanced(by n: TimeInterval) -> Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  /// Formats a `Date` using the given format.
  struct VerbatimFormatStyle : FormatStyle {
    var timeZone: TimeZone
    var calendar: Calendar
    /// Use system locale if nil or unspecified.
    var locale: Locale?
    init(format: Date.FormatString, locale: Locale? = nil, timeZone: TimeZone, calendar: Calendar)
    /// Returns the corresponding `AttributedStyle` which formats the date with  `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`
    var attributed: Date.AttributedStyle { get }
    func format(_ value: Date) -> String
    func locale(_ locale: Locale) -> Date.VerbatimFormatStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.VerbatimFormatStyle, b: Date.VerbatimFormatStyle) -> Bool
    typealias FormatInput = Date
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

extension Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct RelativeFormatStyle : FormatStyle, Codable, Hashable {
    struct UnitsStyle : Codable, Hashable {
      /// "2 months ago", "next Wednesday"
      static var wide: Date.RelativeFormatStyle.UnitsStyle { get }
      /// "two months ago", "next Wednesday"
      static var spellOut: Date.RelativeFormatStyle.UnitsStyle { get }
      /// "2 mo. ago", "next Wed."
      static var abbreviated: Date.RelativeFormatStyle.UnitsStyle { get }
      /// "2 mo. ago", "next W"
      static var narrow: Date.RelativeFormatStyle.UnitsStyle { get }
      func hash(into hasher: inout Hasher)
      static func == (a: Date.RelativeFormatStyle.UnitsStyle, b: Date.RelativeFormatStyle.UnitsStyle) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    struct Presentation : Codable, Hashable {
      /// "1 day ago", "2 days ago", "1 week ago", "in 1 week"
      static var numeric: Date.RelativeFormatStyle.Presentation { get }
      /// "yesterday", "2 days ago", "last week", "next week"; falls back to the numeric style if no name is available.
      static var named: Date.RelativeFormatStyle.Presentation { get }
      func hash(into hasher: inout Hasher)
      static func == (a: Date.RelativeFormatStyle.Presentation, b: Date.RelativeFormatStyle.Presentation) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    var presentation: Date.RelativeFormatStyle.Presentation
    var unitsStyle: Date.RelativeFormatStyle.UnitsStyle
    var capitalizationContext: FormatStyleCapitalizationContext
    var locale: Locale
    var calendar: Calendar
    init(presentation: Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)
    func format(_ destDate: Date) -> String
    func locale(_ locale: Locale) -> Date.RelativeFormatStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.RelativeFormatStyle, b: Date.RelativeFormatStyle) -> Bool
    typealias FormatInput = Date
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  /// Options for parsing string representations of dates to create a `Date` instance.
  struct ParseStrategy : Hashable {
    /// Indicates whether to use heuristics when parsing the representation.
    var isLenient: Bool
    /// The earliest date that can be denoted by a two-digit year specifier.
    var twoDigitStartDate: Date
    /// The locale to use when parsing date strings with the specified format.
    /// Use system locale if unspecified.
    var locale: Locale?
    /// The time zone to use for creating the date.
    var timeZone: TimeZone
    /// The calendar to use when parsing date strings and creating the date.
    var calendar: Calendar
    /// The string representation of the fixed format conforming to Unicode Technical Standard #35.
    var format: String { get }
    /// Creates a new `ParseStrategy` with the given configurations.
    /// - Parameters:
    ///   - format: A fixed format representing the pattern of the date string.
    ///   - locale: The locale of the fixed format.
    ///   - timeZone: The time zone to use for creating the date.
    ///   - isLenient: Whether to use heuristics when parsing the representation.
    ///   - twoDigitStartDate: The earliest date that can be denoted by a two-digit year specifier.
    init(format: Date.FormatString, locale: Locale? = nil, timeZone: TimeZone, calendar: Calendar = Calendar(identifier: .gregorian), isLenient: Bool = true, twoDigitStartDate: Date = Date(timeIntervalSince1970: 0))
    func hash(into hasher: inout Hasher)
    static func == (a: Date.ParseStrategy, b: Date.ParseStrategy) -> Bool
    var hashValue: Int { get }
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  /// Converts `self` to its textual representation.
  /// - Parameter format: The format for formatting `self`.
  /// - Returns: A representation of `self` using the given `format`. The type of the representation is specified by `FormatStyle.FormatOutput`.
  func formatted<F>(_ format: F) -> F.FormatOutput where F : FormatStyle, F.FormatInput == Date
  /// Converts `self` to its textual representation that contains both the date and time parts. The exact format depends on the user's preferences.
  /// - Parameters:
  ///   - date: The style for describing the date part.
  ///   - time: The style for describing the time part.
  /// - Returns: A `String` describing `self`.
  func formatted(date: Date.FormatStyle.DateStyle, time: Date.FormatStyle.TimeStyle) -> String
  func formatted() -> String
  /// Creates a new `Date` by parsing the given representation.
  /// - Parameter value: A representation of a date. The type of the representation is specified by `ParseStrategy.ParseInput`.
  /// - Parameters:
  ///   - value: A representation of a date. The type of the representation is specified by `ParseStrategy.ParseInput`.
  ///   - strategy: The parse strategy to parse `value` whose `ParseOutput` is `Date`.
  init<T>(_ value: T.ParseInput, strategy: T) throws where T : ParseStrategy, T.ParseOutput == Date
  @_disfavoredOverload init<T, Value>(_ value: Value, strategy: T) throws where T : ParseStrategy, Value : StringProtocol, T.ParseInput == String, T.ParseOutput == Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  /// Strategies for formatting a `Date`.
  struct FormatStyle {
    /// The locale to use when formatting date and time values.
    var locale: Locale
    /// The time zone with which to specify date and time values.
    var timeZone: TimeZone
    /// The calendar to use for date values.
    var calendar: Calendar
    /// The capitalization formatting context used when formatting date and time values.
    var capitalizationContext: FormatStyleCapitalizationContext
    /// Returns
    var attributed: Date.AttributedStyle { get }
    /// Creates a new `FormatStyle` with the given configurations.
    /// - Parameters:
    ///   - date:  The date style for formatting the date.
    ///   - time:  The time style for formatting the date.
    ///   - locale: The locale to use when formatting date and time values.
    ///   - calendar: The calendar to use for date values.
    ///   - timeZone: The time zone with which to specify date and time values.
    ///   - capitalizationContext: The capitalization formatting context used when formatting date and time values.
    /// - Note: Always specify the date length, time length, or the date components to be included in the formatted string with the symbol modifiers. Otherwise, an empty string will be returned when you use the instance to format a `Date`.
    init(date: Date.FormatStyle.DateStyle? = nil, time: Date.FormatStyle.TimeStyle? = nil, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, timeZone: TimeZone = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)
  }
  struct AttributedStyle : FormatStyle {
    /// Returns an attributed string with `AttributeScopes.FoundationAttributes.DateFieldAttribute`
    func format(_ value: Date) -> AttributedString
    func locale(_ locale: Locale) -> Date.AttributedStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.AttributedStyle, b: Date.AttributedStyle) -> Bool
    typealias FormatInput = Date
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  struct FormatString : Hashable {
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatString, b: Date.FormatString) -> Bool
    var hashValue: Int { get }
  }
}

extension Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct IntervalFormatStyle : FormatStyle, Codable, Hashable {
    typealias DateStyle = Date.FormatStyle.DateStyle
    typealias TimeStyle = Date.FormatStyle.TimeStyle
    var locale: Locale
    var timeZone: TimeZone
    var calendar: Calendar
    /// Creates a new `FormatStyle` with the given configurations.
    /// - Parameters:
    ///   - date: The style for formatting the date part of the given date pairs. Note that if `.omitted` is specified, but the date interval spans more than one day, a locale-specific fallback will be used.
    ///   - time: The style for formatting the time part of the given date pairs.
    ///   - locale: The locale to use when formatting date and time values.
    ///   - calendar: The calendar to use for date values.
    ///   - timeZone: The time zone with which to specify date and time values.
    /// - Important: Always specify the date length, time length, or the date components to be included in the formatted string with the symbol modifiers. Otherwise, an empty string will be returned when you use the instance to format an object.
    /// - Note: If specifying the date fields, and the `DateInterval` range is larger than the specified units, a locale-specific fallback will be used.
    ///     - Example: for the range 2010-03-04 07:56 - 2010-03-08 16:11 (4 days, 8 hours, 15 minutes), specifying `.hour().minute()` will produce
    ///         - for en_US, "3/4/2010 7:56 AM - 3/8/2010 4:11 PM"
    ///         - for en_GB, "4/3/2010 7:56 - 8/3/2010 16:11"
    init(date: Date.IntervalFormatStyle.DateStyle? = nil, time: Date.IntervalFormatStyle.TimeStyle? = nil, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, timeZone: TimeZone = .autoupdatingCurrent)
    func format(_ v: Range<Date>) -> String
    func locale(_ locale: Locale) -> Date.IntervalFormatStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.IntervalFormatStyle, b: Date.IntervalFormatStyle) -> Bool
    typealias FormatInput = Range<Date>
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

extension Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct ComponentsFormatStyle : FormatStyle, Codable, Hashable {
    struct Field : Codable, Hashable {
      static var year: Date.ComponentsFormatStyle.Field { get }
      static var month: Date.ComponentsFormatStyle.Field { get }
      static var week: Date.ComponentsFormatStyle.Field { get }
      static var day: Date.ComponentsFormatStyle.Field { get }
      static var hour: Date.ComponentsFormatStyle.Field { get }
      static var minute: Date.ComponentsFormatStyle.Field { get }
      static var second: Date.ComponentsFormatStyle.Field { get }
      func hash(into hasher: inout Hasher)
      static func == (a: Date.ComponentsFormatStyle.Field, b: Date.ComponentsFormatStyle.Field) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    struct Style : Codable, Hashable {
      /// Shows the fields in their full spelling.
      /// For example, "2 hour, 10 minutes", "2小時10分鐘"
      static var wide: Date.ComponentsFormatStyle.Style { get }
      /// Shows the fields in the abbreviation.
      /// For example, "2 hr, 10 min", "2小時10分鐘"
      static var abbreviated: Date.ComponentsFormatStyle.Style { get }
      /// Uses the abbreviated form but condensed if possible.
      /// For example, "2hr 10min", "2小時10分鐘"
      static var condensedAbbreviated: Date.ComponentsFormatStyle.Style { get }
      /// Shows the fields in the shortest form possible.
      /// For example, "2h 10m", "2時10分"
      static var narrow: Date.ComponentsFormatStyle.Style { get }
      /// Values are spelled out and fields are displayed in their full name.
      /// For example, "two hours, ten minutes", "2小時10分鐘"
      static var spellOut: Date.ComponentsFormatStyle.Style { get }
      func hash(into hasher: inout Hasher)
      static func == (a: Date.ComponentsFormatStyle.Style, b: Date.ComponentsFormatStyle.Style) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    var style: Date.ComponentsFormatStyle.Style
    var fields: Set<Date.ComponentsFormatStyle.Field>?
    var calendar: Calendar
    var locale: Locale
    /// Shows the date interval with the specified style and the specified date and time fields.
    /// - Parameters:
    ///   - style: The style for the field names.
    ///   - locale: The locale for formatting the date interval. May affect the language in which the formatted fields are displayed and how the individual fields are connected.
    ///   - calendar: The calendar to interpret date values.
    ///   - fields: The fields to be included in the output string. Chosen automatically based on the interval being formatted if unspecified. Fields with 0 value are dropped.
    init(style: Date.ComponentsFormatStyle.Style, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, fields: Set<Date.ComponentsFormatStyle.Field>? = nil)
    func format(_ v: Range<Date>) -> String
    func calendar(_ calendar: Calendar) -> Date.ComponentsFormatStyle
    func locale(_ locale: Locale) -> Date.ComponentsFormatStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.ComponentsFormatStyle, b: Date.ComponentsFormatStyle) -> Bool
    typealias FormatInput = Range<Date>
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

extension Date : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  /**
   A string representation of the date object (read-only).
   
   The representation is useful for debugging only.
   
   There are a number of options to acquire a formatted string for a date including: date formatters (see
   [NSDateFormatter](//apple_ref/occ/cl/NSDateFormatter) and [Data Formatting Guide](//apple_ref/doc/uid/10000029i)), and the `Date` function `description(locale:)`.
   */
  var description: String { get }
  /**
   Returns a string representation of the receiver using the given
   locale.
   
   - Parameter locale: A `Locale`. If you pass `nil`, `Date` formats the date in the same way as the `description` property.
   
   - Returns: A string representation of the `Date`, using the given locale, or if the locale argument is `nil`, in the international format `YYYY-MM-DD HH:MM:SS ±HHMM`, where `±HHMM` represents the time zone offset in hours and minutes from UTC (for example, "`2001-03-24 10:45:32 +0600`").
   */
  func description(with locale: Locale?) -> String
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension Date : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSDate
  static func _forceBridgeFromObjectiveC(_ x: NSDate, result: inout Date?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSDate, result: inout Date?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSDate?) -> Date
  typealias _ObjectiveCType = NSDate
}

extension Date : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Date : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  func ISO8601Format(_ style: Date.ISO8601FormatStyle = .init()) -> String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {
  /// Options for generating and parsing string representations of dates following the ISO 8601 standard.
  struct ISO8601FormatStyle {
    enum TimeZoneSeparator : String, Codable {
      case colon
      case omitted
      init?(rawValue: String)
      typealias RawValue = String
      var rawValue: String { get }
    }
    enum DateSeparator : String, Codable {
      case dash
      case omitted
      init?(rawValue: String)
      typealias RawValue = String
      var rawValue: String { get }
    }
    enum TimeSeparator : String, Codable {
      case colon
      case omitted
      init?(rawValue: String)
      typealias RawValue = String
      var rawValue: String { get }
    }
    enum DateTimeSeparator : String, Codable {
      case space
      case standard
      init?(rawValue: String)
      typealias RawValue = String
      var rawValue: String { get }
    }
    var timeSeparator: Date.ISO8601FormatStyle.TimeSeparator { get }
    var includingFractionalSeconds: Bool { get }
    var timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator { get }
    var dateSeparator: Date.ISO8601FormatStyle.DateSeparator { get }
    var dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator { get }
    /// The time zone to use to create and parse date representations.
    var timeZone: TimeZone
    @_disfavoredOverload init(dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeZone: TimeZone = TimeZone(secondsFromGMT: 0)!)
    init(dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Bool = false, timeZone: TimeZone = TimeZone(secondsFromGMT: 0)!)
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.VerbatimFormatStyle : ParseableFormatStyle {
  var parseStrategy: Date.ParseStrategy { get }
  typealias Strategy = Date.ParseStrategy
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ParseStrategy : ParseStrategy {
  /// Returns a `Date` of a given string interpreted using the current settings.
  /// - Parameter value: A string representation of a date.
  /// - Throws: Throws `NSFormattingError` if the string cannot be parsed.
  /// - Returns: A `Date` represented by `value`.
  func parse(_ value: String) throws -> Date
  typealias ParseInput = String
  typealias ParseOutput = Date
  func encode(to encoder: Encoder) throws
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
  func era(_ format: Date.FormatStyle.Symbol.Era = .abbreviated) -> Date.FormatStyle
  func year(_ format: Date.FormatStyle.Symbol.Year = .defaultDigits) -> Date.FormatStyle
  func quarter(_ format: Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Date.FormatStyle
  func month(_ format: Date.FormatStyle.Symbol.Month = .abbreviated) -> Date.FormatStyle
  func week(_ format: Date.FormatStyle.Symbol.Week = .defaultDigits) -> Date.FormatStyle
  func day(_ format: Date.FormatStyle.Symbol.Day = .defaultDigits) -> Date.FormatStyle
  func dayOfYear(_ format: Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Date.FormatStyle
  func weekday(_ format: Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Date.FormatStyle
  func hour(_ format: Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Date.FormatStyle
  func minute(_ format: Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Date.FormatStyle
  func second(_ format: Date.FormatStyle.Symbol.Second = .defaultDigits) -> Date.FormatStyle
  func secondFraction(_ format: Date.FormatStyle.Symbol.SecondFraction) -> Date.FormatStyle
  func timeZone(_ format: Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Date.FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : FormatStyle {
  func format(_ value: Date) -> String
  func locale(_ locale: Locale) -> Date.FormatStyle
  typealias FormatInput = Date
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : ParseStrategy {
  func parse(_ value: String) throws -> Date
  typealias ParseInput = String
  typealias ParseOutput = Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : Codable, Hashable {
  func encode(to encoder: Encoder) throws
  init(from decoder: Decoder) throws
  func hash(into hasher: inout Hasher)
  static func == (a: Date.FormatStyle, b: Date.FormatStyle) -> Bool
  var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
  /// Predefined date styles varied in lengths or the components included. The exact format depends on the locale.
  struct DateStyle : Codable, Hashable {
    /// Excludes the date part.
    static let omitted: Date.FormatStyle.DateStyle
    /// Shows date components in their numeric form. For example, "10/21/2015".
    static let numeric: Date.FormatStyle.DateStyle
    /// Shows date components in their abbreviated form if possible. For example, "Oct 21, 2015".
    static let abbreviated: Date.FormatStyle.DateStyle
    /// Shows date components in their long form if possible. For example, "October 21, 2015".
    static let long: Date.FormatStyle.DateStyle
    /// Shows the complete day. For example, "Wednesday, October 21, 2015".
    static let complete: Date.FormatStyle.DateStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.DateStyle, b: Date.FormatStyle.DateStyle) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  /// Predefined time styles varied in lengths or the components included. The exact format depends on the locale.
  struct TimeStyle : Codable, Hashable {
    /// Excludes the time part.
    static let omitted: Date.FormatStyle.TimeStyle
    /// For example, `04:29 PM`, `16:29`.
    static let shortened: Date.FormatStyle.TimeStyle
    /// For example, `4:29:24 PM`, `16:29:24`.
    static let standard: Date.FormatStyle.TimeStyle
    /// For example, `4:29:24 PM PDT`, `16:29:24 GMT`.
    static let complete: Date.FormatStyle.TimeStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.TimeStyle, b: Date.FormatStyle.TimeStyle) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : ParseableFormatStyle {
  var parseStrategy: Date.FormatStyle { get }
  typealias Strategy = Date.FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {
  struct Symbol : Hashable {
    struct Era : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Era, b: Date.FormatStyle.Symbol.Era) -> Bool
      var hashValue: Int { get }
    }
    struct Year : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Year, b: Date.FormatStyle.Symbol.Year) -> Bool
      var hashValue: Int { get }
    }
    struct YearForWeekOfYear : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.YearForWeekOfYear, b: Date.FormatStyle.Symbol.YearForWeekOfYear) -> Bool
      var hashValue: Int { get }
    }
    struct CyclicYear : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.CyclicYear, b: Date.FormatStyle.Symbol.CyclicYear) -> Bool
      var hashValue: Int { get }
    }
    struct Quarter : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Quarter, b: Date.FormatStyle.Symbol.Quarter) -> Bool
      var hashValue: Int { get }
    }
    struct Month : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Month, b: Date.FormatStyle.Symbol.Month) -> Bool
      var hashValue: Int { get }
    }
    struct Week : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Week, b: Date.FormatStyle.Symbol.Week) -> Bool
      var hashValue: Int { get }
    }
    struct Day : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Day, b: Date.FormatStyle.Symbol.Day) -> Bool
      var hashValue: Int { get }
    }
    struct DayOfYear : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.DayOfYear, b: Date.FormatStyle.Symbol.DayOfYear) -> Bool
      var hashValue: Int { get }
    }
    struct Weekday : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Weekday, b: Date.FormatStyle.Symbol.Weekday) -> Bool
      var hashValue: Int { get }
    }
    struct DayPeriod : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.DayPeriod, b: Date.FormatStyle.Symbol.DayPeriod) -> Bool
      var hashValue: Int { get }
    }
    struct Hour : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Hour, b: Date.FormatStyle.Symbol.Hour) -> Bool
      var hashValue: Int { get }
    }
    struct Minute : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Minute, b: Date.FormatStyle.Symbol.Minute) -> Bool
      var hashValue: Int { get }
    }
    struct Second : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.Second, b: Date.FormatStyle.Symbol.Second) -> Bool
      var hashValue: Int { get }
    }
    struct SecondFraction : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.SecondFraction, b: Date.FormatStyle.Symbol.SecondFraction) -> Bool
      var hashValue: Int { get }
    }
    struct TimeZone : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.TimeZone, b: Date.FormatStyle.Symbol.TimeZone) -> Bool
      var hashValue: Int { get }
    }
    struct StandaloneQuarter : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.StandaloneQuarter, b: Date.FormatStyle.Symbol.StandaloneQuarter) -> Bool
      var hashValue: Int { get }
    }
    struct StandaloneMonth : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.StandaloneMonth, b: Date.FormatStyle.Symbol.StandaloneMonth) -> Bool
      var hashValue: Int { get }
    }
    struct StandaloneWeekday : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.StandaloneWeekday, b: Date.FormatStyle.Symbol.StandaloneWeekday) -> Bool
      var hashValue: Int { get }
    }
    struct VerbatimHour : Hashable {
      func hash(into hasher: inout Hasher)
      static func == (a: Date.FormatStyle.Symbol.VerbatimHour, b: Date.FormatStyle.Symbol.VerbatimHour) -> Bool
      var hashValue: Int { get }
    }
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.Symbol, b: Date.FormatStyle.Symbol) -> Bool
    var hashValue: Int { get }
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatString : ExpressibleByStringInterpolation {
  init(stringInterpolation: Date.FormatString.StringInterpolation)
  init(stringLiteral value: String)
  struct StringInterpolation : StringInterpolationProtocol {
    typealias StringLiteralType = String
    init(literalCapacity: Int, interpolationCount: Int)
    mutating func appendLiteral(_ literal: String)
    mutating func appendInterpolation(era: Date.FormatStyle.Symbol.Era)
    mutating func appendInterpolation(year: Date.FormatStyle.Symbol.Year)
    mutating func appendInterpolation(yearForWeekOfYear: Date.FormatStyle.Symbol.YearForWeekOfYear)
    mutating func appendInterpolation(cyclicYear: Date.FormatStyle.Symbol.CyclicYear)
    mutating func appendInterpolation(quarter: Date.FormatStyle.Symbol.Quarter)
    mutating func appendInterpolation(standaloneQuarter: Date.FormatStyle.Symbol.StandaloneQuarter)
    mutating func appendInterpolation(month: Date.FormatStyle.Symbol.Month)
    mutating func appendInterpolation(standaloneMonth: Date.FormatStyle.Symbol.StandaloneMonth)
    mutating func appendInterpolation(week: Date.FormatStyle.Symbol.Week)
    mutating func appendInterpolation(day: Date.FormatStyle.Symbol.Day)
    mutating func appendInterpolation(dayOfYear: Date.FormatStyle.Symbol.DayOfYear)
    mutating func appendInterpolation(weekday: Date.FormatStyle.Symbol.Weekday)
    mutating func appendInterpolation(standaloneWeekday: Date.FormatStyle.Symbol.StandaloneWeekday)
    mutating func appendInterpolation(dayPeriod: Date.FormatStyle.Symbol.DayPeriod)
    mutating func appendInterpolation(hour: Date.FormatStyle.Symbol.VerbatimHour)
    mutating func appendInterpolation(minute: Date.FormatStyle.Symbol.Minute)
    mutating func appendInterpolation(second: Date.FormatStyle.Symbol.Second)
    mutating func appendInterpolation(secondFraction: Date.FormatStyle.Symbol.SecondFraction)
    mutating func appendInterpolation(timeZone: Date.FormatStyle.Symbol.TimeZone)
  }
  typealias ExtendedGraphemeClusterLiteralType = String
  typealias StringLiteralType = String
  typealias UnicodeScalarLiteralType = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.IntervalFormatStyle {
  typealias Symbol = Date.FormatStyle.Symbol
  func year() -> Date.IntervalFormatStyle
  func month(_ format: Date.IntervalFormatStyle.Symbol.Month = .abbreviated) -> Date.IntervalFormatStyle
  func day() -> Date.IntervalFormatStyle
  func weekday(_ format: Date.IntervalFormatStyle.Symbol.Weekday = .abbreviated) -> Date.IntervalFormatStyle
  func hour(_ format: Date.IntervalFormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Date.IntervalFormatStyle
  func minute() -> Date.IntervalFormatStyle
  func second() -> Date.IntervalFormatStyle
  func timeZone(_ format: Date.IntervalFormatStyle.Symbol.TimeZone = .genericName(.short)) -> Date.IntervalFormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle {
  func year() -> Date.ISO8601FormatStyle
  func weekOfYear() -> Date.ISO8601FormatStyle
  func month() -> Date.ISO8601FormatStyle
  func day() -> Date.ISO8601FormatStyle
  func time(includingFractionalSeconds: Bool) -> Date.ISO8601FormatStyle
  func timeZone(separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> Date.ISO8601FormatStyle
  func dateSeparator(_ separator: Date.ISO8601FormatStyle.DateSeparator) -> Date.ISO8601FormatStyle
  func dateTimeSeparator(_ separator: Date.ISO8601FormatStyle.DateTimeSeparator) -> Date.ISO8601FormatStyle
  func timeSeparator(_ separator: Date.ISO8601FormatStyle.TimeSeparator) -> Date.ISO8601FormatStyle
  func timeZoneSeparator(_ separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> Date.ISO8601FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : FormatStyle {
  func format(_ value: Date) -> String
  func hash(into hasher: inout Hasher)
  static func == (a: Date.ISO8601FormatStyle, b: Date.ISO8601FormatStyle) -> Bool
  typealias FormatInput = Date
  typealias FormatOutput = String
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : ParseStrategy {
  func parse(_ value: String) throws -> Date
  typealias ParseInput = String
  typealias ParseOutput = Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : ParseableFormatStyle {
  var parseStrategy: Date.ISO8601FormatStyle { get }
  typealias Strategy = Date.ISO8601FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Era {
  /// Abbreviated Era name. For example, "AD", "Reiwa", "令和".
  static var abbreviated: Date.FormatStyle.Symbol.Era { get }
  /// Wide era name. For example, "Anno Domini", "Reiwa", "令和".
  static var wide: Date.FormatStyle.Symbol.Era { get }
  /// Narrow era name.
  /// For example, For example, "A", "R", "R".
  static var narrow: Date.FormatStyle.Symbol.Era { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Year {
  /// Minimum number of digits that shows the full year.
  /// For example, `2`, `20`, `201`, `2017`, `20173`.
  static var defaultDigits: Date.FormatStyle.Symbol.Year { get }
  /// Two low-order digits.
  /// Padded or truncated if necessary. For example, `02`, `20`, `01`, `17`, `73`.
  static var twoDigits: Date.FormatStyle.Symbol.Year { get }
  /// Three or more digits.
  /// Padded if necessary. For example, `002`, `020`, `201`, `2017`, `20173`.
  static func padded(_ length: Int) -> Date.FormatStyle.Symbol.Year
  /// Related Gregorian year.
  /// For non-Gregorian calendars, this corresponds to the extended Gregorian year in which the calendar’s year begins. Related Gregorian years are often displayed, for example, when formatting dates in the Japanese calendar — e.g. "2012(平成24)年1月15日" — or in the Chinese calendar — e.g. "2012壬辰年腊月初四".
  static func relatedGregorian(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Year
  /// Extended year.
  /// This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0.
  static func extended(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Year
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.YearForWeekOfYear {
  /// Minimum number of digits that shows the full year in "Week of Year"-based calendars.
  /// For example, `2`, `20`, `201`, `2017`, `20173`.
  static var defaultDigits: Date.FormatStyle.Symbol.YearForWeekOfYear { get }
  /// Two low-order digits.  Padded or truncated if necessary.
  /// For example, `02`, `20`, `01`, `17`, `73`.
  static var twoDigits: Date.FormatStyle.Symbol.YearForWeekOfYear { get }
  /// Three or more digits. Padded if necessary.
  /// For example, `002`, `020`, `201`, `2017`, `20173`.
  static func padded(_ length: Int) -> Date.FormatStyle.Symbol.YearForWeekOfYear
}

/// Cyclic year symbols.
///
/// Calendars such as the Chinese lunar calendar (and related calendars) and the Hindu calendars use 60-year cycles of year names. If the calendar does not provide cyclic year name data, or if the year value to be formatted is out of the range of years for which cyclic name data is provided, then numeric formatting is used (behaves like `Year`).
///
/// Currently the data only provides abbreviated names, which will be used for all requested name widths.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.CyclicYear {
  /// Abbreviated cyclic year name.
  /// For example, "甲子".
  static var abbreviated: Date.FormatStyle.Symbol.CyclicYear { get }
  /// Wide cyclic year name.
  /// For example, "甲子".
  static var wide: Date.FormatStyle.Symbol.CyclicYear { get }
  /// Narrow cyclic year name.
  /// For example, "甲子".
  static var narrow: Date.FormatStyle.Symbol.CyclicYear { get }
}

/// Quarter symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Quarter {
  /// Numeric: one digit quarter. For example `2`.
  static var oneDigit: Date.FormatStyle.Symbol.Quarter { get }
  /// Numeric: two digits with zero padding. For example `02`.
  static var twoDigits: Date.FormatStyle.Symbol.Quarter { get }
  /// Abbreviated quarter. For example `Q2`.
  static var abbreviated: Date.FormatStyle.Symbol.Quarter { get }
  /// The quarter spelled out in full, for example `2nd quarter`.
  static var wide: Date.FormatStyle.Symbol.Quarter { get }
  /// Narrow quarter. For example `2`.
  static var narrow: Date.FormatStyle.Symbol.Quarter { get }
}

/// Month symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Month {
  /// Minimum number of digits that shows the numeric month. Intended to be used in conjunction with `Day.defaultDigits`.
  /// For example, `9`, `12`.
  static var defaultDigits: Date.FormatStyle.Symbol.Month { get }
  /// 2 digits, zero pad if needed. For example, `09`, `12`.
  static var twoDigits: Date.FormatStyle.Symbol.Month { get }
  /// Abbreviated month name. For example, "Sep".
  static var abbreviated: Date.FormatStyle.Symbol.Month { get }
  /// Wide month name. For example, "September".
  static var wide: Date.FormatStyle.Symbol.Month { get }
  /// Narrow month name. For example, "S".
  static var narrow: Date.FormatStyle.Symbol.Month { get }
}

/// Week symbols. Use with `YearForWeekOfYear` for the year field instead of `Year`.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Week {
  /// Numeric week of year. For example, `8`, `27`.
  static var defaultDigits: Date.FormatStyle.Symbol.Week { get }
  /// Two-digit numeric week of year, zero padded as necessary. For example, `08`, `27`.
  static var twoDigits: Date.FormatStyle.Symbol.Week { get }
  /// One-digit numeric week of month, starting from 1. For example, `1`.
  static var weekOfMonth: Date.FormatStyle.Symbol.Week { get }
}

/// Day symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Day {
  /// Minimum number of digits that shows the full numeric day of month. For example, `1`, `18`.
  static var defaultDigits: Date.FormatStyle.Symbol.Day { get }
  /// Two-digit, zero-padded if necessary. For example, `01`, `18`.
  static var twoDigits: Date.FormatStyle.Symbol.Day { get }
  /// Ordinal of day in month.
  /// For example, the 2nd Wed in July would yield `2`.
  static var ordinalOfDayInMonth: Date.FormatStyle.Symbol.Day { get }
  /// The field length specifies the minimum number of digits, with zero-padding as necessary.
  /// This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields.
  /// For example, `2451334`.
  static func julianModified(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Day
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayOfYear {
  /// Minimum number of digits that shows the full numeric day of year. For example, `7`, `33`, `345`.
  static var defaultDigits: Date.FormatStyle.Symbol.DayOfYear { get }
  /// Two-digit day of year, with zero-padding as necessary. For example, `07`, `33`, `345`.
  static var twoDigits: Date.FormatStyle.Symbol.DayOfYear { get }
  /// Three-digit day of year, with zero-padding as necessary. For example, `007`, `033`, `345`.
  static var threeDigits: Date.FormatStyle.Symbol.DayOfYear { get }
}

/// Week day name symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Weekday {
  /// Abbreviated day of week name. For example, "Tue".
  static var abbreviated: Date.FormatStyle.Symbol.Weekday { get }
  /// Wide day of week name. For example, "Tuesday".
  static var wide: Date.FormatStyle.Symbol.Weekday { get }
  /// Narrow day of week name. For example, "T".
  static var narrow: Date.FormatStyle.Symbol.Weekday { get }
  /// Short day of week name. For example, "Tu".
  static var short: Date.FormatStyle.Symbol.Weekday { get }
  /// Local day of week number/name. The value depends on the local starting day of the week.
  static var oneDigit: Date.FormatStyle.Symbol.Weekday { get }
  /// Local day of week number/name, format style; two digits, zero-padded if necessary.
  static var twoDigits: Date.FormatStyle.Symbol.Weekday { get }
}

/// The time period (for example, "a.m." or "p.m."). May be upper or lower case depending on the locale and other options.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod {
  enum Width {
    case abbreviated
    case wide
    case narrow
    static func == (a: Date.FormatStyle.Symbol.DayPeriod.Width, b: Date.FormatStyle.Symbol.DayPeriod.Width) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// Standard day period. For example,
  /// Abbreviated: `12 am.`
  /// Wide: `12 am`
  /// Narrow: `12a`.
  static func standard(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod
  /// Day period including designations for noon and midnight. For example,
  /// Abbreviated: `mid`
  /// Wide: `midnight`
  /// Narrow: `md`.
  static func with12s(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod
  /// Conversational day period. For example,
  /// Abbreviated: `at night`, `nachm.`, `ip.`
  /// Wide: `at night`, `nachmittags`, `iltapäivällä`.
  /// Narrow: `at night`, `nachm.`, `iltap`.
  static func conversational(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod
}

/// Hour symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Hour {
  struct AMPMStyle : Codable, Hashable {
    /// Hides the day period marker (AM/PM).
    /// For example, `8` (for 8 in the morning), `1` (for 1 in the afternoon) if used with `defaultDigits`.
    /// Or `08`, `01` if used with `twoDigits`.
    static let omitted: Date.FormatStyle.Symbol.Hour.AMPMStyle
    /// Narrow day period if the locale prefers using day period with hour.
    /// For example, `8`, `8a`, `13`, `1p` if used with `defaultDigits`.
    /// Or `08`, `08a`, `13`, `01p` if used with `twoDigits`.
    static let narrow: Date.FormatStyle.Symbol.Hour.AMPMStyle
    /// Abbreviated day period if the locale prefers using day period with hour.
    /// For example, `8`, `8 AM`, `13`, `1 PM` if used with `defaultDigits`.
    /// Or `08`, `08 AM`, `13`, `01 PM` if used with `twoDigits`.
    static let abbreviated: Date.FormatStyle.Symbol.Hour.AMPMStyle
    /// Wide day period if the locale prefers using day period with hour.
    /// For example, `8`, `8 A.M.`, `13`, `1 P.M.` if used with `defaultDigits`.
    /// Or, `08`, `08 A.M.`, `13`, `01 P.M.` if used with `twoDigits`.
    static let wide: Date.FormatStyle.Symbol.Hour.AMPMStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.Symbol.Hour.AMPMStyle, b: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  /// The preferred numeric hour format for the locale with minimum digits. Whether the period symbol (AM/PM) will be shown depends on the locale.
  static func defaultDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour
  /// The preferred two-digit hour format for the locale, zero padded if necessary. Whether the period symbol (AM/PM) will be shown depends on the locale.
  static func twoDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour
  /// Behaves like `defaultDigits`: the preferred numeric hour format for the locale with minimum digits. May also use conversational period formats.
  static func conversationalDefaultDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour
  /// Behaves like `twoDigits`: two-digit hour format for the locale, zero padded if necessary. May also use conversational period formats.
  static func conversationalTwoDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour
  @available(*, deprecated, renamed: "defaultDigits(amPM:)")
  static var defaultDigitsNoAMPM: Date.FormatStyle.Symbol.Hour { get }
  @available(*, deprecated, renamed: "twoDigits(amPM:)")
  static var twoDigitsNoAMPM: Date.FormatStyle.Symbol.Hour { get }
}

/// Minute symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Minute {
  /// Minimum digits to show the numeric minute. Truncated, not rounded. For example, `8`, `59`.
  static var defaultDigits: Date.FormatStyle.Symbol.Minute { get }
  /// Two-digit numeric, zero padded if needed. For example, `08`, `59`.
  static var twoDigits: Date.FormatStyle.Symbol.Minute { get }
}

/// Second symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Second {
  /// Minimum digits to show the numeric second. Truncated, not rounded. For example, `8`, `12`.
  static var defaultDigits: Date.FormatStyle.Symbol.Second { get }
  /// Two digits numeric, zero padded if needed, not rounded. For example, `08`, `12`.
  static var twoDigits: Date.FormatStyle.Symbol.Second { get }
}

/// Fractions of a second  symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.SecondFraction {
  /// Fractional second (numeric).
  /// Truncates, like other numeric time fields, but in this case to the number of digits specified by the associated `Int`.
  /// For example, specifying `4` for seconds value `12.34567` yields `12.3456`.
  static func fractional(_ val: Int) -> Date.FormatStyle.Symbol.SecondFraction
  /// Milliseconds in day (numeric).
  /// The associated `Int` specifies the minimum number of digits, with zero-padding as necessary. The maximum number of digits is 9.
  /// This field behaves exactly like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value.
  static func milliseconds(_ val: Int) -> Date.FormatStyle.Symbol.SecondFraction
}

/// Time zone symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone {
  enum Width {
    case short
    case long
    static func == (a: Date.FormatStyle.Symbol.TimeZone.Width, b: Date.FormatStyle.Symbol.TimeZone.Width) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// Specific non-location format. Falls back to `shortLocalizedGMT` if unavailable. For example,
  /// short: "PDT"
  /// long: "Pacific Daylight Time".
  static func specificName(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone
  /// Generic non-location format. Falls back to `genericLocation` if unavailable. For example,
  /// short: "PT". Fallback again to `localizedGMT(.short)` if `genericLocation(.short)` is unavaiable.
  /// long: "Pacific Time"
  static func genericName(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone
  /// The ISO8601 format with hours, minutes and optional seconds fields. For example,
  /// short: "-0800"
  /// long: "-08:00" or "-07:52:58".
  static func iso8601(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone
  /// Short localized GMT format. For example,
  /// short: "GMT-8"
  /// long: "GMT-8:00"
  static func localizedGMT(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone
  /// The time zone ID. For example,
  /// short: "uslax"
  /// long: "America/Los_Angeles".
  static func identifier(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone
  /// The exemplar city (location) for the time zone. The localized exemplar city name for the special zone or unknown is used as the fallback if it is unavailable.
  /// For example, "Los Angeles".
  static var exemplarLocation: Date.FormatStyle.Symbol.TimeZone { get }
  /// The generic location format. Falls back to `longLocalizedGMT` if unavailable. Recommends for presenting possible time zone choices for user selection.
  /// For example, "Los Angeles Time".
  static var genericLocation: Date.FormatStyle.Symbol.TimeZone { get }
}

/// Standalone quarter symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneQuarter {
  /// Standalone one-digit numeric quarter. For example `2`.
  static var oneDigit: Date.FormatStyle.Symbol.StandaloneQuarter { get }
  /// Two-digit standalone numeric quarter with zero padding if necessary, for example `02`.
  static var twoDigits: Date.FormatStyle.Symbol.StandaloneQuarter { get }
  /// Standalone abbreviated quarter. For example `Q2`.
  static var abbreviated: Date.FormatStyle.Symbol.StandaloneQuarter { get }
  /// Standalone wide quarter. For example "2nd quarter".
  static var wide: Date.FormatStyle.Symbol.StandaloneQuarter { get }
  /// Standalone narrow quarter. For example "2".
  static var narrow: Date.FormatStyle.Symbol.StandaloneQuarter { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneMonth {
  /// Stand-alone minimum digits numeric month. Number/name (intended to be used without `Day`).
  /// For example, `9`, `12`.
  static var defaultDigits: Date.FormatStyle.Symbol.StandaloneMonth { get }
  /// Stand-alone two-digit numeric month.
  /// Two digits, zero pad if needed. For example, `09`, `12`.
  static var twoDigits: Date.FormatStyle.Symbol.StandaloneMonth { get }
  /// Stand-alone abbreviated month.
  /// For example, "Sep".
  static var abbreviated: Date.FormatStyle.Symbol.StandaloneMonth { get }
  /// Stand-alone wide month.
  /// For example, "September".
  static var wide: Date.FormatStyle.Symbol.StandaloneMonth { get }
  /// Stand-alone narrow month.
  /// For example, "S".
  static var narrow: Date.FormatStyle.Symbol.StandaloneMonth { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneWeekday {
  /// Standalone local day of week number/name.
  static var oneDigit: Date.FormatStyle.Symbol.StandaloneWeekday { get }
  /// Standalone local day of week number/name.
  /// For example, "Tue".
  static var abbreviated: Date.FormatStyle.Symbol.StandaloneWeekday { get }
  /// Standalone wide local day of week number/name.
  /// For example, "Tuesday".
  static var wide: Date.FormatStyle.Symbol.StandaloneWeekday { get }
  /// Standalone narrow local day of week number/name.
  /// For example, "T".
  static var narrow: Date.FormatStyle.Symbol.StandaloneWeekday { get }
  /// Standalone short local day of week number/name.
  /// For example, "Tu".
  static var short: Date.FormatStyle.Symbol.StandaloneWeekday { get }
}

/// Hour symbols that does not take users' preferences into account, and is displayed as-is.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.VerbatimHour {
  struct HourCycle : Codable, Hashable {
    /// The hour ranges from 0 to 11 in a 12-hour clock. Ranges from 0 to 23 in a 24-hour clock.
    static let zeroBased: Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    /// The hour ranges from 1 to 12 in the 12-hour clock. Ranges from 1 to 24 in a 24-hour clock.
    static let oneBased: Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.Symbol.VerbatimHour.HourCycle, b: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct Clock : Codable, Hashable {
    /// In a 12-hour clock system, the 24-hour day is divided into two periods, a.m. and p.m, and each period consists of 12 hours.
    /// - Note: Does not include the period marker (AM/PM). Specify a `PeriodSymbol` if that's desired.
    static let twelveHour: Date.FormatStyle.Symbol.VerbatimHour.Clock
    /// In a 24-hour clock system, the day runs from midnight to midnight, dividing into 24 hours.
    /// - Note: If using `twentyFourHour` together with `PeriodSymbol`, the period is ignored.
    static let twentyFourHour: Date.FormatStyle.Symbol.VerbatimHour.Clock
    func hash(into hasher: inout Hasher)
    static func == (a: Date.FormatStyle.Symbol.VerbatimHour.Clock, b: Date.FormatStyle.Symbol.VerbatimHour.Clock) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  /// Minimum digits to show the numeric hour. For example, `1`, `12`.
  /// Or `23` if using the `twentyFourHour` clock.
  /// - Note: This format does not take user's locale preferences into account. Consider using `defaultDigits` if applicable.
  static func defaultDigits(clock: Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Date.FormatStyle.Symbol.VerbatimHour
  /// Numeric two-digit hour, zero padded if necessary.
  /// For example, `01`, `12`.
  /// Or `23` if using the `twentyFourHour` clock.
  /// - Note: This format does not take user's locale preferences into account. Consider using `defaultDigits` if applicable.
  static func twoDigits(clock: Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Date.FormatStyle.Symbol.VerbatimHour
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod.Width : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone.Width : Hashable {
}

/**
 `DateComponents` encapsulates the components of a date in an extendable, structured manner. 
 
 It is used to specify a date by providing the temporal components that make up a date and time in a particular calendar: hour, minutes, seconds, day, month, year, and so on. It can also be used to specify a duration of time, for example, 5 hours and 16 minutes. A `DateComponents` is not required to define all the component fields. 
 
 When a new instance of `DateComponents` is created, the date components are set to `nil`.
*/
struct DateComponents : ReferenceConvertible, Hashable, Equatable {
  typealias ReferenceType = NSDateComponents
  /// Initialize a `DateComponents`, optionally specifying values for its fields.
  init(calendar: Calendar? = nil, timeZone: TimeZone? = nil, era: Int? = nil, year: Int? = nil, month: Int? = nil, day: Int? = nil, hour: Int? = nil, minute: Int? = nil, second: Int? = nil, nanosecond: Int? = nil, weekday: Int? = nil, weekdayOrdinal: Int? = nil, quarter: Int? = nil, weekOfMonth: Int? = nil, weekOfYear: Int? = nil, yearForWeekOfYear: Int? = nil)
  /// The `Calendar` used to interpret the other values in this structure.
  ///
  /// - note: API which uses `DateComponents` may have different behavior if this value is `nil`. For example, assuming the current calendar or ignoring certain values.
  var calendar: Calendar?
  /// A time zone.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var timeZone: TimeZone?
  /// An era or count of eras.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var era: Int?
  /// A year or count of years.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var year: Int?
  /// A month or count of months.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var month: Int?
  /// A day or count of days.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var day: Int?
  /// An hour or count of hours.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var hour: Int?
  /// A minute or count of minutes.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var minute: Int?
  /// A second or count of seconds.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var second: Int?
  /// A nanosecond or count of nanoseconds.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var nanosecond: Int?
  /// A weekday or count of weekdays.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var weekday: Int?
  /// A weekday ordinal or count of weekday ordinals.
  /// Weekday ordinal units represent the position of the weekday within the next larger calendar unit, such as the month. For example, 2 is the weekday ordinal unit for the second Friday of the month.///
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var weekdayOrdinal: Int?
  /// A quarter or count of quarters.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var quarter: Int?
  /// A week of the month or a count of weeks of the month.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var weekOfMonth: Int?
  /// A week of the year or count of the weeks of the year.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var weekOfYear: Int?
  /// The ISO 8601 week-numbering year of the receiver.
  ///
  /// The Gregorian calendar defines a week to have 7 days, and a year to have 365 days, or 366 in a leap year. However, neither 365 or 366 divide evenly into a 7 day week, so it is often the case that the last week of a year ends on a day in the next year, and the first week of a year begins in the preceding year. To reconcile this, ISO 8601 defines a week-numbering year, consisting of either 52 or 53 full weeks (364 or 371 days), such that the first week of a year is designated to be the week containing the first Thursday of the year.
  ///
  /// You can use the yearForWeekOfYear property with the weekOfYear and weekday properties to get the date corresponding to a particular weekday of a given week of a year. For example, the 6th day of the 53rd week of the year 2005 (ISO 2005-W53-6) corresponds to Sat 1 January 2005 on the Gregorian calendar.
  /// - note: This value is interpreted in the context of the calendar in which it is used.
  var yearForWeekOfYear: Int?
  /// Set to true if these components represent a leap month.
  var isLeapMonth: Bool?
  /// Returns a `Date` calculated from the current components using the `calendar` property.
  var date: Date? { get }
  /// Set the value of one of the properties, using an enumeration value instead of a property name.
  ///
  /// The calendar and timeZone and isLeapMonth properties cannot be set by this method.
  @available(macOS 10.9, iOS 8.0, *)
  mutating func setValue(_ value: Int?, for component: Calendar.Component)
  /// Returns the value of one of the properties, using an enumeration value instead of a property name.
  ///
  /// The calendar and timeZone and isLeapMonth property values cannot be retrieved by this method.
  @available(macOS 10.9, iOS 8.0, *)
  func value(for component: Calendar.Component) -> Int?
  /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the `calendar` property.
  ///
  /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
  ///
  /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
  ///
  /// If the time zone property is set in the `DateComponents`, it is used.
  ///
  /// The calendar property must be set, or the result is always `false`.
  @available(macOS 10.9, iOS 8.0, *)
  var isValidDate: Bool { get }
  /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the specified `Calendar`.
  ///
  /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
  ///
  /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
  ///
  /// If the time zone property is set in the `DateComponents`, it is used.
  @available(macOS 10.9, iOS 8.0, *)
  func isValidDate(in calendar: Calendar) -> Bool
  func hash(into hasher: inout Hasher)
  static func == (lhs: DateComponents, rhs: DateComponents) -> Bool
  var hashValue: Int { get }
}

extension DateComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension DateComponents : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSDateComponents
  static func _forceBridgeFromObjectiveC(_ dateComponents: NSDateComponents, result: inout DateComponents?)
  static func _conditionallyBridgeFromObjectiveC(_ dateComponents: NSDateComponents, result: inout DateComponents?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSDateComponents?) -> DateComponents
  typealias _ObjectiveCType = NSDateComponents
}

extension DateComponents : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/// DateInterval represents a closed date interval in the form of [startDate, endDate].  It is possible for the start and end dates to be the same with a duration of 0.  DateInterval does not support reverse intervals i.e. intervals where the duration is less than 0 and the end date occurs earlier in time than the start date.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
struct DateInterval : ReferenceConvertible, Comparable, Hashable, Codable {
  typealias ReferenceType = NSDateInterval
  /// The start date.
  var start: Date
  /// The end date.
  ///
  /// - precondition: `end >= start`
  var end: Date
  /// The duration.
  ///
  /// - precondition: `duration >= 0`
  var duration: TimeInterval
  /// Initializes a `DateInterval` with start and end dates set to the current date and the duration set to `0`.
  init()
  /// Initialize a `DateInterval` with the specified start and end date.
  ///
  /// - precondition: `end >= start`
  init(start: Date, end: Date)
  /// Initialize a `DateInterval` with the specified start date and duration.
  ///
  /// - precondition: `duration >= 0`
  init(start: Date, duration: TimeInterval)
  /**
   Compare two DateIntervals.
   
   This method prioritizes ordering by start date. If the start dates are equal, then it will order by duration.
   e.g. Given intervals a and b
   ```
   a.   |-----|
   b.      |-----|
   ```
   
   `a.compare(b)` would return `.OrderedAscending` because a's start date is earlier in time than b's start date.
  
   In the event that the start dates are equal, the compare method will attempt to order by duration.
   e.g. Given intervals c and d
   ```
   c.  |-----|
   d.  |---|
   ```
   `c.compare(d)` would result in `.OrderedDescending` because c is longer than d.
  
   If both the start dates and the durations are equal, then the intervals are considered equal and `.OrderedSame` is returned as the result.
  */
  func compare(_ dateInterval: DateInterval) -> ComparisonResult
  /// Returns `true` if `self` intersects the `dateInterval`.
  func intersects(_ dateInterval: DateInterval) -> Bool
  /// Returns a DateInterval that represents the interval where the given date interval and the current instance intersect.
  ///
  /// In the event that there is no intersection, the method returns nil.
  func intersection(with dateInterval: DateInterval) -> DateInterval?
  /// Returns `true` if `self` contains `date`.
  func contains(_ date: Date) -> Bool
  func hash(into hasher: inout Hasher)
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  static func == (lhs: DateInterval, rhs: DateInterval) -> Bool
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  static func < (lhs: DateInterval, rhs: DateInterval) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSDateInterval
  static func _forceBridgeFromObjectiveC(_ dateInterval: NSDateInterval, result: inout DateInterval?)
  static func _conditionallyBridgeFromObjectiveC(_ dateInterval: NSDateInterval, result: inout DateInterval?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSDateInterval?) -> DateInterval
  typealias _ObjectiveCType = NSDateInterval
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol DecodableAttributedStringKey : AttributedStringKey {
  static func decode(from decoder: Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension DecodableAttributedStringKey where Self.Value : Decodable {
  static func decode(from decoder: Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension DecodableAttributedStringKey where Self.Value : NSObject, Self.Value : NSSecureCoding {
  static func decode(from decoder: Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol DecodableWithConfiguration {
  associatedtype DecodingConfiguration
  init(from decoder: Decoder, configuration: Self.DecodingConfiguration) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol DecodingConfigurationProviding {
  associatedtype DecodingConfiguration
  static var decodingConfiguration: Self.DecodingConfiguration { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
enum DescriptiveNumberFormatConfiguration {
  typealias CapitalizationContext = FormatStyleCapitalizationContext
  struct Presentation : Codable, Hashable {
    static var spellOut: DescriptiveNumberFormatConfiguration.Presentation { get }
    static var ordinal: DescriptiveNumberFormatConfiguration.Presentation { get }
    func hash(into hasher: inout Hasher)
    static func == (a: DescriptiveNumberFormatConfiguration.Presentation, b: DescriptiveNumberFormatConfiguration.Presentation) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol EncodableAttributedStringKey : AttributedStringKey {
  static func encode(_ value: Self.Value, to encoder: Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension EncodableAttributedStringKey where Self.Value : Encodable {
  static func encode(_ value: Self.Value, to encoder: Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension EncodableAttributedStringKey where Self.Value : NSObject, Self.Value : NSSecureCoding {
  static func encode(_ value: Self.Value, to encoder: Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol EncodableWithConfiguration {
  associatedtype EncodingConfiguration
  func encode(to encoder: Encoder, configuration: Self.EncodingConfiguration) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol EncodingConfigurationProviding {
  associatedtype EncodingConfiguration
  static var encodingConfiguration: Self.EncodingConfiguration { get }
}

typealias ErrorPointer = NSErrorPointer

struct ErrorUserInfoKey : RawRepresentable, _SwiftNewtypeWrapper, Equatable, Hashable, _ObjectiveCBridgeable {
  typealias _ObjectiveCType = NSString
  init(rawValue: String)
  var rawValue: String
  typealias RawValue = String
}

extension ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  static let underlyingErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  static let localizedDescriptionKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  static let localizedFailureReasonErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  static let localizedRecoverySuggestionErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  static let localizedRecoveryOptionsErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  static let recoveryAttempterErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  static let helpAnchorErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  static let stringEncodingErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  static let NSURLErrorKey: ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  static let filePathErrorKey: ErrorUserInfoKey
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct FloatingPointFormatStyle<Value> : Codable, Hashable where Value : BinaryFloatingPoint {
  var locale: Locale
  init(locale: Locale = .autoupdatingCurrent)
  var attributed: FloatingPointFormatStyle<Value>.Attributed { get }
  typealias Configuration = NumberFormatStyleConfiguration
  func grouping(_ group: FloatingPointFormatStyle<Value>.Configuration.Grouping) -> FloatingPointFormatStyle<Value>
  func precision(_ p: FloatingPointFormatStyle<Value>.Configuration.Precision) -> FloatingPointFormatStyle<Value>
  func sign(strategy: FloatingPointFormatStyle<Value>.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>
  func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>
  func rounded(rule: FloatingPointFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>
  func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>
  func notation(_ notation: FloatingPointFormatStyle<Value>.Configuration.Notation) -> FloatingPointFormatStyle<Value>
  func hash(into hasher: inout Hasher)
  static func == (a: FloatingPointFormatStyle<Value>, b: FloatingPointFormatStyle<Value>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {
  struct Percent : Codable, Hashable {
    var locale: Locale
    init(locale: Locale = .autoupdatingCurrent)
    var attributed: FloatingPointFormatStyle<Value>.Attributed { get }
    typealias Configuration = NumberFormatStyleConfiguration
    func grouping(_ group: FloatingPointFormatStyle<Value>.Percent.Configuration.Grouping) -> FloatingPointFormatStyle<Value>.Percent
    func precision(_ p: FloatingPointFormatStyle<Value>.Percent.Configuration.Precision) -> FloatingPointFormatStyle<Value>.Percent
    func sign(strategy: FloatingPointFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>.Percent
    func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>.Percent
    func rounded(rule: FloatingPointFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>.Percent
    func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>.Percent
    func notation(_ notation: FloatingPointFormatStyle<Value>.Percent.Configuration.Notation) -> FloatingPointFormatStyle<Value>.Percent
    func hash(into hasher: inout Hasher)
    static func == (a: FloatingPointFormatStyle<Value>.Percent, b: FloatingPointFormatStyle<Value>.Percent) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct Currency : Codable, Hashable {
    var locale: Locale
    let currencyCode: String
    typealias Configuration = CurrencyFormatStyleConfiguration
    init(code: String, locale: Locale = .autoupdatingCurrent)
    var attributed: FloatingPointFormatStyle<Value>.Attributed { get }
    func grouping(_ group: FloatingPointFormatStyle<Value>.Currency.Configuration.Grouping) -> FloatingPointFormatStyle<Value>.Currency
    func precision(_ p: FloatingPointFormatStyle<Value>.Currency.Configuration.Precision) -> FloatingPointFormatStyle<Value>.Currency
    func sign(strategy: FloatingPointFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>.Currency
    func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>.Currency
    func rounded(rule: FloatingPointFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>.Currency
    func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>.Currency
    func presentation(_ p: FloatingPointFormatStyle<Value>.Currency.Configuration.Presentation) -> FloatingPointFormatStyle<Value>.Currency
    func hash(into hasher: inout Hasher)
    static func == (a: FloatingPointFormatStyle<Value>.Currency, b: FloatingPointFormatStyle<Value>.Currency) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle : FormatStyle {
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle : ParseableFormatStyle {
  var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>> { get }
  typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {
  struct Attributed : Codable, Hashable, FormatStyle {
    /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`.
    func format(_ value: Value) -> AttributedString
    func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Attributed
    func hash(into hasher: inout Hasher)
    static func == (a: FloatingPointFormatStyle<Value>.Attributed, b: FloatingPointFormatStyle<Value>.Attributed) -> Bool
    typealias FormatInput = Value
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent : FormatStyle {
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Percent
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent : ParseableFormatStyle {
  var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Percent> { get }
  typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Percent>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency : FormatStyle {
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Currency
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency : ParseableFormatStyle {
  var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Currency> { get }
  typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Currency>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct FloatingPointParseStrategy<Format> : Codable, Hashable where Format : FormatStyle, Format.FormatInput : BinaryFloatingPoint {
  var formatStyle: Format
  var lenient: Bool
  func hash(into hasher: inout Hasher)
  static func == (a: FloatingPointParseStrategy<Format>, b: FloatingPointParseStrategy<Format>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy : ParseStrategy {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  func parse(_ value: String) throws -> Format.FormatInput
  typealias ParseInput = String
  typealias ParseOutput = Format.FormatInput
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>.Currency, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>.Percent, Value : BinaryFloatingPoint
}

/// A type that can convert a given data type into a representation.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
protocol FormatStyle : Decodable, Encodable, Hashable {
  /// The type of data to format.
  associatedtype FormatInput
  /// The type of the formatted data.
  associatedtype FormatOutput
  /// Creates a `FormatOutput` instance from `value`.
  func format(_ value: Self.FormatInput) -> Self.FormatOutput
  /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
  func locale(_ locale: Locale) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.RelativeFormatStyle {
  static func relative(presentation: Date.RelativeFormatStyle.Presentation, unitsStyle: Date.RelativeFormatStyle.UnitsStyle = .wide) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  static func measurement<UnitType>(width: Measurement<UnitType>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil) -> Self where Self == Measurement<UnitType>.FormatStyle, UnitType : Dimension
  static func measurement(width: Measurement<UnitTemperature>.FormatStyle.UnitWidth = .abbreviated, usage: MeasurementFormatUnitUsage<UnitTemperature> = .general, hidesScaleName: Bool = false, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil) -> Self where Self == Measurement<UnitTemperature>.FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle {
  static var number: Decimal.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle.Percent {
  static var percent: Decimal.FormatStyle.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle.Currency {
  static func currency(code: String) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.FormatStyle {
  static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<Int> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int16> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<Int16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int32> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<Int32> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int64> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<Int64> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int8> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<Int8> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<UInt> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt16> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<UInt16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt32> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<UInt32> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt64> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<UInt64> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt8> {
  @_alwaysEmitIntoClient static var number: IntegerFormatStyle<UInt8> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<Int>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int16>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<Int16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int32>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<Int32>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int64>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<Int64>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int8>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<Int8>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<UInt>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt16>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<UInt16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt32>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<UInt32>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt64>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<UInt64>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt8>.Percent {
  @_alwaysEmitIntoClient static var percent: IntegerFormatStyle<UInt8>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  static func currency<V>(code: String) -> Self where Self == IntegerFormatStyle<V>.Currency, V : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == PersonNameComponents.FormatStyle {
  static func name(style: PersonNameComponents.FormatStyle.Style) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.IntervalFormatStyle {
  static var interval: Date.IntervalFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.ComponentsFormatStyle {
  static func components(style: Date.ComponentsFormatStyle.Style, fields: Set<Date.ComponentsFormatStyle.Field>? = nil) -> Self
  /// A pre-defined style for showing an interval using combinations of time fields: hours, minutes, and seconds.
  /// Units may be omitted if they are not needed to represent the time interval.
  /// For example, "02:10:03".
  static var timeDuration: Date.ComponentsFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Double> {
  @_alwaysEmitIntoClient static var number: FloatingPointFormatStyle<Double> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float> {
  @_alwaysEmitIntoClient static var number: FloatingPointFormatStyle<Float> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Double>.Percent {
  @_alwaysEmitIntoClient static var percent: FloatingPointFormatStyle<Double>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float>.Percent {
  @_alwaysEmitIntoClient static var percent: FloatingPointFormatStyle<Float>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  @_alwaysEmitIntoClient static func currency<Value>(code: String) -> Self where Self == FloatingPointFormatStyle<Value>.Currency, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float16> {
  @_alwaysEmitIntoClient static var number: FloatingPointFormatStyle<Float16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float16>.Percent {
  @_alwaysEmitIntoClient static var percent: FloatingPointFormatStyle<Float16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  static func list<MemberStyle, Base>(memberStyle: MemberStyle, type: ListFormatStyle<MemberStyle, Base>.ListType, width: ListFormatStyle<MemberStyle, Base>.Width = .standard) -> Self where Self == ListFormatStyle<MemberStyle, Base>, MemberStyle : FormatStyle, Base : Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  static func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType, width: ListFormatStyle<StringStyle, Base>.Width = .standard) -> Self where Self == ListFormatStyle<StringStyle, Base>, Base : Sequence, Base.Element == String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {
  func locale(_ locale: Locale) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == ByteCountFormatStyle {
  static func byteCount(style: ByteCountFormatStyle.Style, allowedUnits: ByteCountFormatStyle.Units = .all, spellsOutZero: Bool = true, includesActualByteCount: Bool = false) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.ISO8601FormatStyle {
  static var iso8601: Date.ISO8601FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct FormatStyleCapitalizationContext : Codable, Hashable {
  static var unknown: FormatStyleCapitalizationContext { get }
  /// For stand-alone usage, such as an isolated name on a calendar page.
  static var standalone: FormatStyleCapitalizationContext { get }
  /// For use in a UI list or menu item.
  static var listItem: FormatStyleCapitalizationContext { get }
  static var beginningOfSentence: FormatStyleCapitalizationContext { get }
  static var middleOfSentence: FormatStyleCapitalizationContext { get }
  func hash(into hasher: inout Hasher)
  static func == (a: FormatStyleCapitalizationContext, b: FormatStyleCapitalizationContext) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

/**
 `IndexPath` represents the path to a specific node in a tree of nested array collections.
 
 Each index in an index path represents the index into an array of children from one node in the tree to another, deeper, node.
 */
struct IndexPath : ReferenceConvertible, Equatable, Hashable, MutableCollection, RandomAccessCollection, Comparable, ExpressibleByArrayLiteral {
  typealias ReferenceType = NSIndexPath
  typealias Element = Int
  typealias Index = Array<Int>.Index
  typealias Indices = DefaultIndices<IndexPath>
  /// Initialize an empty index path.
  init()
  /// Initialize with a sequence of integers.
  init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Sequence, ElementSequence.Element == Int
  /// Initialize with an array literal.
  init(arrayLiteral indexes: IndexPath.Element...)
  /// Initialize with an array of elements.
  init(indexes: Array<IndexPath.Element>)
  /// Initialize with a single element.
  init(index: IndexPath.Element)
  /// Return a new `IndexPath` containing all but the last element.
  func dropLast() -> IndexPath
  /// Append an `IndexPath` to `self`.
  mutating func append(_ other: IndexPath)
  /// Append a single element to `self`.
  mutating func append(_ other: IndexPath.Element)
  /// Append an array of elements to `self`.
  mutating func append(_ other: Array<IndexPath.Element>)
  /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
  func appending(_ other: IndexPath.Element) -> IndexPath
  /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
  func appending(_ other: IndexPath) -> IndexPath
  /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
  func appending(_ other: Array<IndexPath.Element>) -> IndexPath
  subscript(index: IndexPath.Index) -> IndexPath.Element
  subscript(range: Range<IndexPath.Index>) -> IndexPath
  func makeIterator() -> IndexingIterator<IndexPath>
  var count: Int { get }
  var startIndex: IndexPath.Index { get }
  var endIndex: IndexPath.Index { get }
  func index(before i: IndexPath.Index) -> IndexPath.Index
  func index(after i: IndexPath.Index) -> IndexPath.Index
  /// Sorting an array of `IndexPath` using this comparison results in an array representing nodes in depth-first traversal order.
  func compare(_ other: IndexPath) -> ComparisonResult
  func hash(into hasher: inout Hasher)
  static func == (lhs: IndexPath, rhs: IndexPath) -> Bool
  static func + (lhs: IndexPath, rhs: IndexPath) -> IndexPath
  static func += (lhs: inout IndexPath, rhs: IndexPath)
  static func < (lhs: IndexPath, rhs: IndexPath) -> Bool
  static func <= (lhs: IndexPath, rhs: IndexPath) -> Bool
  static func > (lhs: IndexPath, rhs: IndexPath) -> Bool
  static func >= (lhs: IndexPath, rhs: IndexPath) -> Bool
  typealias ArrayLiteralElement = IndexPath.Element
  typealias Iterator = IndexingIterator<IndexPath>
  typealias SubSequence = IndexPath
  var hashValue: Int { get }
}

extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension IndexPath : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSIndexPath
  static func _forceBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSIndexPath?) -> IndexPath
  typealias _ObjectiveCType = NSIndexPath
}

extension IndexPath : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/// Manages a `Set` of integer values, which are commonly used as an index type in Cocoa API.
///
/// The range of valid integer values is 0..<INT_MAX-1. Anything outside this range is an error.
struct IndexSet : ReferenceConvertible, Equatable, BidirectionalCollection, SetAlgebra {
  /// An view of the contents of an IndexSet, organized by range.
  ///
  /// For example, if an IndexSet is composed of:
  ///  `[1..<5]` and `[7..<10]` and `[13]`
  /// then calling `next()` on this view's iterator will produce 3 ranges before returning nil.
  struct RangeView : Equatable, BidirectionalCollection {
    typealias Index = Int
    let startIndex: IndexSet.RangeView.Index
    let endIndex: IndexSet.RangeView.Index
    func makeIterator() -> IndexingIterator<IndexSet.RangeView>
    subscript(index: IndexSet.RangeView.Index) -> Range<IndexSet.Element> { get }
    subscript(bounds: Range<IndexSet.RangeView.Index>) -> Slice<IndexSet.RangeView> { get }
    func index(after i: IndexSet.RangeView.Index) -> IndexSet.RangeView.Index
    func index(before i: IndexSet.RangeView.Index) -> IndexSet.RangeView.Index
    typealias Element = Range<IndexSet.Element>
    typealias Indices = DefaultIndices<IndexSet.RangeView>
    typealias Iterator = IndexingIterator<IndexSet.RangeView>
    typealias SubSequence = Slice<IndexSet.RangeView>
  }
  /// The mechanism for accessing the integers stored in an IndexSet.
  struct Index : CustomStringConvertible, Comparable {
    var description: String { get }
  }
  typealias ReferenceType = NSIndexSet
  typealias Element = Int
  /// Initialize an `IndexSet` with a range of integers.
  init(integersIn range: Range<IndexSet.Element>)
  /// Initialize an `IndexSet` with a range of integers.
  init<R>(integersIn range: R) where R : RangeExpression, R.Bound == Int
  /// Initialize an `IndexSet` with a single integer.
  init(integer: IndexSet.Element)
  /// Initialize an empty `IndexSet`.
  init()
  func hash(into hasher: inout Hasher)
  /// Returns the number of integers in `self`.
  var count: Int { get }
  func makeIterator() -> IndexingIterator<IndexSet>
  /// Returns a `Range`-based view of the entire contents of `self`.
  ///
  /// - seealso: rangeView(of:)
  var rangeView: IndexSet.RangeView { get }
  /// Returns a `Range`-based view of `self`.
  ///
  /// - parameter range: A subrange of `self` to view.
  func rangeView(of range: Range<IndexSet.Element>) -> IndexSet.RangeView
  /// Returns a `Range`-based view of `self`.
  ///
  /// - parameter range: A subrange of `self` to view.
  func rangeView<R>(of range: R) -> IndexSet.RangeView where R : RangeExpression, R.Bound == Int
  var startIndex: IndexSet.Index { get }
  var endIndex: IndexSet.Index { get }
  subscript(index: IndexSet.Index) -> IndexSet.Element { get }
  subscript(bounds: Range<IndexSet.Index>) -> Slice<IndexSet> { get }
  /// Returns the first integer in `self`, or nil if `self` is empty.
  var first: IndexSet.Element? { get }
  /// Returns the last integer in `self`, or nil if `self` is empty.
  var last: IndexSet.Element? { get }
  /// Returns an integer contained in `self` which is greater than `integer`, or `nil` if a result could not be found.
  func integerGreaterThan(_ integer: IndexSet.Element) -> IndexSet.Element?
  /// Returns an integer contained in `self` which is less than `integer`, or `nil` if a result could not be found.
  func integerLessThan(_ integer: IndexSet.Element) -> IndexSet.Element?
  /// Returns an integer contained in `self` which is greater than or equal to `integer`, or `nil` if a result could not be found.
  func integerGreaterThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?
  /// Returns an integer contained in `self` which is less than or equal to `integer`, or `nil` if a result could not be found.
  func integerLessThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?
  /// Return a `Range<IndexSet.Index>` which can be used to subscript the index set.
  ///
  /// The resulting range is the range of the intersection of the integers in `range` with the index set. The resulting range will be `isEmpty` if the intersection is empty.
  ///
  /// - parameter range: The range of integers to include.
  func indexRange(in range: Range<IndexSet.Element>) -> Range<IndexSet.Index>
  /// Return a `Range<IndexSet.Index>` which can be used to subscript the index set.
  ///
  /// The resulting range is the range of the intersection of the integers in `range` with the index set.
  ///
  /// - parameter range: The range of integers to include.
  func indexRange<R>(in range: R) -> Range<IndexSet.Index> where R : RangeExpression, R.Bound == Int
  /// Returns the count of integers in `self` that intersect `range`.
  func count(in range: Range<IndexSet.Element>) -> Int
  /// Returns the count of integers in `self` that intersect `range`.
  func count<R>(in range: R) -> Int where R : RangeExpression, R.Bound == Int
  /// Returns `true` if `self` contains `integer`.
  func contains(_ integer: IndexSet.Element) -> Bool
  /// Returns `true` if `self` contains all of the integers in `range`.
  func contains(integersIn range: Range<IndexSet.Element>) -> Bool
  /// Returns `true` if `self` contains all of the integers in `range`.
  func contains<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == Int
  /// Returns `true` if `self` contains all of the integers in `indexSet`.
  func contains(integersIn indexSet: IndexSet) -> Bool
  /// Returns `true` if `self` intersects any of the integers in `range`.
  func intersects(integersIn range: Range<IndexSet.Element>) -> Bool
  /// Returns `true` if `self` intersects any of the integers in `range`.
  func intersects<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == Int
  func index(after i: IndexSet.Index) -> IndexSet.Index
  func formIndex(after i: inout IndexSet.Index)
  func index(before i: IndexSet.Index) -> IndexSet.Index
  func formIndex(before i: inout IndexSet.Index)
  /// Union the `IndexSet` with `other`.
  mutating func formUnion(_ other: IndexSet)
  /// Union the `IndexSet` with `other`.
  func union(_ other: IndexSet) -> IndexSet
  /// Exclusive or the `IndexSet` with `other`.
  func symmetricDifference(_ other: IndexSet) -> IndexSet
  /// Exclusive or the `IndexSet` with `other`.
  mutating func formSymmetricDifference(_ other: IndexSet)
  /// Intersect the `IndexSet` with `other`.
  func intersection(_ other: IndexSet) -> IndexSet
  /// Intersect the `IndexSet` with `other`.
  mutating func formIntersection(_ other: IndexSet)
  /// Insert an integer into the `IndexSet`.
  @discardableResult
  mutating func insert(_ integer: IndexSet.Element) -> (inserted: Bool, memberAfterInsert: IndexSet.Element)
  /// Insert an integer into the `IndexSet`.
  @discardableResult
  mutating func update(with integer: IndexSet.Element) -> IndexSet.Element?
  /// Remove an integer from the `IndexSet`.
  @discardableResult
  mutating func remove(_ integer: IndexSet.Element) -> IndexSet.Element?
  /// Remove all values from the `IndexSet`.
  mutating func removeAll()
  /// Insert a range of integers into the `IndexSet`.
  mutating func insert(integersIn range: Range<IndexSet.Element>)
  /// Insert a range of integers into the `IndexSet`.
  mutating func insert<R>(integersIn range: R) where R : RangeExpression, R.Bound == Int
  /// Remove a range of integers from the `IndexSet`.
  mutating func remove(integersIn range: Range<IndexSet.Element>)
  /// Remove a range of integers from the `IndexSet`.
  mutating func remove(integersIn range: ClosedRange<IndexSet.Element>)
  /// Returns `true` if self contains no values.
  var isEmpty: Bool { get }
  /// Returns an IndexSet filtered according to the result of `includeInteger`.
  ///
  /// - parameter range: A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the `includeInteger` predicate will be invoked.
  /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
  func filteredIndexSet(in range: Range<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet
  /// Returns an IndexSet filtered according to the result of `includeInteger`.
  ///
  /// - parameter range: A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the `includeInteger` predicate will be invoked.
  /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
  func filteredIndexSet(in range: ClosedRange<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet
  /// Returns an IndexSet filtered according to the result of `includeInteger`.
  ///
  /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
  func filteredIndexSet(includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet
  /// For a positive delta, shifts the indexes in [index, INT_MAX] to the right, thereby inserting an "empty space" [index, delta], for a negative delta, shifts the indexes in [index, INT_MAX] to the left, thereby deleting the indexes in the range [index - delta, delta].
  mutating func shift(startingAt integer: IndexSet.Element, by delta: Int)
  typealias ArrayLiteralElement = IndexSet.Element
  typealias Indices = DefaultIndices<IndexSet>
  typealias Iterator = IndexingIterator<IndexSet>
  typealias SubSequence = Slice<IndexSet>
  var hashValue: Int { get }
}

extension IndexSet : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension IndexSet {
  static func == (lhs: IndexSet, rhs: IndexSet) -> Bool
}

extension IndexSet : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSIndexSet
  static func _forceBridgeFromObjectiveC(_ x: NSIndexSet, result: inout IndexSet?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSIndexSet, result: inout IndexSet?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSIndexSet?) -> IndexSet
  typealias _ObjectiveCType = NSIndexSet
}

extension IndexSet : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension IndexSet.RangeView {
  static func == (lhs: IndexSet.RangeView, rhs: IndexSet.RangeView) -> Bool
}

extension IndexSet.Index {
  static func == (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  static func < (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  static func <= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  static func > (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  static func >= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
enum InflectionRule {
  case automatic
  case explicit(Morphology)
  init(morphology: Morphology)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule : Hashable {
  func hash(into hasher: inout Hasher)
  static func == (a: InflectionRule, b: InflectionRule) -> Bool
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule {
  static func canInflect(language: String) -> Bool
  static var canInflectPreferredLocalization: Bool { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __NSInflectionRule
  static func _forceBridgeFromObjectiveC(_ rule: __NSInflectionRule, result: inout InflectionRule?)
  static func _conditionallyBridgeFromObjectiveC(_ rule: __NSInflectionRule, result: inout InflectionRule?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ rule: __NSInflectionRule?) -> InflectionRule
  typealias _ObjectiveCType = __NSInflectionRule
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct IntegerFormatStyle<Value> : Codable, Hashable where Value : BinaryInteger {
  var locale: Locale
  init(locale: Locale = .autoupdatingCurrent)
  var attributed: IntegerFormatStyle<Value>.Attributed { get }
  typealias Configuration = NumberFormatStyleConfiguration
  func grouping(_ group: IntegerFormatStyle<Value>.Configuration.Grouping) -> IntegerFormatStyle<Value>
  func precision(_ p: IntegerFormatStyle<Value>.Configuration.Precision) -> IntegerFormatStyle<Value>
  func sign(strategy: IntegerFormatStyle<Value>.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>
  func decimalSeparator(strategy: IntegerFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>
  func rounded(rule: IntegerFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>
  func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>
  func notation(_ notation: IntegerFormatStyle<Value>.Configuration.Notation) -> IntegerFormatStyle<Value>
  func hash(into hasher: inout Hasher)
  static func == (a: IntegerFormatStyle<Value>, b: IntegerFormatStyle<Value>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle {
  struct Percent : Codable, Hashable {
    var locale: Locale
    init(locale: Locale = .autoupdatingCurrent)
    var attributed: IntegerFormatStyle<Value>.Attributed { get }
    typealias Configuration = NumberFormatStyleConfiguration
    func grouping(_ group: IntegerFormatStyle<Value>.Percent.Configuration.Grouping) -> IntegerFormatStyle<Value>.Percent
    func precision(_ p: IntegerFormatStyle<Value>.Percent.Configuration.Precision) -> IntegerFormatStyle<Value>.Percent
    func sign(strategy: IntegerFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>.Percent
    func decimalSeparator(strategy: IntegerFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>.Percent
    func rounded(rule: IntegerFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>.Percent
    func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>.Percent
    func notation(_ notation: IntegerFormatStyle<Value>.Percent.Configuration.Notation) -> IntegerFormatStyle<Value>.Percent
    func hash(into hasher: inout Hasher)
    static func == (a: IntegerFormatStyle<Value>.Percent, b: IntegerFormatStyle<Value>.Percent) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct Currency : Codable, Hashable {
    typealias Configuration = CurrencyFormatStyleConfiguration
    var locale: Locale
    let currencyCode: String
    init(code: String, locale: Locale = .autoupdatingCurrent)
    var attributed: IntegerFormatStyle<Value>.Attributed { get }
    func grouping(_ group: IntegerFormatStyle<Value>.Currency.Configuration.Grouping) -> IntegerFormatStyle<Value>.Currency
    func precision(_ p: IntegerFormatStyle<Value>.Currency.Configuration.Precision) -> IntegerFormatStyle<Value>.Currency
    func sign(strategy: IntegerFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>.Currency
    func decimalSeparator(strategy: IntegerFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>.Currency
    func rounded(rule: IntegerFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>.Currency
    func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>.Currency
    func presentation(_ p: IntegerFormatStyle<Value>.Currency.Configuration.Presentation) -> IntegerFormatStyle<Value>.Currency
    func hash(into hasher: inout Hasher)
    static func == (a: IntegerFormatStyle<Value>.Currency, b: IntegerFormatStyle<Value>.Currency) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle : FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> IntegerFormatStyle<Value>
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle : ParseableFormatStyle {
  var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>> { get }
  typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle {
  struct Attributed : Codable, Hashable, FormatStyle {
    /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`.
    func format(_ value: Value) -> AttributedString
    func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Attributed
    func hash(into hasher: inout Hasher)
    static func == (a: IntegerFormatStyle<Value>.Attributed, b: IntegerFormatStyle<Value>.Attributed) -> Bool
    typealias FormatInput = Value
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Percent : FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Percent
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Percent : ParseableFormatStyle {
  var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>.Percent> { get }
  typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>.Percent>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Currency : FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  func format(_ value: Value) -> String
  func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Currency
  typealias FormatInput = Value
  typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Currency : ParseableFormatStyle {
  var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>.Currency> { get }
  typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>.Currency>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct IntegerParseStrategy<Format> : Codable, Hashable where Format : FormatStyle, Format.FormatInput : BinaryInteger {
  var formatStyle: Format
  var lenient: Bool
  func hash(into hasher: inout Hasher)
  static func == (a: IntegerParseStrategy<Format>, b: IntegerParseStrategy<Format>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy : ParseStrategy {
  func parse(_ value: String) throws -> Format.FormatInput
  typealias ParseInput = String
  typealias ParseOutput = Format.FormatInput
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>, Value : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>.Percent, Value : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {
  init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>.Currency, Value : BinaryInteger
}

class JSONDecoder {
  /// The strategy to use for decoding `Date` values.
  enum DateDecodingStrategy {
    /// Defer to `Date` for decoding. This is the default strategy.
    case deferredToDate
    /// Decode the `Date` as a UNIX timestamp from a JSON number.
    case secondsSince1970
    /// Decode the `Date` as UNIX millisecond timestamp from a JSON number.
    case millisecondsSince1970
    /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    /// Decode the `Date` as a string parsed by the given formatter.
    case formatted(DateFormatter)
    /// Decode the `Date` as a custom value decoded by the given closure.
    case custom((_ decoder: Decoder) throws -> Date)
  }
  /// The strategy to use for decoding `Data` values.
  enum DataDecodingStrategy {
    /// Defer to `Data` for decoding.
    case deferredToData
    /// Decode the `Data` from a Base64-encoded string. This is the default strategy.
    case base64
    /// Decode the `Data` as a custom value decoded by the given closure.
    case custom((_ decoder: Decoder) throws -> Data)
  }
  /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
  enum NonConformingFloatDecodingStrategy {
    /// Throw upon encountering non-conforming values. This is the default strategy.
    case `throw`
    /// Decode the values from the given representation strings.
    case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String)
  }
  /// The strategy to use for automatically changing the value of keys before decoding.
  enum KeyDecodingStrategy {
    /// Use the keys specified by each type. This is the default strategy.
    case useDefaultKeys
    /// Convert from "snake_case_keys" to "camelCaseKeys" before attempting to match a key with the one specified by each type.
    /// 
    /// The conversion to upper case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
    ///
    /// Converting from snake case to camel case:
    /// 1. Capitalizes the word starting after each `_`
    /// 2. Removes all `_`
    /// 3. Preserves starting and ending `_` (as these are often used to indicate private variables or other metadata).
    /// For example, `one_two_three` becomes `oneTwoThree`. `_one_two_three_` becomes `_oneTwoThree_`.
    ///
    /// - Note: Using a key decoding strategy has a nominal performance cost, as each string key has to be inspected for the `_` character.
    case convertFromSnakeCase
    /// Provide a custom conversion from the key in the encoded JSON to the keys specified by the decoded types.
    /// The full path to the current decoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before decoding.
    /// If the result of the conversion is a duplicate key, then only one value will be present in the container for the type to decode from.
    case custom((_ codingPath: [CodingKey]) -> CodingKey)
  }
  /// The strategy to use in decoding dates. Defaults to `.deferredToDate`.
  var dateDecodingStrategy: JSONDecoder.DateDecodingStrategy
  /// The strategy to use in decoding binary data. Defaults to `.base64`.
  var dataDecodingStrategy: JSONDecoder.DataDecodingStrategy
  /// The strategy to use in decoding non-conforming numbers. Defaults to `.throw`.
  var nonConformingFloatDecodingStrategy: JSONDecoder.NonConformingFloatDecodingStrategy
  /// The strategy to use for decoding keys. Defaults to `.useDefaultKeys`.
  var keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy
  /// Contextual user-provided information for use during decoding.
  var userInfo: [CodingUserInfoKey : Any]
  /// Set to `true` to allow parsing of JSON5. Defaults to `false`.
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var allowsJSON5: Bool
  /// Set to `true` to assume the data is a top level Dictionary (no surrounding "{ }" required). Defaults to `false`. Compatible with both JSON5 and non-JSON5 mode.
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var assumesTopLevelDictionary: Bool
  /// Initializes `self` with default strategies.
  init()
  /// Decodes a top-level value of the given type from the given JSON representation.
  ///
  /// - parameter type: The type of the value to decode.
  /// - parameter data: The data to decode from.
  /// - returns: A value of the requested type.
  /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not valid JSON.
  /// - throws: An error if any value throws an error during decoding.
  func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Decodable
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONDecoder : TopLevelDecoder {
  typealias Input = Data
}

class JSONEncoder {
  /// The formatting of the output JSON data.
  struct OutputFormatting : OptionSet {
    /// The format's default value.
    let rawValue: UInt
    /// Creates an OutputFormatting value with the given raw value.
    init(rawValue: UInt)
    /// Produce human-readable JSON with indented output.
    static let prettyPrinted: JSONEncoder.OutputFormatting
    /// Produce JSON with dictionary keys sorted in lexicographic order.
    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    static let sortedKeys: JSONEncoder.OutputFormatting
    /// By default slashes get escaped ("/" → "\/", "http://apple.com/" → "http:\/\/apple.com\/")
    /// for security reasons, allowing outputted JSON to be safely embedded within HTML/XML.
    /// In contexts where this escaping is unnecessary, the JSON is known to not be embedded,
    /// or is intended only for display, this option avoids this escaping.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    static let withoutEscapingSlashes: JSONEncoder.OutputFormatting
    typealias ArrayLiteralElement = JSONEncoder.OutputFormatting
    typealias Element = JSONEncoder.OutputFormatting
    typealias RawValue = UInt
  }
  /// The strategy to use for encoding `Date` values.
  enum DateEncodingStrategy {
    /// Defer to `Date` for choosing an encoding. This is the default strategy.
    case deferredToDate
    /// Encode the `Date` as a UNIX timestamp (as a JSON number).
    case secondsSince1970
    /// Encode the `Date` as UNIX millisecond timestamp (as a JSON number).
    case millisecondsSince1970
    /// Encode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    /// Encode the `Date` as a string formatted by the given formatter.
    case formatted(DateFormatter)
    /// Encode the `Date` as a custom value encoded by the given closure.
    ///
    /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
    case custom((Date, Encoder) throws -> Void)
  }
  /// The strategy to use for encoding `Data` values.
  enum DataEncodingStrategy {
    /// Defer to `Data` for choosing an encoding.
    case deferredToData
    /// Encoded the `Data` as a Base64-encoded string. This is the default strategy.
    case base64
    /// Encode the `Data` as a custom value encoded by the given closure.
    ///
    /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
    case custom((Data, Encoder) throws -> Void)
  }
  /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
  enum NonConformingFloatEncodingStrategy {
    /// Throw upon encountering non-conforming values. This is the default strategy.
    case `throw`
    /// Encode the values using the given representation strings.
    case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String)
  }
  /// The strategy to use for automatically changing the value of keys before encoding.
  enum KeyEncodingStrategy {
    /// Use the keys specified by each type. This is the default strategy.
    case useDefaultKeys
    /// Convert from "camelCaseKeys" to "snake_case_keys" before writing a key to JSON payload.
    ///
    /// Capital characters are determined by testing membership in `CharacterSet.uppercaseLetters` and `CharacterSet.lowercaseLetters` (Unicode General Categories Lu and Lt).
    /// The conversion to lower case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
    ///
    /// Converting from camel case to snake case:
    /// 1. Splits words at the boundary of lower-case to upper-case
    /// 2. Inserts `_` between words
    /// 3. Lowercases the entire string
    /// 4. Preserves starting and ending `_`.
    ///
    /// For example, `oneTwoThree` becomes `one_two_three`. `_oneTwoThree_` becomes `_one_two_three_`.
    ///
    /// - Note: Using a key encoding strategy has a nominal performance cost, as each string key has to be converted.
    case convertToSnakeCase
    /// Provide a custom conversion to the key in the encoded JSON from the keys specified by the encoded types.
    /// The full path to the current encoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before encoding.
    /// If the result of the conversion is a duplicate key, then only one value will be present in the result.
    case custom((_ codingPath: [CodingKey]) -> CodingKey)
  }
  /// The output format to produce. Defaults to `[]`.
  var outputFormatting: JSONEncoder.OutputFormatting
  /// The strategy to use in encoding dates. Defaults to `.deferredToDate`.
  var dateEncodingStrategy: JSONEncoder.DateEncodingStrategy
  /// The strategy to use in encoding binary data. Defaults to `.base64`.
  var dataEncodingStrategy: JSONEncoder.DataEncodingStrategy
  /// The strategy to use in encoding non-conforming numbers. Defaults to `.throw`.
  var nonConformingFloatEncodingStrategy: JSONEncoder.NonConformingFloatEncodingStrategy
  /// The strategy to use for encoding keys. Defaults to `.useDefaultKeys`.
  var keyEncodingStrategy: JSONEncoder.KeyEncodingStrategy
  /// Contextual user-provided information for use during encoding.
  var userInfo: [CodingUserInfoKey : Any]
  /// Initializes `self` with default strategies.
  init()
  /// Encodes the given top-level value and returns its JSON representation.
  ///
  /// - parameter value: The value to encode.
  /// - returns: A new `Data` value containing the encoded JSON data.
  /// - throws: `EncodingError.invalidValue` if a non-conforming floating-point value is encountered during encoding, and the encoding strategy is `.throw`.
  /// - throws: An error if any value throws an error during encoding.
  func encode<T>(_ value: T) throws -> Data where T : Encodable
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONEncoder : TopLevelEncoder {
  typealias Output = Data
}

/// Compares elements using a `KeyPath`, and a `SortComparator` which compares
/// elements of the `KeyPath`s `Value` type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
struct KeyPathComparator<Compared> : SortComparator {
  /// The key path to the property to be used for comparisons.
  let keyPath: PartialKeyPath<Compared>
  var order: SortOrder
  /// Creates a `KeyPathComparator` that orders values based on a property
  /// that conforms to the `Comparable` protocol.
  ///
  /// The underlying field comparison uses `ComparableComparator<Value>()`
  /// unless the keyPath points to a `String` in which case the default string
  /// comparator, `String.StandardComparator.localizedStandard`, will be used.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init<Value>(_ keyPath: KeyPath<Compared, Value>, order: SortOrder = .forward) where Value : Comparable
  /// Creates a `KeyPathComparator` that orders values based on an optional
  /// property whose wrapped value conforms to the `Comparable` protocol.
  ///
  /// The resulting `KeyPathComparator` orders `nil` values first when in
  /// `forward` order.
  ///
  /// The underlying field comparison uses `ComparableComparator<Value>()`
  /// unless the keyPath points to a `String` in which case the default string
  /// comparator, `String.StandardComparator.localizedStandard`, will be used.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init<Value>(_ keyPath: KeyPath<Compared, Value?>, order: SortOrder = .forward) where Value : Comparable
  /// Creates a `KeyPathComparator` with the given `keyPath` and
  /// `SortComparator`.
  ///
  /// `comparator.order` is used for the initial `order` of the created
  /// `KeyPathComparator`.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the value used for the comparison.
  ///   - comparator: The `SortComparator` used to order values.
  init<Value, Comparator>(_ keyPath: KeyPath<Compared, Value>, comparator: Comparator) where Value == Comparator.Compared, Comparator : SortComparator
  /// Creates a `KeyPathComparator` with the given `keyPath` to an optional
  /// value and `SortComparator`.
  ///
  /// The resulting `KeyPathComparator` orders `nil` values first when in
  /// `forward` order.
  ///
  /// `comparator.order` is used for the initial `order` of the created
  /// `KeyPathComparator`.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the value used for the comparison.
  ///   - comparator: The `SortComparator` used to order values.
  init<Value, Comparator>(_ keyPath: KeyPath<Compared, Value?>, comparator: Comparator) where Value == Comparator.Compared, Comparator : SortComparator
  /// Creates a `KeyPathComparator` with the given `keyPath`,
  /// `SortComparator`, and initial order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the value used for the comparison.
  ///   - comparator: The `SortComparator` used to order values.
  ///   - order: The initial order to use for comparison.
  init<Value, Comparator>(_ keyPath: KeyPath<Compared, Value>, comparator: Comparator, order: SortOrder) where Value == Comparator.Compared, Comparator : SortComparator
  /// Creates a `KeyPathComparator` with the given `keyPath`,
  /// `SortComparator`, and initial order.
  ///
  ///  The resulting `KeyPathComparator` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the value used for the comparison.
  ///   - comparator: The `SortComparator` used to order values.
  ///   - order: The initial order to use for comparison.
  init<Value, Comparator>(_ keyPath: KeyPath<Compared, Value?>, comparator: Comparator, order: SortOrder) where Value == Comparator.Compared, Comparator : SortComparator
  func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult
  static func == (lhs: KeyPathComparator<Compared>, rhs: KeyPathComparator<Compared>) -> Bool
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
  typealias Compared = Compared
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct ListFormatStyle<Style, Base> : FormatStyle where Style : FormatStyle, Base : Sequence, Style.FormatInput == Base.Element, Style.FormatOutput == String {
  var width: ListFormatStyle<Style, Base>.Width
  var listType: ListFormatStyle<Style, Base>.ListType
  var locale: Locale
  init(memberStyle: Style)
  func format(_ value: Base) -> String
  enum Width : Int, Codable {
    case standard
    case short
    case narrow
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  enum ListType : Int, Codable {
    case and
    case or
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  func locale(_ locale: Locale) -> ListFormatStyle<Style, Base>
  func hash(into hasher: inout Hasher)
  static func == (a: ListFormatStyle<Style, Base>, b: ListFormatStyle<Style, Base>) -> Bool
  typealias FormatInput = Base
  typealias FormatOutput = String
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : RawRepresentable {
}

/**
 `Locale` encapsulates information about linguistic, cultural, and technological conventions and standards. Examples of information encapsulated by a locale include the symbol used for the decimal separator in numbers and the way dates are formatted.
 
 Locales are typically used to provide, format, and interpret information about and according to the user's customs and preferences. They are frequently used in conjunction with formatters. Although you can use many locales, you usually use the one associated with the current user.
*/
struct Locale : Hashable, Equatable, ReferenceConvertible {
  typealias ReferenceType = NSLocale
  typealias LanguageDirection = NSLocale.LanguageDirection
  /// Returns a locale which tracks the user's current preferences.
  ///
  /// If mutated, this Locale will no longer track the user's preferences.
  ///
  /// - note: The autoupdating Locale will only compare equal to another autoupdating Locale.
  static var autoupdatingCurrent: Locale { get }
  /// Returns the user's current locale.
  static var current: Locale { get }
  @available(*, unavailable, message: "Consider using the user's locale or nil instead, depending on use case")
  static var system: Locale { get }
  /// Return a locale with the specified identifier.
  init(identifier: String)
  /// Returns a localized string for a specified identifier.
  ///
  /// For example, in the "en" locale, the result for `"es"` is `"Spanish"`.
  func localizedString(forIdentifier identifier: String) -> String?
  /// Returns a localized string for a specified language code.
  ///
  /// For example, in the "en" locale, the result for `"es"` is `"Spanish"`.
  func localizedString(forLanguageCode languageCode: String) -> String?
  /// Returns a localized string for a specified region code.
  ///
  /// For example, in the "en" locale, the result for `"fr"` is `"France"`.
  func localizedString(forRegionCode regionCode: String) -> String?
  /// Returns a localized string for a specified script code.
  ///
  /// For example, in the "en" locale, the result for `"Hans"` is `"Simplified Han"`.
  func localizedString(forScriptCode scriptCode: String) -> String?
  /// Returns a localized string for a specified variant code.
  ///
  /// For example, in the "en" locale, the result for `"POSIX"` is `"Computer"`.
  func localizedString(forVariantCode variantCode: String) -> String?
  /// Returns a localized string for a specified `Calendar.Identifier`.
  ///
  /// For example, in the "en" locale, the result for `.buddhist` is `"Buddhist Calendar"`.
  func localizedString(for calendarIdentifier: Calendar.Identifier) -> String?
  /// Returns a localized string for a specified ISO 4217 currency code.
  ///
  /// For example, in the "en" locale, the result for `"USD"` is `"US Dollar"`.
  /// - seealso: `Locale.isoCurrencyCodes`
  func localizedString(forCurrencyCode currencyCode: String) -> String?
  /// Returns a localized string for a specified ICU collation identifier.
  ///
  /// For example, in the "en" locale, the result for `"phonebook"` is `"Phonebook Sort Order"`.
  func localizedString(forCollationIdentifier collationIdentifier: String) -> String?
  /// Returns a localized string for a specified ICU collator identifier.
  func localizedString(forCollatorIdentifier collatorIdentifier: String) -> String?
  /// Returns the identifier of the locale.
  var identifier: String { get }
  /// Returns the language code of the locale, or nil if has none.
  ///
  /// For example, for the locale "zh-Hant-HK", returns "zh".
  var languageCode: String? { get }
  /// Returns the region code of the locale, or nil if it has none.
  ///
  /// For example, for the locale "zh-Hant-HK", returns "HK".
  var regionCode: String? { get }
  /// Returns the script code of the locale, or nil if has none.
  ///
  /// For example, for the locale "zh-Hant-HK", returns "Hant".
  var scriptCode: String? { get }
  /// Returns the variant code for the locale, or nil if it has none.
  ///
  /// For example, for the locale "en_POSIX", returns "POSIX".
  var variantCode: String? { get }
  /// Returns the exemplar character set for the locale, or nil if has none.
  var exemplarCharacterSet: CharacterSet? { get }
  /// Returns the calendar for the locale, or the Gregorian calendar as a fallback.
  var calendar: Calendar { get }
  /// Returns the collation identifier for the locale, or nil if it has none.
  ///
  /// For example, for the locale "en_US@collation=phonebook", returns "phonebook".
  var collationIdentifier: String? { get }
  /// Returns true if the locale uses the metric system.
  ///
  /// -seealso: MeasurementFormatter
  var usesMetricSystem: Bool { get }
  /// Returns the decimal separator of the locale.
  ///
  /// For example, for "en_US", returns ".".
  var decimalSeparator: String? { get }
  /// Returns the grouping separator of the locale.
  ///
  /// For example, for "en_US", returns ",".
  var groupingSeparator: String? { get }
  /// Returns the currency symbol of the locale.
  ///
  /// For example, for "zh-Hant-HK", returns "HK$".
  var currencySymbol: String? { get }
  /// Returns the currency code of the locale.
  ///
  /// For example, for "zh-Hant-HK", returns "HKD".
  var currencyCode: String? { get }
  /// Returns the collator identifier of the locale.
  var collatorIdentifier: String? { get }
  /// Returns the quotation begin delimiter of the locale.
  ///
  /// For example, returns `“` for "en_US", and `「` for "zh-Hant-HK".
  var quotationBeginDelimiter: String? { get }
  /// Returns the quotation end delimiter of the locale.
  ///
  /// For example, returns `”` for "en_US", and `」` for "zh-Hant-HK".
  var quotationEndDelimiter: String? { get }
  /// Returns the alternate quotation begin delimiter of the locale.
  ///
  /// For example, returns `‘` for "en_US", and `『` for "zh-Hant-HK".
  var alternateQuotationBeginDelimiter: String? { get }
  /// Returns the alternate quotation end delimiter of the locale.
  ///
  /// For example, returns `’` for "en_US", and `』` for "zh-Hant-HK".
  var alternateQuotationEndDelimiter: String? { get }
  /// Returns a list of available `Locale` identifiers.
  static var availableIdentifiers: [String] { get }
  /// Returns a list of available `Locale` language codes.
  static var isoLanguageCodes: [String] { get }
  /// Returns a list of available `Locale` region codes.
  static var isoRegionCodes: [String] { get }
  /// Returns a list of available `Locale` currency codes.
  static var isoCurrencyCodes: [String] { get }
  /// Returns a list of common `Locale` currency codes.
  static var commonISOCurrencyCodes: [String] { get }
  /// Returns a list of the user's preferred languages.
  ///
  /// - note: `Bundle` is responsible for determining the language that your application will run in, based on the result of this API and combined with the languages your application supports.
  /// - seealso: `Bundle.preferredLocalizations(from:)`
  /// - seealso: `Bundle.preferredLocalizations(from:forPreferences:)`
  static var preferredLanguages: [String] { get }
  /// Returns a dictionary that splits an identifier into its component pieces.
  static func components(fromIdentifier string: String) -> [String : String]
  /// Constructs an identifier from a dictionary of components.
  static func identifier(fromComponents components: [String : String]) -> String
  /// Returns a canonical identifier from the given string.
  static func canonicalIdentifier(from string: String) -> String
  /// Returns a canonical language identifier from the given string.
  static func canonicalLanguageIdentifier(from string: String) -> String
  /// Returns the `Locale` identifier from a given Windows locale code, or nil if it could not be converted.
  static func identifier(fromWindowsLocaleCode code: Int) -> String?
  /// Returns the Windows locale code from a given identifier, or nil if it could not be converted.
  static func windowsLocaleCode(fromIdentifier identifier: String) -> Int?
  /// Returns the character direction for a specified language code.
  static func characterDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection
  /// Returns the line direction for a specified language code.
  static func lineDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection
  @available(*, unavailable, renamed: "init(identifier:)")
  init(localeIdentifier: String)
  @available(*, unavailable, renamed: "identifier")
  var localeIdentifier: String { get }
  @available(*, unavailable, renamed: "localizedString(forIdentifier:)")
  func localizedString(forLocaleIdentifier localeIdentifier: String) -> String
  @available(*, unavailable, renamed: "availableIdentifiers")
  static var availableLocaleIdentifiers: [String] { get }
  @available(*, unavailable, renamed: "components(fromIdentifier:)")
  static func components(fromLocaleIdentifier string: String) -> [String : String]
  @available(*, unavailable, renamed: "identifier(fromComponents:)")
  static func localeIdentifier(fromComponents dict: [String : String]) -> String
  @available(*, unavailable, renamed: "canonicalIdentifier(from:)")
  static func canonicalLocaleIdentifier(from string: String) -> String
  @available(*, unavailable, renamed: "identifier(fromWindowsLocaleCode:)")
  static func localeIdentifier(fromWindowsLocaleCode lcid: UInt32) -> String?
  @available(*, unavailable, renamed: "windowsLocaleCode(fromIdentifier:)")
  static func windowsLocaleCode(fromLocaleIdentifier localeIdentifier: String) -> UInt32
  @available(*, unavailable, message: "use regionCode instead")
  var countryCode: String { get }
  @available(*, unavailable, message: "use localizedString(forRegionCode:) instead")
  func localizedString(forCountryCode countryCode: String) -> String
  @available(*, unavailable, renamed: "isoRegionCodes")
  static var isoCountryCodes: [String] { get }
  func hash(into hasher: inout Hasher)
  static func == (lhs: Locale, rhs: Locale) -> Bool
  var hashValue: Int { get }
}

extension Locale : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  var customMirror: Mirror { get }
  var description: String { get }
  var debugDescription: String { get }
}

extension Locale : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSLocale
  static func _forceBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSLocale?) -> Locale
  typealias _ObjectiveCType = NSLocale
}

extension Locale : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/// Describes an error that provides localized messages describing why
/// an error occurred and provides more information about the error.
protocol LocalizedError : Error {
  /// A localized message describing what error occurred.
  var errorDescription: String? { get }
  /// A localized message describing the reason for the failure.
  var failureReason: String? { get }
  /// A localized message describing how one might recover from the failure.
  var recoverySuggestion: String? { get }
  /// A localized message providing "help" text if the user requests help.
  var helpAnchor: String? { get }
}

extension LocalizedError {
  var errorDescription: String? { get }
  var failureReason: String? { get }
  var recoverySuggestion: String? { get }
  var helpAnchor: String? { get }
}

/// Describes an error in the Mach error domain.
struct MachError : _BridgedStoredNSError {
  let _nsError: NSError
  init(_nsError error: NSError)
  static var errorDomain: String { get }
  var hashValue: Int { get }
  typealias Code = MachErrorCode
}

extension MachError {
  static var success: MachError.Code { get }
  /// Specified address is not currently valid.
  static var invalidAddress: MachError.Code { get }
  /// Specified memory is valid, but does not permit the required
  /// forms of access.
  static var protectionFailure: MachError.Code { get }
  /// The address range specified is already in use, or no address
  /// range of the size specified could be found.
  static var noSpace: MachError.Code { get }
  /// The function requested was not applicable to this type of
  /// argument, or an argument is invalid.
  static var invalidArgument: MachError.Code { get }
  /// The function could not be performed.  A catch-all.
  static var failure: MachError.Code { get }
  /// A system resource could not be allocated to fulfill this
  /// request.  This failure may not be permanent.
  static var resourceShortage: MachError.Code { get }
  /// The task in question does not hold receive rights for the port
  /// argument.
  static var notReceiver: MachError.Code { get }
  /// Bogus access restriction.
  static var noAccess: MachError.Code { get }
  /// During a page fault, the target address refers to a memory
  /// object that has been destroyed.  This failure is permanent.
  static var memoryFailure: MachError.Code { get }
  /// During a page fault, the memory object indicated that the data
  /// could not be returned.  This failure may be temporary; future
  /// attempts to access this same data may succeed, as defined by the
  /// memory object.
  static var memoryError: MachError.Code { get }
  /// The receive right is already a member of the portset.
  static var alreadyInSet: MachError.Code { get }
  /// The receive right is not a member of a port set.
  static var notInSet: MachError.Code { get }
  /// The name already denotes a right in the task.
  static var nameExists: MachError.Code { get }
  /// The operation was aborted.  Ipc code will catch this and reflect
  /// it as a message error.
  static var aborted: MachError.Code { get }
  /// The name doesn't denote a right in the task.
  static var invalidName: MachError.Code { get }
  /// Target task isn't an active task.
  static var invalidTask: MachError.Code { get }
  /// The name denotes a right, but not an appropriate right.
  static var invalidRight: MachError.Code { get }
  /// A blatant range error.
  static var invalidValue: MachError.Code { get }
  /// Operation would overflow limit on user-references.
  static var userReferencesOverflow: MachError.Code { get }
  /// The supplied (port) capability is improper.
  static var invalidCapability: MachError.Code { get }
  /// The task already has send or receive rights for the port under
  /// another name.
  static var rightExists: MachError.Code { get }
  /// Target host isn't actually a host.
  static var invalidHost: MachError.Code { get }
  /// An attempt was made to supply "precious" data for memory that is
  /// already present in a memory object.
  static var memoryPresent: MachError.Code { get }
  /// A page was requested of a memory manager via
  /// memory_object_data_request for an object using a
  /// MEMORY_OBJECT_COPY_CALL strategy, with the VM_PROT_WANTS_COPY
  /// flag being used to specify that the page desired is for a copy
  /// of the object, and the memory manager has detected the page was
  /// pushed into a copy of the object while the kernel was walking
  /// the shadow chain from the copy to the object. This error code is
  /// delivered via memory_object_data_error and is handled by the
  /// kernel (it forces the kernel to restart the fault). It will not
  /// be seen by users.
  static var memoryDataMoved: MachError.Code { get }
  /// A strategic copy was attempted of an object upon which a quicker
  /// copy is now possible.  The caller should retry the copy using
  /// vm_object_copy_quickly. This error code is seen only by the
  /// kernel.
  static var memoryRestartCopy: MachError.Code { get }
  /// An argument applied to assert processor set privilege was not a
  /// processor set control port.
  static var invalidProcessorSet: MachError.Code { get }
  /// The specified scheduling attributes exceed the thread's limits.
  static var policyLimit: MachError.Code { get }
  /// The specified scheduling policy is not currently enabled for the
  /// processor set.
  static var invalidPolicy: MachError.Code { get }
  /// The external memory manager failed to initialize the memory object.
  static var invalidObject: MachError.Code { get }
  /// A thread is attempting to wait for an event for which there is
  /// already a waiting thread.
  static var alreadyWaiting: MachError.Code { get }
  /// An attempt was made to destroy the default processor set.
  static var defaultSet: MachError.Code { get }
  /// An attempt was made to fetch an exception port that is
  /// protected, or to abort a thread while processing a protected
  /// exception.
  static var exceptionProtected: MachError.Code { get }
  /// A ledger was required but not supplied.
  static var invalidLedger: MachError.Code { get }
  /// The port was not a memory cache control port.
  static var invalidMemoryControl: MachError.Code { get }
  /// An argument supplied to assert security privilege was not a host
  /// security port.
  static var invalidSecurity: MachError.Code { get }
  /// thread_depress_abort was called on a thread which was not
  /// currently depressed.
  static var notDepressed: MachError.Code { get }
  /// Object has been terminated and is no longer available.
  static var terminated: MachError.Code { get }
  /// Lock set has been destroyed and is no longer available.
  static var lockSetDestroyed: MachError.Code { get }
  /// The thread holding the lock terminated before releasing the lock.
  static var lockUnstable: MachError.Code { get }
  /// The lock is already owned by another thread.
  static var lockOwned: MachError.Code { get }
  /// The lock is already owned by the calling thread.
  static var lockOwnedSelf: MachError.Code { get }
  /// Semaphore has been destroyed and is no longer available.
  static var semaphoreDestroyed: MachError.Code { get }
  /// Return from RPC indicating the target server was terminated
  /// before it successfully replied.
  static var rpcServerTerminated: MachError.Code { get }
  /// Terminate an orphaned activation.
  static var rpcTerminateOrphan: MachError.Code { get }
  /// Allow an orphaned activation to continue executing.
  static var rpcContinueOrphan: MachError.Code { get }
  /// Empty thread activation (No thread linked to it).
  static var notSupported: MachError.Code { get }
  /// Remote node down or inaccessible.
  static var nodeDown: MachError.Code { get }
  /// A signalled thread was not actually waiting.
  static var notWaiting: MachError.Code { get }
  /// Some thread-oriented operation (semaphore_wait) timed out.
  static var operationTimedOut: MachError.Code { get }
  /// During a page fault, indicates that the page was rejected as a
  /// result of a signature check.
  static var codesignError: MachError.Code { get }
  /// The requested property cannot be changed at this time.
  static var policyStatic: MachError.Code { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol MarkdownDecodableAttributedStringKey : AttributedStringKey {
  static func decodeMarkdown(from decoder: Decoder) throws -> Self.Value
  static var markdownName: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension MarkdownDecodableAttributedStringKey {
  static var markdownName: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension MarkdownDecodableAttributedStringKey where Self : DecodableAttributedStringKey {
  static func decodeMarkdown(from decoder: Decoder) throws -> Self.Value
}

/// A `Measurement` is a model type that holds a `Double` value associated with a `Unit`.
///
/// Measurements support a large set of operators, including `+`, `-`, `*`, `/`, and a full set of comparison operators.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
struct Measurement<UnitType> : ReferenceConvertible, Comparable, Equatable where UnitType : Unit {
  typealias ReferenceType = NSMeasurement
  /// The unit component of the `Measurement`.
  let unit: UnitType
  /// The value component of the `Measurement`.
  var value: Double
  /// Create a `Measurement` given a specified value and unit.
  init(value: Double, unit: UnitType)
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {
  struct AttributedStyle : FormatStyle {
    func format(_ measurement: Measurement<UnitType>) -> AttributedString
    func locale(_ locale: Locale) -> Measurement<UnitType>.AttributedStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Measurement<UnitType>.AttributedStyle, b: Measurement<UnitType>.AttributedStyle) -> Bool
    typealias FormatInput = Measurement<UnitType>
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {
  struct FormatStyle : FormatStyle {
    struct UnitWidth : Codable, Hashable {
      /// Examples for formatting a measurement with value of 37.20:
      ///
      /// Shows the unit in its full spelling.
      /// For example, "37.20 Calories", "37,20 litres"
      static var wide: Measurement<UnitType>.FormatStyle.UnitWidth { get }
      /// Shows the unit using abbreviation.
      /// For example, "37.20 Cal", "37,2 L"
      static var abbreviated: Measurement<UnitType>.FormatStyle.UnitWidth { get }
      /// Shows the unit in the shortest form possible, and may condense the spacing between the value and the unit.
      /// For example, "37.20Cal", "37,2L"
      static var narrow: Measurement<UnitType>.FormatStyle.UnitWidth { get }
      func hash(into hasher: inout Hasher)
      static func == (a: Measurement<UnitType>.FormatStyle.UnitWidth, b: Measurement<UnitType>.FormatStyle.UnitWidth) -> Bool
      func encode(to encoder: Encoder) throws
      var hashValue: Int { get }
      init(from decoder: Decoder) throws
    }
    var width: Measurement<UnitType>.FormatStyle.UnitWidth
    var locale: Locale
    /// Specifies how the value part is formatted.
    var numberFormatStyle: FloatingPointFormatStyle<Double>?
    var usage: MeasurementFormatUnitUsage<UnitType>?
    var attributed: Measurement<UnitType>.AttributedStyle { get }
    init(width: Measurement<UnitType>.FormatStyle.UnitWidth, locale: Locale = .autoupdatingCurrent, usage: MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil)
    func locale(_ locale: Locale) -> Measurement<UnitType>.FormatStyle
    func format(_ measurement: Measurement<UnitType>) -> String
    func hash(into hasher: inout Hasher)
    static func == (a: Measurement<UnitType>.FormatStyle, b: Measurement<UnitType>.FormatStyle) -> Bool
    typealias FormatInput = Measurement<UnitType>
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {
  func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Measurement<UnitType>
  func formatted() -> String
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

/// When a `Measurement` contains a `Dimension` unit, it gains the ability to convert between the kinds of units in that dimension.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement where UnitType : Dimension {
  /// Returns a new measurement created by converting to the specified unit.
  ///
  /// - parameter otherUnit: A unit of the same `Dimension`.
  /// - returns: A converted measurement.
  func converted(to otherUnit: UnitType) -> Measurement<UnitType>
  /// Converts the measurement to the specified unit.
  ///
  /// - parameter otherUnit: A unit of the same `Dimension`.
  mutating func convert(to otherUnit: UnitType)
  /// Add two measurements of the same Dimension.
  ///
  /// If the `unit` of the `lhs` and `rhs` are `isEqual`, then this returns the result of adding the `value` of each `Measurement`. If they are not equal, then this will convert both to the base unit of the `Dimension` and return the result as a `Measurement` of that base unit.
  /// - returns: The result of adding the two measurements.
  static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  /// Subtract two measurements of the same Dimension.
  ///
  /// If the `unit` of the `lhs` and `rhs` are `==`, then this returns the result of subtracting the `value` of each `Measurement`. If they are not equal, then this will convert both to the base unit of the `Dimension` and return the result as a `Measurement` of that base unit.
  /// - returns: The result of adding the two measurements.
  static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement {
  /// Add two measurements of the same Unit.
  /// - precondition: The `unit` of `lhs` and `rhs` must be `isEqual`.
  /// - returns: A measurement of value `lhs.value + rhs.value` and unit `lhs.unit`.
  static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  /// Subtract two measurements of the same Unit.
  /// - precondition: The `unit` of `lhs` and `rhs` must be `isEqual`.
  /// - returns: A measurement of value `lhs.value - rhs.value` and unit `lhs.unit`.
  static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  /// Multiply a measurement by a scalar value.
  /// - returns: A measurement of value `lhs.value * rhs` with the same unit as `lhs`.
  static func * (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>
  /// Multiply a scalar value by a measurement.
  /// - returns: A measurement of value `lhs * rhs.value` with the same unit as `rhs`.
  static func * (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  /// Divide a measurement by a scalar value.
  /// - returns: A measurement of value `lhs.value / rhs` with the same unit as `lhs`.
  static func / (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>
  /// Divide a scalar value by a measurement.
  /// - returns: A measurement of value `lhs / rhs.value` with the same unit as `rhs`.
  static func / (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  /// Compare two measurements of the same `Dimension`.
  ///
  /// If `lhs.unit == rhs.unit`, returns `lhs.value == rhs.value`. Otherwise, converts `rhs` to the same unit as `lhs` and then compares the resulting values.
  /// - returns: `true` if the measurements are equal.
  static func == <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Unit, RightHandSideType : Unit
  /// Compare two measurements of the same `Unit`.
  /// - returns: `true` if the measurements can be compared and the `lhs` is less than the `rhs` converted value.
  static func < <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Unit, RightHandSideType : Unit
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : MeasurementBridgeType {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSMeasurement
  static func _forceBridgeFromObjectiveC(_ source: NSMeasurement, result: inout Measurement<UnitType>?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSMeasurement, result: inout Measurement<UnitType>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSMeasurement?) -> Measurement<UnitType>
  typealias _ObjectiveCType = NSMeasurement
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement.FormatStyle where UnitType == UnitTemperature {
  /// Hides the scale name. For example, "90°" rather than "90°F" or "90°C" with the `narrow` unit width, or "90 degrees" rather than "90 degrees celcius" or "90 degrees fahrenheit" with the `wide` width.
  var hidesScaleName: Bool
  init(width: Measurement<UnitType>.FormatStyle.UnitWidth = .abbreviated, locale: Locale = .autoupdatingCurrent, usage: MeasurementFormatUnitUsage<UnitType> = .general, hidesScaleName: Bool = false, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil)
}

@usableFromInline
typealias MeasurementBridgeType = _ObjectiveCBridgeable

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct MeasurementFormatUnitUsage<UnitType> : Codable, Hashable where UnitType : Dimension {
  /// Default. No specific usage.
  static var general: MeasurementFormatUnitUsage<UnitType> { get }
  /// Ignore the preferred unit by the locale and use the given unit.
  static var asProvided: MeasurementFormatUnitUsage<UnitType> { get }
  func hash(into hasher: inout Hasher)
  static func == (a: MeasurementFormatUnitUsage<UnitType>, b: MeasurementFormatUnitUsage<UnitType>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitTemperature {
  static var weather: MeasurementFormatUnitUsage<UnitTemperature> { get }
  static var person: MeasurementFormatUnitUsage<UnitTemperature> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitLength {
  static var person: MeasurementFormatUnitUsage<UnitLength> { get }
  static var road: MeasurementFormatUnitUsage<UnitLength> { get }
  static var personHeight: MeasurementFormatUnitUsage<UnitLength> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitEnergy {
  static var food: MeasurementFormatUnitUsage<UnitEnergy> { get }
  static var workout: MeasurementFormatUnitUsage<UnitEnergy> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitMass {
  static var personWeight: MeasurementFormatUnitUsage<UnitMass> { get }
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
struct Morphology {
  init()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  enum GrammaticalGender : Int, Hashable {
    case feminine
    case masculine
    case neuter
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  var grammaticalGender: Morphology.GrammaticalGender?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  enum PartOfSpeech : Int, Hashable {
    case determiner
    case pronoun
    case letter
    case adverb
    case particle
    case adjective
    case adposition
    case verb
    case noun
    case conjunction
    case numeral
    case interjection
    case preposition
    case abbreviation
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  var partOfSpeech: Morphology.PartOfSpeech?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  enum GrammaticalNumber : Int, Hashable {
    case singular
    case zero
    case plural
    case pluralTwo
    case pluralFew
    case pluralMany
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
  var number: Morphology.GrammaticalNumber?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology : Hashable {
  func hash(into hasher: inout Hasher)
  static func == (a: Morphology, b: Morphology) -> Bool
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology {
  func customPronoun(forLanguage language: String) -> Morphology.CustomPronoun?
  mutating func setCustomPronoun(_ pronoun: Morphology.CustomPronoun?, forLanguage language: String) throws
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  struct CustomPronoun {
    init()
    static func isSupported(forLanguage language: String) -> Bool
    static func requiredKeys(forLanguage language: String) -> [PartialKeyPath<Morphology.CustomPronoun>]
    var subjectForm: String?
    var objectForm: String?
    var possessiveForm: String?
    var possessiveAdjectiveForm: String?
    var reflexiveForm: String?
  }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology {
  var isUnspecified: Bool { get }
  static let user: Morphology
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __NSMorphology
  static func _forceBridgeFromObjectiveC(_ morphology: __NSMorphology, result: inout Morphology?)
  static func _conditionallyBridgeFromObjectiveC(_ morphology: __NSMorphology, result: inout Morphology?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ morphology: __NSMorphology?) -> Morphology
  typealias _ObjectiveCType = __NSMorphology
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.GrammaticalGender : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.GrammaticalGender : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.PartOfSpeech : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.PartOfSpeech : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.GrammaticalNumber : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.GrammaticalNumber : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.CustomPronoun : Hashable {
  func hash(into hasher: inout Hasher)
  static func == (a: Morphology.CustomPronoun, b: Morphology.CustomPronoun) -> Bool
  var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.CustomPronoun : Codable {
  func encode(to encoder: Encoder) throws
  init(from decoder: Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.CustomPronoun : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __NSMorphologyCustomPronoun
  static func _forceBridgeFromObjectiveC(_ morphology: __NSMorphologyCustomPronoun, result: inout Morphology.CustomPronoun?)
  static func _conditionallyBridgeFromObjectiveC(_ morphology: __NSMorphologyCustomPronoun, result: inout Morphology.CustomPronoun?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ morphology: __NSMorphologyCustomPronoun?) -> Morphology.CustomPronoun
  typealias _ObjectiveCType = __NSMorphologyCustomPronoun
}

protocol MutableDataProtocol : DataProtocol, MutableCollection, RangeReplaceableCollection {
  /// Replaces the contents of the buffer at the given range with zeroes.
  ///
  /// A default implementation is given in terms of
  /// `replaceSubrange(_:with:)`.
  mutating func resetBytes<R>(in range: R) where R : RangeExpression, Self.Index == R.Bound
}

extension MutableDataProtocol {
  mutating func resetBytes<R>(in range: R) where R : RangeExpression, Self.Index == R.Bound
}

@available(*, deprecated, message: "Please use the struct type URLRequest")
typealias MutableURLRequest = NSMutableURLRequest

@available(*, unavailable, renamed: "String.Encoding.ascii")
var NSASCIIStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "CocoaError")
typealias NSCocoaError = CocoaError

typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer<NSError?>?

struct NSFastEnumerationIterator : IteratorProtocol {
  init(_ enumerable: NSFastEnumeration)
  mutating func next() -> Any?
  typealias Element = Any
}

@available(*, unavailable, renamed: "String.Encoding.iso2022JP")
var NSISO2022JPStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.isoLatin1")
var NSISOLatin1StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.isoLatin2")
var NSISOLatin2StringEncoding: String.Encoding { get }

struct NSIndexSetIterator : IteratorProtocol {
  typealias Element = Int
  mutating func next() -> Int?
}

@available(*, unavailable, renamed: "String.Encoding.japaneseEUC")
var NSJapaneseEUCStringEncoding: String.Encoding { get }

@objc(_NSKeyValueObservation) class NSKeyValueObservation : NSObject {
  ///invalidate() will be called automatically when an NSKeyValueObservation is deinited
  @objc func invalidate()
}

struct NSKeyValueObservedChange<Value> {
  typealias Kind = NSKeyValueChange
  let kind: NSKeyValueObservedChange<Value>.Kind
  ///newValue and oldValue will only be non-nil if .new/.old is passed to `observe()`. In general, get the most up to date value by accessing it directly on the observed object instead.
  let newValue: Value?
  let oldValue: Value?
  ///indexes will be nil unless the observed KeyPath refers to an ordered to-many property
  let indexes: IndexSet?
  ///'isPrior' will be true if this change observation is being sent before the change happens, due to .prior being passed to `observe()`
  let isPrior: Bool
}

///Conforming to NSKeyValueObservingCustomization is not required to use Key-Value Observing. Provide an implementation of these functions if you need to disable auto-notifying for a key, or add dependent keys
protocol NSKeyValueObservingCustomization : NSObjectProtocol {
  static func keyPathsAffectingValue(for key: AnyKeyPath) -> Set<AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: AnyKeyPath) -> Bool
}

/// Returns the localized version of a string.
///
/// - parameter key: An identifying value used to reference a localized string.
///   Don't use the empty string as a key. Values keyed by the empty string will
///   not be localized.
/// - parameter tableName: The name of the table containing the localized string
///   identified by `key`. This is the prefix of the strings file—a file with
///   the `.strings` extension—containing the localized values. If `tableName`
///   is `nil` or the empty string, the `Localizable` table is used.
/// - parameter bundle: The bundle containing the table's strings file. The main
///   bundle is used by default.
/// - parameter value: A user-visible string to return when the localized string
///   for `key` cannot be found in the table. If `value` is the empty string,
///   `key` would be returned instead.
/// - parameter comment: A note to the translator describing the context where
///   the localized string is presented to the user.
///
/// - returns: A localized version of the string designated by `key` in the
///   table identified by `tableName`. If the localized string for `key` cannot
///   be found within the table, `value` is returned. However, `key` is returned
///   instead when `value` is the empty string.
///
/// Export Localizations with Xcode
/// -------------------------------
///
/// Xcode can read through a project's code to find invocations of
/// `NSLocalizedString(_:tableName:bundle:value:comment:)` and automatically
/// generate the appropriate strings files for the project's base localization.
///
/// In Xcode, open the project file and, in the `Edit` menu, select
/// `Export for Localization`. This will generate an XLIFF bundle containing
/// strings files derived from your code along with other localizable assets.
/// `xcodebuild` can also be used to generate the localization bundle from the
/// command line with the `exportLocalizations` option.
///
///     xcodebuild -exportLocalizations -project <projectname>.xcodeproj \
///                                     -localizationPath <path>
///
/// These bundles can be sent to translators for localization, and then
/// reimported into your Xcode project. In Xcode, open the project file. In the
/// `Edit` menu, select `Import Localizations...`, and select the XLIFF
/// folder to import. You can also use `xcodebuild` to import localizations with
/// the `importLocalizations` option.
///
///     xcodebuild -importLocalizations -project <projectname>.xcodeproj \
///                                     -localizationPath <path>
///
/// Choose Meaningful Keys
/// ----------------------
///
/// Words can often have multiple different meanings depending on the context
/// in which they're used. For example, the word "Book" can be used as a noun—a
/// printed literary work—and it can be used as a verb—the action of making a
/// reservation. Words with different meanings which share the same spelling are
/// heteronyms.
///
/// Different languages often have different heteronyms. "Book" in English is
/// one such heteronym, but that's not so in French, where the noun translates
/// to "Livre", and the verb translates to "Réserver". For this reason, it's
/// important make sure that each use of the same phrase is translated
/// appropriately for its context by assigning unique keys to each phrase and
/// adding a description comment describing how that phrase is used.
///
///     NSLocalizedString("book-tag-title", value: "Book", comment: """
///     noun: A label attached to literary items in the library.
///     """)
///
///     NSLocalizedString("book-button-title", value: "Book", comment: """
///     verb: Title of the button that makes a reservation.
///     """)
///
/// Use Only String Literals
/// ------------------------
///
/// String literal values must be used with `key`, `tableName`, `value`, and
/// `comment`.
///
/// Xcode does not evaluate interpolated strings and string variables when
/// generating strings files from code. Attempting to localize a string using
/// those language features will cause Xcode to export something that resembles
/// the original code expression instead of its expected value at runtime.
/// Translators would then translate that exported value—leaving
/// international users with a localized string containing code.
///
///     // Translators will see "1 + 1 = (1 + 1)".
///     // International users will see a localization "1 + 1 = (1 + 1)".
///     let localizedString = NSLocalizedString("string-interpolation",
///                                             value: "1 + 1 = \(1 + 1)"
///                                             comment: "A math equation.")
///
/// To dynamically insert values within localized strings, set `value` to a
/// format string, and use `String.localizedStringWithFormat(_:_:)` to insert
/// those values.
///
///     // Translators will see "1 + 1 = %d" (they know what "%d" means).
///     // International users will see a localization of "1 + 1 = 2".
///     let format = NSLocalizedString("string-literal",
///                                    value: "1 + 1 = %d",
///                                    comment: "A math equation.")
///     let localizedString = String.localizedStringWithFormat(format, (1 + 1))
///
/// Multiline string literals are technically supported, but will result in
/// unexpected behavior during internationalization. A newline will be inserted
/// before and after the body of text within the string, and translators will
/// likely preserve those in their internationalizations.
///
/// To preserve some of the aesthetics of having newlines in the string mirrored
/// in their code representation, string literal concatenation with the `+`
/// operator can be used.
///
///     NSLocalizedString("multiline-string-literal",
///                       value: """
///     This multiline string literal won't work as expected.
///     An extra newline is added to the beginning and end of the string.
///     """,
///                       comment: "The description of a sample of code.")
///
///     NSLocalizedString("string-literal-contatenation",
///                       value: "This string literal concatenated with"
///                            + "this other string literal works just fine.",
///                       comment: "The description of a sample of code.")
///
/// Since comments aren't localized, multiline string literals can be safely
/// used with `comment`.
///
/// Work with Manually Managed Strings
/// ----------------------------------
///
/// If having Xcode generate strings files from code isn't desired behavior,
/// call `Bundle.localizedString(forKey:value:table:)` instead.
///
///     let greeting = Bundle.localizedString(forKey: "program-greeting",
///                                           value: "Hello, World!",
///                                           table: "Localization")
///
/// However, this requires the manual creation and management of that table's
/// strings file.
///
///     /* Localization.strings */
///
///     /* A friendly greeting to the user when the program starts. */
///     "program-greeting" = "Hello, World!";
///
/// - note: Although `NSLocalizedString(_:tableName:bundle:value:comment:)`
/// and `Bundle.localizedString(forKey:value:table:)` can be used in a project
/// at the same time, data from manually managed strings files will be
/// overwritten by Xcode when their table is also used to look up localized
/// strings with `NSLocalizedString(_:tableName:bundle:value:comment:)`.
func NSLocalizedString(_ key: String, tableName: String? = nil, bundle: Bundle = Bundle.main, value: String = "", comment: String) -> String

func NSLog(_ format: String, _ args: CVarArg...)

@available(*, unavailable, renamed: "String.Encoding.macOSRoman")
var NSMacOSRomanStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.nextstep")
var NSNEXTSTEPStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.nonLossyASCII")
var NSNonLossyASCIIStringEncoding: String.Encoding { get }

let NSNotFound: Int

@available(*, unavailable, renamed: "String.Encoding.shiftJIS")
var NSShiftJISStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding")
typealias NSStringEncoding = UInt

@available(*, unavailable, renamed: "String.Encoding.symbol")
var NSSymbolStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16BigEndian")
var NSUTF16BigEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16LittleEndian")
var NSUTF16LittleEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16")
var NSUTF16StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32BigEndian")
var NSUTF32BigEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32LittleEndian")
var NSUTF32LittleEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32")
var NSUTF32StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf8")
var NSUTF8StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.unicode")
var NSUnicodeStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1250")
var NSWindowsCP1250StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1251")
var NSWindowsCP1251StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1252")
var NSWindowsCP1252StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1253")
var NSWindowsCP1253StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1254")
var NSWindowsCP1254StringEncoding: String.Encoding { get }

/**
 `Notification` encapsulates information broadcast to observers via a `NotificationCenter`.
*/
struct Notification : ReferenceConvertible, Equatable, Hashable {
  typealias ReferenceType = NSNotification
  /// A tag identifying the notification.
  var name: Notification.Name
  /// An object that the poster wishes to send to observers.
  ///
  /// Typically this is the object that posted the notification.
  var object: Any?
  /// Storage for values or objects related to this notification.
  var userInfo: [AnyHashable : Any]?
  /// Initialize a new `Notification`.
  ///
  /// The default value for `userInfo` is nil.
  init(name: Notification.Name, object: Any? = nil, userInfo: [AnyHashable : Any]? = nil)
  func hash(into hasher: inout Hasher)
  var description: String { get }
  var debugDescription: String { get }
  typealias Name = NSNotification.Name
  /// Compare two notifications for equality.
  static func == (lhs: Notification, rhs: Notification) -> Bool
  var hashValue: Int { get }
}

extension Notification : CustomReflectable {
  var customMirror: Mirror { get }
}

extension Notification : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNotification
  static func _forceBridgeFromObjectiveC(_ x: NSNotification, result: inout Notification?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNotification, result: inout Notification?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNotification?) -> Notification
  typealias _ObjectiveCType = NSNotification
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
enum NumberFormatStyleConfiguration {
  typealias RoundingRule = FloatingPointRoundingRule
  struct Grouping : Codable, Hashable, CustomStringConvertible {
    static var automatic: NumberFormatStyleConfiguration.Grouping { get }
    static var never: NumberFormatStyleConfiguration.Grouping { get }
    var description: String { get }
    func hash(into hasher: inout Hasher)
    static func == (a: NumberFormatStyleConfiguration.Grouping, b: NumberFormatStyleConfiguration.Grouping) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct Precision : Codable, Hashable {
    static func significantDigits<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression, R.Bound == Int
    static func significantDigits(_ digits: Int) -> NumberFormatStyleConfiguration.Precision
    static func integerAndFractionLength<R1, R2>(integerLimits: R1, fractionLimits: R2) -> NumberFormatStyleConfiguration.Precision where R1 : RangeExpression, R2 : RangeExpression, R1.Bound == Int, R2.Bound == Int
    static func integerAndFractionLength(integer: Int, fraction: Int) -> NumberFormatStyleConfiguration.Precision
    static func integerLength<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression
    static func integerLength(_ length: Int) -> NumberFormatStyleConfiguration.Precision
    static func fractionLength<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression, R.Bound == Int
    static func fractionLength(_ length: Int) -> NumberFormatStyleConfiguration.Precision
    func hash(into hasher: inout Hasher)
    static func == (a: NumberFormatStyleConfiguration.Precision, b: NumberFormatStyleConfiguration.Precision) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct DecimalSeparatorDisplayStrategy : Codable, Hashable, CustomStringConvertible {
    static var automatic: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy { get }
    static var always: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy { get }
    var description: String { get }
    func hash(into hasher: inout Hasher)
    static func == (a: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy, b: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct SignDisplayStrategy : Codable, Hashable, CustomStringConvertible {
    static var automatic: NumberFormatStyleConfiguration.SignDisplayStrategy { get }
    static var never: NumberFormatStyleConfiguration.SignDisplayStrategy { get }
    static func always(includingZero: Bool = true) -> NumberFormatStyleConfiguration.SignDisplayStrategy
    var description: String { get }
    func hash(into hasher: inout Hasher)
    static func == (a: NumberFormatStyleConfiguration.SignDisplayStrategy, b: NumberFormatStyleConfiguration.SignDisplayStrategy) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct Notation : Codable, Hashable, CustomStringConvertible {
    static var scientific: NumberFormatStyleConfiguration.Notation { get }
    static var automatic: NumberFormatStyleConfiguration.Notation { get }
    /// Formats the number with localized prefixes or suffixes corresponding to powers of ten. Rounds to integer while showing at least two significant digits by default.
    /// For example, "42.3K" for 42300 for the "en_US" locale.
    /// - note: We do not support parsing a number string containing localized prefixes or suffixes.
    static var compactName: NumberFormatStyleConfiguration.Notation { get }
    var description: String { get }
    func hash(into hasher: inout Hasher)
    static func == (a: NumberFormatStyleConfiguration.Notation, b: NumberFormatStyleConfiguration.Notation) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol ObjectiveCConvertibleAttributedStringKey : AttributedStringKey {
  associatedtype ObjectiveCValue : NSObject
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == NSNumber, Self.Value : RawRepresentable, Self.Value.RawValue == Int {
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == NSString, Self.Value : RawRepresentable, Self.Value.RawValue == String {
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
typealias ObservableObject = ObservableObject

/// Describes an error in the POSIX error domain.
struct POSIXError : _BridgedStoredNSError {
  let _nsError: NSError
  init(_nsError error: NSError)
  static var errorDomain: String { get }
  var hashValue: Int { get }
  typealias Code = POSIXErrorCode
}

extension POSIXError {
  static var EPERM: POSIXErrorCode { get }
  /// No such file or directory.
  static var ENOENT: POSIXErrorCode { get }
  /// No such process.
  static var ESRCH: POSIXErrorCode { get }
  /// Interrupted system call.
  static var EINTR: POSIXErrorCode { get }
  /// Input/output error.
  static var EIO: POSIXErrorCode { get }
  /// Device not configured.
  static var ENXIO: POSIXErrorCode { get }
  /// Argument list too long.
  static var E2BIG: POSIXErrorCode { get }
  /// Exec format error.
  static var ENOEXEC: POSIXErrorCode { get }
  /// Bad file descriptor.
  static var EBADF: POSIXErrorCode { get }
  /// No child processes.
  static var ECHILD: POSIXErrorCode { get }
  /// Resource deadlock avoided.
  static var EDEADLK: POSIXErrorCode { get }
  /// Cannot allocate memory.
  static var ENOMEM: POSIXErrorCode { get }
  /// Permission denied.
  static var EACCES: POSIXErrorCode { get }
  /// Bad address.
  static var EFAULT: POSIXErrorCode { get }
  /// Block device required.
  static var ENOTBLK: POSIXErrorCode { get }
  /// Device / Resource busy.
  static var EBUSY: POSIXErrorCode { get }
  /// File exists.
  static var EEXIST: POSIXErrorCode { get }
  /// Cross-device link.
  static var EXDEV: POSIXErrorCode { get }
  /// Operation not supported by device.
  static var ENODEV: POSIXErrorCode { get }
  /// Not a directory.
  static var ENOTDIR: POSIXErrorCode { get }
  /// Is a directory.
  static var EISDIR: POSIXErrorCode { get }
  /// Invalid argument.
  static var EINVAL: POSIXErrorCode { get }
  /// Too many open files in system.
  static var ENFILE: POSIXErrorCode { get }
  /// Too many open files.
  static var EMFILE: POSIXErrorCode { get }
  /// Inappropriate ioctl for device.
  static var ENOTTY: POSIXErrorCode { get }
  /// Text file busy.
  static var ETXTBSY: POSIXErrorCode { get }
  /// File too large.
  static var EFBIG: POSIXErrorCode { get }
  /// No space left on device.
  static var ENOSPC: POSIXErrorCode { get }
  /// Illegal seek.
  static var ESPIPE: POSIXErrorCode { get }
  /// Read-only file system.
  static var EROFS: POSIXErrorCode { get }
  /// Too many links.
  static var EMLINK: POSIXErrorCode { get }
  /// Broken pipe.
  static var EPIPE: POSIXErrorCode { get }
  /// math software.
  /// Numerical argument out of domain.
  static var EDOM: POSIXErrorCode { get }
  /// Result too large.
  static var ERANGE: POSIXErrorCode { get }
  /// non-blocking and interrupt i/o.
  /// Resource temporarily unavailable.
  static var EAGAIN: POSIXErrorCode { get }
  /// Operation would block.
  static var EWOULDBLOCK: POSIXErrorCode { get }
  /// Operation now in progress.
  static var EINPROGRESS: POSIXErrorCode { get }
  /// Operation already in progress.
  static var EALREADY: POSIXErrorCode { get }
  /// ipc/network software -- argument errors.
  /// Socket operation on non-socket.
  static var ENOTSOCK: POSIXErrorCode { get }
  /// Destination address required.
  static var EDESTADDRREQ: POSIXErrorCode { get }
  /// Message too long.
  static var EMSGSIZE: POSIXErrorCode { get }
  /// Protocol wrong type for socket.
  static var EPROTOTYPE: POSIXErrorCode { get }
  /// Protocol not available.
  static var ENOPROTOOPT: POSIXErrorCode { get }
  /// Protocol not supported.
  static var EPROTONOSUPPORT: POSIXErrorCode { get }
  /// Socket type not supported.
  static var ESOCKTNOSUPPORT: POSIXErrorCode { get }
  /// Operation not supported.
  static var ENOTSUP: POSIXErrorCode { get }
  /// Protocol family not supported.
  static var EPFNOSUPPORT: POSIXErrorCode { get }
  /// Address family not supported by protocol family.
  static var EAFNOSUPPORT: POSIXErrorCode { get }
  /// Address already in use.
  static var EADDRINUSE: POSIXErrorCode { get }
  /// Can't assign requested address.
  static var EADDRNOTAVAIL: POSIXErrorCode { get }
  /// ipc/network software -- operational errors
  /// Network is down.
  static var ENETDOWN: POSIXErrorCode { get }
  /// Network is unreachable.
  static var ENETUNREACH: POSIXErrorCode { get }
  /// Network dropped connection on reset.
  static var ENETRESET: POSIXErrorCode { get }
  /// Software caused connection abort.
  static var ECONNABORTED: POSIXErrorCode { get }
  /// Connection reset by peer.
  static var ECONNRESET: POSIXErrorCode { get }
  /// No buffer space available.
  static var ENOBUFS: POSIXErrorCode { get }
  /// Socket is already connected.
  static var EISCONN: POSIXErrorCode { get }
  /// Socket is not connected.
  static var ENOTCONN: POSIXErrorCode { get }
  /// Can't send after socket shutdown.
  static var ESHUTDOWN: POSIXErrorCode { get }
  /// Too many references: can't splice.
  static var ETOOMANYREFS: POSIXErrorCode { get }
  /// Operation timed out.
  static var ETIMEDOUT: POSIXErrorCode { get }
  /// Connection refused.
  static var ECONNREFUSED: POSIXErrorCode { get }
  /// Too many levels of symbolic links.
  static var ELOOP: POSIXErrorCode { get }
  /// File name too long.
  static var ENAMETOOLONG: POSIXErrorCode { get }
  /// Host is down.
  static var EHOSTDOWN: POSIXErrorCode { get }
  /// No route to host.
  static var EHOSTUNREACH: POSIXErrorCode { get }
  /// Directory not empty.
  static var ENOTEMPTY: POSIXErrorCode { get }
  /// quotas & mush.
  /// Too many processes.
  static var EPROCLIM: POSIXErrorCode { get }
  /// Too many users.
  static var EUSERS: POSIXErrorCode { get }
  /// Disc quota exceeded.
  static var EDQUOT: POSIXErrorCode { get }
  /// Network File System.
  /// Stale NFS file handle.
  static var ESTALE: POSIXErrorCode { get }
  /// Too many levels of remote in path.
  static var EREMOTE: POSIXErrorCode { get }
  /// RPC struct is bad.
  static var EBADRPC: POSIXErrorCode { get }
  /// RPC version wrong.
  static var ERPCMISMATCH: POSIXErrorCode { get }
  /// RPC prog. not avail.
  static var EPROGUNAVAIL: POSIXErrorCode { get }
  /// Program version wrong.
  static var EPROGMISMATCH: POSIXErrorCode { get }
  /// Bad procedure for program.
  static var EPROCUNAVAIL: POSIXErrorCode { get }
  /// No locks available.
  static var ENOLCK: POSIXErrorCode { get }
  /// Function not implemented.
  static var ENOSYS: POSIXErrorCode { get }
  /// Inappropriate file type or format.
  static var EFTYPE: POSIXErrorCode { get }
  /// Authentication error.
  static var EAUTH: POSIXErrorCode { get }
  /// Need authenticator.
  static var ENEEDAUTH: POSIXErrorCode { get }
  /// Intelligent device errors.
  /// Device power is off.
  static var EPWROFF: POSIXErrorCode { get }
  /// Device error, e.g. paper out.
  static var EDEVERR: POSIXErrorCode { get }
  /// Value too large to be stored in data type.
  static var EOVERFLOW: POSIXErrorCode { get }
  /// Program loading errors.
  /// Bad executable.
  static var EBADEXEC: POSIXErrorCode { get }
  /// Bad CPU type in executable.
  static var EBADARCH: POSIXErrorCode { get }
  /// Shared library version mismatch.
  static var ESHLIBVERS: POSIXErrorCode { get }
  /// Malformed Macho file.
  static var EBADMACHO: POSIXErrorCode { get }
  /// Operation canceled.
  static var ECANCELED: POSIXErrorCode { get }
  /// Identifier removed.
  static var EIDRM: POSIXErrorCode { get }
  /// No message of desired type.
  static var ENOMSG: POSIXErrorCode { get }
  /// Illegal byte sequence.
  static var EILSEQ: POSIXErrorCode { get }
  /// Attribute not found.
  static var ENOATTR: POSIXErrorCode { get }
  /// Bad message.
  static var EBADMSG: POSIXErrorCode { get }
  /// Reserved.
  static var EMULTIHOP: POSIXErrorCode { get }
  /// No message available on STREAM.
  static var ENODATA: POSIXErrorCode { get }
  /// Reserved.
  static var ENOLINK: POSIXErrorCode { get }
  /// No STREAM resources.
  static var ENOSR: POSIXErrorCode { get }
  /// Not a STREAM.
  static var ENOSTR: POSIXErrorCode { get }
  /// Protocol error.
  static var EPROTO: POSIXErrorCode { get }
  /// STREAM ioctl timeout.
  static var ETIME: POSIXErrorCode { get }
  /// No such policy registered.
  static var ENOPOLICY: POSIXErrorCode { get }
  /// State not recoverable.
  static var ENOTRECOVERABLE: POSIXErrorCode { get }
  /// Previous owner died.
  static var EOWNERDEAD: POSIXErrorCode { get }
  /// Interface output queue is full.
  static var EQFULL: POSIXErrorCode { get }
}

/// A type that can parse a representation of a given data type.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
protocol ParseStrategy : Decodable, Encodable, Hashable {
  /// The type of the representation describing the data.
  associatedtype ParseInput
  /// The type of the data type.
  associatedtype ParseOutput
  /// Creates an instance of the `ParseOutput` type from `value`.
  func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy {
  static func fixed(format: Date.FormatString, timeZone: TimeZone, locale: Locale? = nil) -> Self where Self == Date.ParseStrategy
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == Date.FormatStyle {
  @_disfavoredOverload static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == PersonNameComponents.ParseStrategy {
  static var name: PersonNameComponents.ParseStrategy { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == Date.ISO8601FormatStyle {
  @_disfavoredOverload static var iso8601: Date.ISO8601FormatStyle { get }
}

/// A type that can convert a given data type into a representation.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
protocol ParseableFormatStyle : FormatStyle {
  associatedtype Strategy : ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput
  /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
  var parseStrategy: Self.Strategy { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle {
  static var number: Decimal.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle.Percent {
  static var percent: Decimal.FormatStyle.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle.Currency {
  static func currency(code: String) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Date.FormatStyle {
  static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == PersonNameComponents.FormatStyle {
  static func name(style: PersonNameComponents.FormatStyle.Style) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Date.ISO8601FormatStyle {
  static var iso8601: Date.ISO8601FormatStyle { get }
}

@available(macOS 10.11, iOS 9.0, *)
struct PersonNameComponents : ReferenceConvertible, Hashable, Equatable {
  typealias ReferenceType = NSPersonNameComponents
  init()
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  init(namePrefix: String? = nil, givenName: String? = nil, middleName: String? = nil, familyName: String? = nil, nameSuffix: String? = nil, nickname: String? = nil, phoneticRepresentation: PersonNameComponents? = nil)
  var namePrefix: String?
  var givenName: String?
  var middleName: String?
  var familyName: String?
  var nameSuffix: String?
  var nickname: String?
  var phoneticRepresentation: PersonNameComponents?
  func hash(into hasher: inout Hasher)
  @available(macOS 10.11, iOS 9.0, *)
  static func == (lhs: PersonNameComponents, rhs: PersonNameComponents) -> Bool
  var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {
  struct FormatStyle : FormatStyle {
    var style: PersonNameComponents.FormatStyle.Style
    var locale: Locale
    var attributed: PersonNameComponents.AttributedStyle { get }
    init(style: PersonNameComponents.FormatStyle.Style = .medium, locale: Locale = .autoupdatingCurrent)
    func locale(_ locale: Locale) -> PersonNameComponents.FormatStyle
    func format(_ value: PersonNameComponents) -> String
    enum Style : Int, Codable, Hashable {
      case short
      case medium
      case long
      case abbreviated
      init?(rawValue: Int)
      typealias RawValue = Int
      var rawValue: Int { get }
    }
    func hash(into hasher: inout Hasher)
    static func == (a: PersonNameComponents.FormatStyle, b: PersonNameComponents.FormatStyle) -> Bool
    typealias FormatInput = PersonNameComponents
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct AttributedStyle : FormatStyle {
    var style: PersonNameComponents.FormatStyle.Style
    var locale: Locale
    init(style: PersonNameComponents.FormatStyle.Style = .medium, locale: Locale = .autoupdatingCurrent)
    func format(_ value: PersonNameComponents) -> AttributedString
    func locale(_ locale: Locale) -> PersonNameComponents.AttributedStyle
    func hash(into hasher: inout Hasher)
    static func == (a: PersonNameComponents.AttributedStyle, b: PersonNameComponents.AttributedStyle) -> Bool
    typealias FormatInput = PersonNameComponents
    typealias FormatOutput = AttributedString
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {
  struct ParseStrategy : ParseStrategy {
    init()
    func parse(_ value: String) throws -> PersonNameComponents
    func hash(into hasher: inout Hasher)
    static func == (a: PersonNameComponents.ParseStrategy, b: PersonNameComponents.ParseStrategy) -> Bool
    typealias ParseInput = String
    typealias ParseOutput = PersonNameComponents
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {
  func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == PersonNameComponents
  func formatted() -> String
  init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput == PersonNameComponents
  init(_ value: String) throws
}

@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSPersonNameComponents
  static func _forceBridgeFromObjectiveC(_ personNameComponents: NSPersonNameComponents, result: inout PersonNameComponents?)
  static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: NSPersonNameComponents, result: inout PersonNameComponents?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSPersonNameComponents?) -> PersonNameComponents
  typealias _ObjectiveCType = NSPersonNameComponents
}

@available(macOS 10.11, iOS 9.0, *)
extension PersonNameComponents : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents.FormatStyle : ParseableFormatStyle {
  var parseStrategy: PersonNameComponents.ParseStrategy { get }
  typealias Strategy = PersonNameComponents.ParseStrategy
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents.FormatStyle.Style : RawRepresentable {
}

@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
struct PresentationIntent : Hashable, Codable, CustomDebugStringConvertible {
  var components: [PresentationIntent.IntentType]
  var count: Int { get }
  var debugDescription: String { get }
  enum Kind : Hashable, Codable, CustomDebugStringConvertible {
    case paragraph
    case header(level: Int)
    case orderedList
    case unorderedList
    case listItem(ordinal: Int)
    case codeBlock(languageHint: String?)
    case blockQuote
    case thematicBreak
    case table(columns: [PresentationIntent.TableColumn])
    case tableHeaderRow
    case tableRow(rowIndex: Int)
    case tableCell(columnIndex: Int)
    var debugDescription: String { get }
    init(from decoder: Decoder) throws
    func encode(to encoder: Encoder) throws
    func hash(into hasher: inout Hasher)
    static func == (a: PresentationIntent.Kind, b: PresentationIntent.Kind) -> Bool
    var hashValue: Int { get }
  }
  struct TableColumn : Hashable, Codable {
    enum Alignment : Int, Hashable, Codable {
      case left
      case center
      case right
      init?(rawValue: Int)
      typealias RawValue = Int
      var rawValue: Int { get }
    }
    var alignment: PresentationIntent.TableColumn.Alignment
    init(alignment: PresentationIntent.TableColumn.Alignment)
    func hash(into hasher: inout Hasher)
    static func == (a: PresentationIntent.TableColumn, b: PresentationIntent.TableColumn) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  struct IntentType : Hashable, Codable, CustomDebugStringConvertible {
    var kind: PresentationIntent.Kind
    var identity: Int
    var debugDescription: String { get }
    func hash(into hasher: inout Hasher)
    static func == (a: PresentationIntent.IntentType, b: PresentationIntent.IntentType) -> Bool
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  init(_ kind: PresentationIntent.Kind, identity: Int, parent: PresentationIntent? = nil)
  init(types: [PresentationIntent.IntentType])
  var isValid: Bool { get }
  var indentationLevel: Int { get }
  func hash(into hasher: inout Hasher)
  static func == (a: PresentationIntent, b: PresentationIntent) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension PresentationIntent : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> __NSPresentationIntent
  static func _forceBridgeFromObjectiveC(_ source: __NSPresentationIntent, result: inout PresentationIntent?)
  static func _conditionallyBridgeFromObjectiveC(_ source: __NSPresentationIntent, result: inout PresentationIntent?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: __NSPresentationIntent?) -> PresentationIntent
  typealias _ObjectiveCType = __NSPresentationIntent
}

@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
extension PresentationIntent.TableColumn.Alignment : RawRepresentable {
}

class PropertyListDecoder {
  /// Contextual user-provided information for use during decoding.
  var userInfo: [CodingUserInfoKey : Any]
  /// Initializes `self` with default strategies.
  init()
  /// Decodes a top-level value of the given type from the given property list representation.
  ///
  /// - parameter type: The type of the value to decode.
  /// - parameter data: The data to decode from.
  /// - returns: A value of the requested type.
  /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not a valid property list.
  /// - throws: An error if any value throws an error during decoding.
  func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Decodable
  /// Decodes a top-level value of the given type from the given property list representation.
  ///
  /// - parameter type: The type of the value to decode.
  /// - parameter data: The data to decode from.
  /// - parameter format: The parsed property list format.
  /// - returns: A value of the requested type along with the detected format of the property list.
  /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not a valid property list.
  /// - throws: An error if any value throws an error during decoding.
  func decode<T>(_ type: T.Type, from data: Data, format: inout PropertyListSerialization.PropertyListFormat) throws -> T where T : Decodable
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListDecoder : TopLevelDecoder {
  typealias Input = Data
}

class PropertyListEncoder {
  /// The output format to write the property list data in. Defaults to `.binary`.
  var outputFormat: PropertyListSerialization.PropertyListFormat
  /// Contextual user-provided information for use during encoding.
  var userInfo: [CodingUserInfoKey : Any]
  /// Initializes `self` with default strategies.
  init()
  /// Encodes the given top-level value and returns its property list representation.
  ///
  /// - parameter value: The value to encode.
  /// - returns: A new `Data` value containing the encoded property list data.
  /// - throws: `EncodingError.invalidValue` if a non-conforming floating-point value is encountered during encoding, and the encoding strategy is `.throw`.
  /// - throws: An error if any value throws an error during encoding.
  func encode<Value>(_ value: Value) throws -> Data where Value : Encodable
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListEncoder : TopLevelEncoder {
  typealias Output = Data
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
typealias Published = Published

/// Describes an error that may be recoverable by presenting several
/// potential recovery options to the user.
protocol RecoverableError : Error {
  /// Provides a set of possible recovery options to present to the user.
  var recoveryOptions: [String] { get }
  /// Attempt to recover from this error when the user selected the
  /// option at the given index. This routine must call handler and
  /// indicate whether recovery was successful (or not).
  ///
  /// This entry point is used for recovery of errors handled at a
  /// "document" granularity, that do not affect the entire
  /// application.
  func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)
  /// Attempt to recover from this error when the user selected the
  /// option at the given index. Returns true to indicate
  /// successful recovery, and false otherwise.
  ///
  /// This entry point is used for recovery of errors handled at
  /// the "application" granularity, where nothing else in the
  /// application can proceed until the attempted error recovery
  /// completes.
  func attemptRecovery(optionIndex recoveryOptionIndex: Int) -> Bool
}

extension RecoverableError {
  /// Default implementation that uses the application-model recovery
  /// mechanism (``attemptRecovery(optionIndex:)``) to implement
  /// document-modal recovery.
  func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)
}

/// Decorates types which are backed by a Foundation reference type.
///
/// All `ReferenceConvertible` types are hashable, equatable, and provide description functions.
protocol ReferenceConvertible : CustomDebugStringConvertible, CustomStringConvertible, Hashable, _ObjectiveCBridgeable {
  associatedtype ReferenceType : NSObject, NSCopying
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup struct ScopedAttributeContainer<S> where S : AttributeScope {
  subscript<T>(dynamicMember keyPath: KeyPath<S, T>) -> T.Value? where T : AttributedStringKey
}

/// A comparison algorithm for a given type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
protocol SortComparator : Hashable {
  /// The type that the `SortComparator` provides a comparison for.
  associatedtype Compared
  /// The relative ordering of lhs, and rhs.
  ///
  /// The result of comparisons should be flipped if the current `order`
  /// is `reverse`.
  ///
  /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
  /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
  /// `.orderedDescending`, then `compare(rhs, lhs)` must be
  /// `.orderedAscending`.
  ///
  /// - Parameters:
  ///     - lhs: A value to compare.
  ///     - rhs: A value to compare.
  func compare(_ lhs: Self.Compared, _ rhs: Self.Compared) -> ComparisonResult
  /// If the `SortComparator`s resulting order is forward or reverse.
  var order: SortOrder { get set }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SortComparator where Self == String.Comparator {
  /// Compares `String`s as compared by the Finder.
  ///
  /// Uses a localized, numeric comparison in the current locale.
  ///
  /// The default `String.Comparator` used in `String` comparisons.
  static var localizedStandard: String.Comparator { get }
  /// Compares `String`s using a localized comparison in the current
  /// locale.
  static var localized: String.Comparator { get }
}

/// A serializable description of how to sort numeric and `String` types.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
struct SortDescriptor<Compared> : SortComparator, Codable {
  var order: SortOrder
  /// Creates a `SortDescriptor` that orders values based on a `Bool`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Bool>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Bool?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Bool?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Double`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Double>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Double?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Double?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Float`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Float>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Float?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Float?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int8`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int8>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int8?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int8?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int16`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int16>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int16?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int16?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int32`
  /// property
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int32>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int32?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int32?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int64`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int64>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int64?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int64?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Int?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Int?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt8`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt8>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt8?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt8?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt16`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt16>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt16?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt16?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt32`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt32>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt32?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt32?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt64`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt64>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt64?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt64?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UInt?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UInt?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Date`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Date>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `Date?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, Date?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UUID`
  /// property.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UUID>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values based on a `UUID?`
  /// property.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for the comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, UUID?>, order: SortOrder = .forward) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values using the given
  /// standard string comparator.
  ///
  /// `comparator.order` is used for the initial `order` of the
  /// created `SortDescriptor`.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for comparison.
  ///   - comparator: The standard string comparator to use for comparison.
  init(_ keyPath: KeyPath<Compared, String>, comparator: String.StandardComparator = .localizedStandard) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders optional values using the given
  /// standard string comparator.
  ///
  /// `comparator.order` is used for the initial `order` of the
  /// created `SortDescriptor`.
  ///
  ///  The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for comparison.
  ///   - comparator: The standard string comparator to use for comparison.
  init(_ keyPath: KeyPath<Compared, String?>, comparator: String.StandardComparator = .localizedStandard) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders values using the given
  /// standard string comparator with the given initial order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for comparison.
  ///   - comparator: The standard string comparator to use for comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, String>, comparator: String.StandardComparator = .localizedStandard, order: SortOrder) where Compared : NSObject
  /// Creates a `SortDescriptor` that orders optional values using the given
  /// standard string comparator with the given initial order.
  ///
  /// The resulting `SortDescriptor` orders `nil` values first when in
  /// `forward` order.
  ///
  /// - Parameters:
  ///   - keyPath: The key path to the field to use for comparison.
  ///   - comparator: The standard string comparator to use for comparison.
  ///   - order: The initial order to use for comparison.
  init(_ keyPath: KeyPath<Compared, String?>, comparator: String.StandardComparator = .localizedStandard, order: SortOrder) where Compared : NSObject
  /// Creates a `SortDescriptor` describing the same sort as the
  /// `NSSortDescriptor` over the given `Compared` type.
  ///
  /// Returns `nil` if there is no `SortDescriptor` equivalent to the given
  /// `NSSortDescriptor`, or if the `NSSortDescriptor`s selector is not one of
  /// the standard string comparison algorithms, or `compare(_:)`.
  ///
  /// The comparison for the created `SortDescriptor` uses the
  /// `NSSortDescriptor`s associated selector directly, so in cases where
  /// using the `NSSortDescriptor`s comparison would crash, the
  /// `SortDescriptor`s comparison will as well.
  ///
  /// - Parameters:
  ///     - descriptor: The `NSSortDescriptor` to convert.
  ///     - comparedType: The type the resulting `SortDescriptor` compares.
  init?(_ descriptor: NSSortDescriptor, comparing comparedType: Compared.Type) where Compared : NSObject
  func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult
  func hash(into hasher: inout Hasher)
  static func == (a: SortDescriptor<Compared>, b: SortDescriptor<Compared>) -> Bool
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
  typealias Compared = Compared
}

/// The orderings that sorts can be performed with.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen enum SortOrder : Hashable, Codable {
  /// The ordering where if compare(a, b) == .orderedAscending,
  /// a is placed before b.
  case forward
  /// The ordering where if compare(a, b) == .orderedAscending,
  /// a is placed after b.
  case reverse
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
  static func == (a: SortOrder, b: SortOrder) -> Bool
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SortOrder : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
struct StringStyle : FormatStyle {
  func format(_ value: String) -> String
  func hash(into hasher: inout Hasher)
  static func == (a: StringStyle, b: StringStyle) -> Bool
  typealias FormatInput = String
  typealias FormatOutput = String
  func encode(to encoder: Encoder) throws
  var hashValue: Int { get }
  init(from decoder: Decoder) throws
}

/**
 `TimeZone` defines the behavior of a time zone. Time zone values represent geopolitical regions. Consequently, these values have names for these regions. Time zone values also represent a temporal offset, either plus or minus, from Greenwich Mean Time (GMT) and an abbreviation (such as PST for Pacific Standard Time).
 
 `TimeZone` provides two static functions to get time zone values: `current` and `autoupdatingCurrent`. The `autoupdatingCurrent` time zone automatically tracks updates made by the user.
 
 Note that time zone database entries such as "America/Los_Angeles" are IDs, not names. An example of a time zone name is "Pacific Daylight Time". Although many `TimeZone` functions include the word "name", they refer to IDs.
 
 Cocoa does not provide any API to change the time zone of the computer, or of other applications.
 */
struct TimeZone : Hashable, Equatable, ReferenceConvertible {
  typealias ReferenceType = NSTimeZone
  /// The time zone currently used by the system.
  static var current: TimeZone { get }
  /// The time zone currently used by the system, automatically updating to the user's current preference.
  ///
  /// If this time zone is mutated, then it no longer tracks the system time zone.
  ///
  /// The autoupdating time zone only compares equal to itself.
  static var autoupdatingCurrent: TimeZone { get }
  /// Returns a time zone initialized with a given identifier.
  ///
  /// An example identifier is "America/Los_Angeles".
  ///
  /// If `identifier` is an unknown identifier, then returns `nil`.
  init?(identifier: __shared String)
  @available(*, unavailable, renamed: "init(secondsFromGMT:)")
  init(forSecondsFromGMT seconds: Int)
  /// Returns a time zone initialized with a specific number of seconds from GMT.
  ///
  /// Time zones created with this never have daylight savings and the offset is constant no matter the date. The identifier and abbreviation do NOT follow the POSIX convention (of minutes-west).
  ///
  /// - parameter seconds: The number of seconds from GMT.
  /// - returns: A time zone, or `nil` if a valid time zone could not be created from `seconds`.
  init?(secondsFromGMT seconds: Int)
  /// Returns a time zone identified by a given abbreviation.
  ///
  /// In general, you are discouraged from using abbreviations except for unique instances such as "GMT". Time Zone abbreviations are not standardized and so a given abbreviation may have multiple meanings--for example, "EST" refers to Eastern Time in both the United States and Australia
  ///
  /// - parameter abbreviation: The abbreviation for the time zone.
  /// - returns: A time zone identified by abbreviation determined by resolving the abbreviation to an identifier using the abbreviation dictionary and then returning the time zone for that identifier. Returns `nil` if there is no match for abbreviation.
  init?(abbreviation: __shared String)
  @available(*, unavailable, renamed: "identifier")
  var name: String { get }
  /// The geopolitical region identifier that identifies the time zone.
  var identifier: String { get }
  @available(*, unavailable, message: "use the identifier instead")
  var data: Data { get }
  /// The current difference in seconds between the time zone and Greenwich Mean Time.
  ///
  /// - parameter date: The date to use for the calculation. The default value is the current date.
  func secondsFromGMT(for date: Date = Date()) -> Int
  /// Returns the abbreviation for the time zone at a given date.
  ///
  /// Note that the abbreviation may be different at different dates. For example, during daylight saving time the US/Eastern time zone has an abbreviation of "EDT." At other times, its abbreviation is "EST."
  /// - parameter date: The date to use for the calculation. The default value is the current date.
  func abbreviation(for date: Date = Date()) -> String?
  /// Returns a Boolean value that indicates whether the receiver uses daylight saving time at a given date.
  ///
  /// - parameter date: The date to use for the calculation. The default value is the current date.
  func isDaylightSavingTime(for date: Date = Date()) -> Bool
  /// Returns the daylight saving time offset for a given date.
  ///
  /// - parameter date: The date to use for the calculation. The default value is the current date.
  func daylightSavingTimeOffset(for date: Date = Date()) -> TimeInterval
  /// Returns the next daylight saving time transition after a given date.
  ///
  /// - parameter date: A date.
  /// - returns: The next daylight saving time transition after `date`. Depending on the time zone, this function may return a change of the time zone's offset from GMT. Returns `nil` if the time zone of the receiver does not observe daylight savings time as of `date`.
  func nextDaylightSavingTimeTransition(after date: Date) -> Date?
  /// Returns an array of strings listing the identifier of all the time zones known to the system.
  static var knownTimeZoneIdentifiers: [String] { get }
  /// Returns the mapping of abbreviations to time zone identifiers.
  static var abbreviationDictionary: [String : String]
  /// Returns the time zone data version.
  static var timeZoneDataVersion: String { get }
  /// Returns the date of the next (after the current instant) daylight saving time transition for the time zone. Depending on the time zone, the value of this property may represent a change of the time zone's offset from GMT. Returns `nil` if the time zone does not currently observe daylight saving time.
  var nextDaylightSavingTimeTransition: Date? { get }
  @available(*, unavailable, renamed: "localizedName(for:locale:)")
  func localizedName(_ style: NSTimeZone.NameStyle, locale: Locale?) -> String?
  /// Returns the name of the receiver localized for a given locale.
  func localizedName(for style: NSTimeZone.NameStyle, locale: Locale?) -> String?
  func hash(into hasher: inout Hasher)
  static func == (lhs: TimeZone, rhs: TimeZone) -> Bool
  var hashValue: Int { get }
}

extension TimeZone : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var customMirror: Mirror { get }
  var description: String { get }
  var debugDescription: String { get }
}

extension TimeZone : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSTimeZone
  static func _forceBridgeFromObjectiveC(_ input: NSTimeZone, result: inout TimeZone?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSTimeZone, result: inout TimeZone?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSTimeZone?) -> TimeZone
  typealias _ObjectiveCType = NSTimeZone
}

extension TimeZone : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/**
 A URL is a type that can potentially contain the location of a resource on a remote server, the path of a local file on disk, or even an arbitrary piece of encoded data.
 
 You can construct URLs and access their parts. For URLs that represent local files, you can also manipulate properties of those files directly, such as changing the file's last modification date. Finally, you can pass URLs to other APIs to retrieve the contents of those URLs. For example, you can use the URLSession classes to access the contents of remote resources, as described in URL Session Programming Guide.
 
 URLs are the preferred way to refer to local files. Most objects that read data from or write data to a file have methods that accept a URL instead of a pathname as the file reference. For example, you can get the contents of a local file URL as `String` by calling `func init(contentsOf:encoding) throws`, or as a `Data` by calling `func init(contentsOf:options) throws`.
*/
struct URL : ReferenceConvertible, Equatable {
  typealias ReferenceType = NSURL
  typealias BookmarkResolutionOptions = NSURL.BookmarkResolutionOptions
  typealias BookmarkCreationOptions = NSURL.BookmarkCreationOptions
  /// Initialize with string.
  ///
  /// Returns `nil` if a `URL` cannot be formed with the string (for example, if the string contains characters that are illegal in a URL, or is an empty string).
  init?(string: __shared String)
  /// Initialize with string, relative to another URL.
  ///
  /// Returns `nil` if a `URL` cannot be formed with the string (for example, if the string contains characters that are illegal in a URL, or is an empty string).
  init?(string: __shared String, relativeTo url: __shared URL?)
  /// Initializes a newly created file URL referencing the local file or directory at path, relative to a base URL.
  ///
  /// If an empty string is used for the path, then the path is assumed to be ".".
  /// - note: This function avoids an extra file system access to check if the file URL is a directory. You should use it if you know the answer already.
  @available(macOS 10.11, iOS 9.0, *)
  init(fileURLWithPath path: __shared String, isDirectory: Bool, relativeTo base: __shared URL?)
  /// Initializes a newly created file URL referencing the local file or directory at path, relative to a base URL.
  ///
  /// If an empty string is used for the path, then the path is assumed to be ".".
  @available(macOS 10.11, iOS 9.0, *)
  init(fileURLWithPath path: __shared String, relativeTo base: __shared URL?)
  /// Initializes a newly created file URL referencing the local file or directory at path.
  ///
  /// If an empty string is used for the path, then the path is assumed to be ".".
  /// - note: This function avoids an extra file system access to check if the file URL is a directory. You should use it if you know the answer already.
  init(fileURLWithPath path: __shared String, isDirectory: Bool)
  /// Initializes a newly created file URL referencing the local file or directory at path.
  ///
  /// If an empty string is used for the path, then the path is assumed to be ".".
  init(fileURLWithPath path: __shared String)
  /// Initializes a newly created URL using the contents of the given data, relative to a base URL.
  ///
  /// If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected. If the URL cannot be formed then this will return nil.
  @available(macOS 10.11, iOS 9.0, *)
  init?(dataRepresentation: __shared Data, relativeTo url: __shared URL?, isAbsolute: Bool = false)
  @available(swift, obsoleted: 4.2)
  init?(resolvingBookmarkData data: __shared Data, options: URL.BookmarkResolutionOptions = [], relativeTo url: __shared URL? = nil, bookmarkDataIsStale: inout Bool) throws
  @available(swift 4.2)
  init(resolvingBookmarkData data: __shared Data, options: URL.BookmarkResolutionOptions = [], relativeTo url: __shared URL? = nil, bookmarkDataIsStale: inout Bool) throws
  @available(macOS 10.10, iOS 8.0, *)
  init(resolvingAliasFileAt url: __shared URL, options: URL.BookmarkResolutionOptions = []) throws
  /// Initializes a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Bool, relativeTo baseURL: __shared URL?)
  func hash(into hasher: inout Hasher)
  /// Returns the data representation of the URL's relativeString. 
  ///
  /// If the URL was initialized with `init?(dataRepresentation:relativeTo:isAbsolute:)`, the data representation returned are the same bytes as those used at initialization; otherwise, the data representation returned are the bytes of the `relativeString` encoded with UTF8 string encoding.
  @available(macOS 10.11, iOS 9.0, *)
  var dataRepresentation: Data { get }
  /// Returns the absolute string for the URL.
  var absoluteString: String { get }
  /// The relative portion of a URL.
  ///
  /// If `baseURL` is nil, or if the receiver is itself absolute, this is the same as `absoluteString`.
  var relativeString: String { get }
  /// Returns the base URL.
  ///
  /// If the URL is itself absolute, then this value is nil.
  var baseURL: URL? { get }
  /// Returns the absolute URL.
  ///
  /// If the URL is itself absolute, this will return self.
  var absoluteURL: URL { get }
  /// Returns the scheme of the URL.
  var scheme: String? { get }
  /// Returns true if the scheme is `file:`.
  var isFileURL: Bool { get }
  @available(*, unavailable, message: "Use `path`, `query`, and `fragment` instead")
  var resourceSpecifier: String { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the host component of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var host: String? { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the port component of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var port: Int? { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the user component of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var user: String? { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the password component of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var password: String? { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the path component of the URL; otherwise it returns an empty string.
  ///
  /// If the URL contains a parameter string, it is appended to the path with a `;`.
  /// - note: This function will resolve against the base `URL`.
  /// - returns: The path, or an empty string if the URL has an empty path.
  var path: String { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the relative path of the URL; otherwise it returns nil.
  ///
  /// This is the same as path if baseURL is nil.
  /// If the URL contains a parameter string, it is appended to the path with a `;`.
  ///
  /// - note: This function will resolve against the base `URL`.
  /// - returns: The relative path, or an empty string if the URL has an empty path.
  var relativePath: String { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the fragment component of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var fragment: String? { get }
  @available(*, unavailable, message: "use the 'path' property")
  var parameterString: String? { get }
  /// If the URL conforms to RFC 1808 (the most common form of URL), returns the query of the URL; otherwise it returns nil.
  ///
  /// - note: This function will resolve against the base `URL`.
  var query: String? { get }
  /// Returns true if the URL path represents a directory.
  @available(macOS 10.11, iOS 9.0, *)
  var hasDirectoryPath: Bool { get }
  /// Passes the URL's path in file system representation to `block`. 
  /// 
  /// File system representation is a null-terminated C string with canonical UTF-8 encoding.
  /// - note: The pointer is not valid outside the context of the block.
  @available(macOS 10.9, iOS 7.0, *)
  func withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType
  /// Returns the path components of the URL, or an empty array if the path is an empty string.
  var pathComponents: [String] { get }
  /// Returns the last path component of the URL, or an empty string if the path is an empty string.
  var lastPathComponent: String { get }
  /// Returns the path extension of the URL, or an empty string if the path is an empty string.
  var pathExtension: String { get }
  /// Returns a URL constructed by appending the given path component to self.
  ///
  /// - parameter pathComponent: The path component to add.
  /// - parameter isDirectory: If `true`, then a trailing `/` is added to the resulting path.
  func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URL
  /// Returns a URL constructed by appending the given path component to self.
  ///
  /// - note: This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing `/`. If you know in advance that the path component is a directory or not, then use `func appendingPathComponent(_:isDirectory:)`.
  /// - parameter pathComponent: The path component to add.
  func appendingPathComponent(_ pathComponent: String) -> URL
  /// Returns a URL constructed by removing the last path component of self.
  ///
  /// This function may either remove a path component or append `/..`.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will return the URL unchanged.
  func deletingLastPathComponent() -> URL
  /// Returns a URL constructed by appending the given path extension to self.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will return the URL unchanged.
  ///
  /// Certain special characters (for example, Unicode Right-To-Left marks) cannot be used as path extensions. If any of those are contained in `pathExtension`, the function will return the URL unchanged.
  /// - parameter pathExtension: The extension to append.
  func appendingPathExtension(_ pathExtension: String) -> URL
  /// Returns a URL constructed by removing any path extension.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will return the URL unchanged.
  func deletingPathExtension() -> URL
  /// Appends a path component to the URL.
  ///
  /// - parameter pathComponent: The path component to add.
  /// - parameter isDirectory: Use `true` if the resulting path is a directory.
  mutating func appendPathComponent(_ pathComponent: String, isDirectory: Bool)
  /// Appends a path component to the URL.
  ///
  /// - note: This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing `/`. If you know in advance that the path component is a directory or not, then use `func appendingPathComponent(_:isDirectory:)`.
  /// - parameter pathComponent: The path component to add.
  mutating func appendPathComponent(_ pathComponent: String)
  /// Appends the given path extension to self.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
  /// Certain special characters (for example, Unicode Right-To-Left marks) cannot be used as path extensions. If any of those are contained in `pathExtension`, the function will return the URL unchanged.
  /// - parameter pathExtension: The extension to append.
  mutating func appendPathExtension(_ pathExtension: String)
  /// Returns a URL constructed by removing the last path component of self.
  ///
  /// This function may either remove a path component or append `/..`.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
  mutating func deleteLastPathComponent()
  /// Returns a URL constructed by removing any path extension.
  ///
  /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
  mutating func deletePathExtension()
  /// Returns a `URL` with any instances of ".." or "." removed from its path.
  var standardized: URL { get }
  /// Standardizes the path of a file URL.
  ///
  /// If the `isFileURL` is false, this method does nothing.
  mutating func standardize()
  /// Standardizes the path of a file URL.
  ///
  /// If the `isFileURL` is false, this method returns `self`.
  var standardizedFileURL: URL { get }
  /// Resolves any symlinks in the path of a file URL.
  ///
  /// If the `isFileURL` is false, this method returns `self`.
  func resolvingSymlinksInPath() -> URL
  /// Resolves any symlinks in the path of a file URL.
  ///
  /// If the `isFileURL` is false, this method does nothing.
  mutating func resolveSymlinksInPath()
  /// Returns whether the URL's resource exists and is reachable. 
  ///
  /// This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. This method is currently applicable only to URLs for file system resources. For other URL types, `false` is returned.
  func checkResourceIsReachable() throws -> Bool
  /// Returns whether the promised item URL's resource exists and is reachable.
  ///
  /// This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. This method is currently applicable only to URLs for file system resources. For other URL types, `false` is returned.
  @available(macOS 10.10, iOS 8.0, *)
  func checkPromisedItemIsReachable() throws -> Bool
  /// Sets the resource value identified by a given resource key.
  /// 
  /// This method writes the new resource values out to the backing store. Attempts to set a read-only resource property or to set a resource property not supported by the resource are ignored and are not considered errors. This method is currently applicable only to URLs for file system resources.
  ///
  /// `URLResourceValues` keeps track of which of its properties have been set. Those values are the ones used by this function to determine which properties to write.
  mutating func setResourceValues(_ values: URLResourceValues) throws
  /// Return a collection of resource values identified by the given resource keys.
  ///
  /// This method first checks if the URL object already caches the resource value. If so, it returns the cached resource value to the caller. If not, then this method synchronously obtains the resource value from the backing store, adds the resource value to the URL object's cache, and returns the resource value to the caller. The type of the resource value varies by resource property (see resource key definitions). If this method does not throw and the resulting value in the `URLResourceValues` is populated with nil, it means the resource property is not available for the specified resource and no errors occurred when determining the resource property was not available. This method is currently applicable only to URLs for file system resources.
  ///
  /// When this function is used from the main thread, resource values cached by the URL (except those added as temporary properties) are removed the next time the main thread's run loop runs. `func removeCachedResourceValue(forKey:)` and `func removeAllCachedResourceValues()` also may be used to remove cached resource values.
  ///
  /// Only the values for the keys specified in `keys` will be populated.
  func resourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues
  /// Sets a temporary resource value on the URL object.
  ///
  /// Temporary resource values are for client use. Temporary resource values exist only in memory and are never written to the resource's backing store. Once set, a temporary resource value can be copied from the URL object with `func resourceValues(forKeys:)`. The values are stored in the loosely-typed `allValues` dictionary property.
  ///
  /// To remove a temporary resource value from the URL object, use `func removeCachedResourceValue(forKey:)`. Care should be taken to ensure the key that identifies a temporary resource value is unique and does not conflict with system defined keys (using reverse domain name notation in your temporary resource value keys is recommended). This method is currently applicable only to URLs for file system resources.
  mutating func setTemporaryResourceValue(_ value: Any, forKey key: URLResourceKey)
  /// Removes all cached resource values and all temporary resource values from the URL object.
  /// 
  /// This method is currently applicable only to URLs for file system resources.
  mutating func removeAllCachedResourceValues()
  /// Removes the cached resource value identified by a given resource value key from the URL object.
  /// 
  /// Removing a cached resource value may remove other cached resource values because some resource values are cached as a set of values, and because some resource values depend on other resource values (temporary resource values have no dependencies). This method is currently applicable only to URLs for file system resources.
  mutating func removeCachedResourceValue(forKey key: URLResourceKey)
  /// Get resource values from URLs of 'promised' items.
  ///
  /// A promised item is not guaranteed to have its contents in the file system until you use `FileCoordinator` to perform a coordinated read on its URL, which causes the contents to be downloaded or otherwise generated. Promised item URLs are returned by various APIs, including currently:
  ///     NSMetadataQueryUbiquitousDataScope
  ///     NSMetadataQueryUbiquitousDocumentsScope
  ///     A `FilePresenter` presenting the contents of the directory located by -URLForUbiquitousContainerIdentifier: or a subdirectory thereof
  ///
  /// The following methods behave identically to their similarly named methods above (`func resourceValues(forKeys:)`, etc.), except that they allow you to get resource values and check for presence regardless of whether the promised item's contents currently exist at the URL. You must use these APIs instead of the normal URL resource value APIs if and only if any of the following are true:
  ///     You are using a URL that you know came directly from one of the above APIs
  ///     You are inside the accessor block of a coordinated read or write that used NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly, NSFileCoordinatorWritingForDeleting, NSFileCoordinatorWritingForMoving, or NSFileCoordinatorWritingContentIndependentMetadataOnly
  ///
  /// Most of the URL resource value keys will work with these APIs. However, there are some that are tied to the item's contents that will not work, such as `contentAccessDateKey` or `generationIdentifierKey`. If one of these keys is used, the method will return a `URLResourceValues` value, but the value for that property will be nil.
  @available(macOS 10.10, iOS 8.0, *)
  func promisedItemResourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  func setResourceValue(_ value: AnyObject?, forKey key: URLResourceKey) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  func setResourceValues(_ keyedValues: [URLResourceKey : AnyObject]) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer<AnyObject?>, forKey key: URLResourceKey) throws
  func bookmarkData(options: URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Set<URLResourceKey>? = nil, relativeTo url: URL? = nil) throws -> Data
  /// Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data. If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available in the bookmark data.
  static func resourceValues(forKeys keys: Set<URLResourceKey>, fromBookmarkData data: Data) -> URLResourceValues?
  /// Creates an alias file on disk at a specified location with specified bookmark data. bookmarkData must have been created with the URLBookmarkCreationSuitableForBookmarkFile option. bookmarkFileURL must either refer to an existing file (which will be overwritten), or to location in an existing directory.
  static func writeBookmarkData(_ data: Data, to url: URL) throws
  /// Initializes and returns bookmark data derived from an alias file pointed to by a specified URL. If bookmarkFileURL refers to an alias file created prior to OS X v10.6 that contains Alias Manager information but no bookmark data, this method synthesizes bookmark data for the file.
  static func bookmarkData(withContentsOf url: URL) throws -> Data
  /// Given an NSURL created by resolving a bookmark data created with security scope, make the resource referenced by the url accessible to the process. When access to this resource is no longer needed the client must call stopAccessingSecurityScopedResource. Each call to startAccessingSecurityScopedResource must be balanced with a call to stopAccessingSecurityScopedResource (Note: this is not reference counted).
  @available(macOS 10.7, iOS 8.0, *)
  func startAccessingSecurityScopedResource() -> Bool
  /// Revokes the access granted to the url by a prior successful call to startAccessingSecurityScopedResource.
  @available(macOS 10.7, iOS 8.0, *)
  func stopAccessingSecurityScopedResource()
  static func == (lhs: URL, rhs: URL) -> Bool
  var hashValue: Int { get }
}

extension URL : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSURL
  static func _forceBridgeFromObjectiveC(_ source: NSURL, result: inout URL?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSURL, result: inout URL?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSURL?) -> URL
  typealias _ObjectiveCType = NSURL
}

extension URL : CustomStringConvertible, CustomDebugStringConvertible {
  var description: String { get }
  var debugDescription: String { get }
}

extension URL : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension URL : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension URL : _ExpressibleByFileReferenceLiteral {
  init(fileReferenceLiteralResourceName name: String)
}

extension URL {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct AsyncBytes : AsyncSequence {
    typealias Element = UInt8
    @frozen struct AsyncIterator : AsyncIteratorProtocol {
      @usableFromInline
      var buffer: _AsyncBytesBuffer
      @inlinable @inline(__always) mutating func next() async throws -> UInt8?
      typealias Element = UInt8
    }
    func makeAsyncIterator() -> URL.AsyncBytes.AsyncIterator
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var resourceBytes: URL.AsyncBytes { get }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var lines: AsyncLineSequence<URL.AsyncBytes> { get }
}

/// A structure designed to parse URLs based on RFC 3986 and to construct URLs from their constituent parts. 
/// 
/// Its behavior differs subtly from the `URL` struct, which conforms to older RFCs. However, you can easily obtain a `URL` based on the contents of a `URLComponents` or vice versa.
struct URLComponents : ReferenceConvertible, Hashable, Equatable {
  typealias ReferenceType = NSURLComponents
  /// Initialize with all components undefined.
  init()
  /// Initialize with the components of a URL.
  ///
  /// If resolvingAgainstBaseURL is `true` and url is a relative URL, the components of url.absoluteURL are used. If the url string from the URL is malformed, nil is returned.
  init?(url: __shared URL, resolvingAgainstBaseURL resolve: Bool)
  /// Initialize with a URL string.
  ///
  /// If the URLString is malformed, nil is returned.
  init?(string: __shared String)
  /// Returns a URL created from the NSURLComponents. 
  ///
  /// If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  var url: URL? { get }
  ///
  /// If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  func url(relativeTo base: URL?) -> URL?
  @available(macOS 10.10, iOS 8.0, *)
  var string: String? { get }
  /// The scheme subcomponent of the URL.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  /// Attempting to set the scheme with an invalid scheme string will cause an exception.
  var scheme: String?
  /// The user subcomponent of the URL.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  ///
  /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
  var user: String?
  /// The password subcomponent of the URL.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  ///
  /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
  var password: String?
  /// The host subcomponent.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  var host: String?
  /// The port subcomponent.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  /// Attempting to set a negative port number will cause a fatal error.
  var port: Int?
  /// The path subcomponent.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  var path: String
  /// The query subcomponent.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  var query: String?
  /// The fragment subcomponent.
  ///
  /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
  var fragment: String?
  /// The user subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlUserAllowed`).
  var percentEncodedUser: String?
  /// The password subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPasswordAllowed`).
  var percentEncodedPassword: String?
  /// The host subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlHostAllowed`).
  var percentEncodedHost: String?
  /// The path subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPathAllowed`).
  var percentEncodedPath: String
  /// The query subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlQueryAllowed`).
  var percentEncodedQuery: String?
  /// The fragment subcomponent, percent-encoded.
  ///
  /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlFragmentAllowed`).
  var percentEncodedFragment: String?
  /// Returns the character range of the scheme in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfScheme: Range<String.Index>? { get }
  /// Returns the character range of the user in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfUser: Range<String.Index>? { get }
  /// Returns the character range of the password in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfPassword: Range<String.Index>? { get }
  /// Returns the character range of the host in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfHost: Range<String.Index>? { get }
  /// Returns the character range of the port in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfPort: Range<String.Index>? { get }
  /// Returns the character range of the path in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfPath: Range<String.Index>? { get }
  /// Returns the character range of the query in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfQuery: Range<String.Index>? { get }
  /// Returns the character range of the fragment in the string returned by `var string`.
  ///
  /// If the component does not exist, nil is returned.
  /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  @available(macOS 10.11, iOS 9.0, *)
  var rangeOfFragment: Range<String.Index>? { get }
  /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string.
  ///
  /// Each `URLQueryItem` represents a single key-value pair,
  ///
  /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the `URLComponents` has an empty query component, returns an empty array. If the `URLComponents` has no query component, returns nil.
  ///
  /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. Passing an empty array sets the query component of the `URLComponents` to an empty string. Passing nil removes the query component of the `URLComponents`.
  ///
  /// - note: If a name-value pair in a query is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a `URLQueryItem` with a zero-length name and a nil value. If a query's name-value pair has nothing before the equals sign, you get a zero-length name. If a query's name-value pair has nothing after the equals sign, you get a zero-length value. If a query's name-value pair has no equals sign, the query name-value pair string is the name and you get a nil value.
  @available(macOS 10.10, iOS 8.0, *)
  var queryItems: [URLQueryItem]?
  /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string. Any percent-encoding in a query item name or value is retained
  ///
  /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. This property assumes the query item names and values are already correctly percent-encoded, and that the query item names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded query item or a query item name with the query item delimiter characters '&' and '=' will cause a `fatalError`.
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  var percentEncodedQueryItems: [URLQueryItem]?
  func hash(into hasher: inout Hasher)
  static func == (lhs: URLComponents, rhs: URLComponents) -> Bool
  var hashValue: Int { get }
}

extension URLComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension URLComponents : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSURLComponents
  static func _forceBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLComponents?) -> URLComponents
  typealias _ObjectiveCType = NSURLComponents
}

extension URLComponents : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

/// Describes errors in the URL error domain.
struct URLError : _BridgedStoredNSError {
  let _nsError: NSError
  init(_nsError error: NSError)
  static var errorDomain: String { get }
  var hashValue: Int { get }
  /// The error code itself.
  struct Code : RawRepresentable, Hashable, _ErrorCodeProtocol {
    typealias _ErrorType = URLError
    let rawValue: Int
    init(rawValue: Int)
    typealias RawValue = Int
  }
}

extension URLError {
  /// Reasons used by URLError to indicate why a background URLSessionTask was cancelled.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  enum BackgroundTaskCancelledReason : Int {
    case userForceQuitApplication
    case backgroundUpdatesDisabled
    case insufficientSystemResources
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
}

extension URLError {
  /// Reasons used by URLError to indicate that a URLSessionTask failed because of unsatisfiable network constraints.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  enum NetworkUnavailableReason : Int {
    case cellular
    case expensive
    case constrained
    init?(rawValue: Int)
    typealias RawValue = Int
    var rawValue: Int { get }
  }
}

extension URLError {
  /// The URL which caused a load to fail.
  var failingURL: URL? { get }
  /// The string for the URL which caused a load to fail.
  var failureURLString: String? { get }
  /// The state of a failed SSL handshake.
  var failureURLPeerTrust: SecTrust? { get }
  /// The reason why a background URLSessionTask was cancelled.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  var backgroundTaskCancelledReason: URLError.BackgroundTaskCancelledReason? { get }
  /// The reason why the network is unavailable when the task failed due to unsatisfiable network constraints.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  var networkUnavailableReason: URLError.NetworkUnavailableReason? { get }
  /// An opaque data blob to resume a failed download task.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  var downloadTaskResumeData: Data? { get }
}

extension URLError {
  static var unknown: URLError.Code { get }
  static var cancelled: URLError.Code { get }
  static var badURL: URLError.Code { get }
  static var timedOut: URLError.Code { get }
  static var unsupportedURL: URLError.Code { get }
  static var cannotFindHost: URLError.Code { get }
  static var cannotConnectToHost: URLError.Code { get }
  static var networkConnectionLost: URLError.Code { get }
  static var dnsLookupFailed: URLError.Code { get }
  static var httpTooManyRedirects: URLError.Code { get }
  static var resourceUnavailable: URLError.Code { get }
  static var notConnectedToInternet: URLError.Code { get }
  static var redirectToNonExistentLocation: URLError.Code { get }
  static var badServerResponse: URLError.Code { get }
  static var userCancelledAuthentication: URLError.Code { get }
  static var userAuthenticationRequired: URLError.Code { get }
  static var zeroByteResource: URLError.Code { get }
  static var cannotDecodeRawData: URLError.Code { get }
  static var cannotDecodeContentData: URLError.Code { get }
  static var cannotParseResponse: URLError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var appTransportSecurityRequiresSecureConnection: URLError.Code { get }
  static var fileDoesNotExist: URLError.Code { get }
  static var fileIsDirectory: URLError.Code { get }
  static var noPermissionsToReadFile: URLError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var dataLengthExceedsMaximum: URLError.Code { get }
  static var secureConnectionFailed: URLError.Code { get }
  static var serverCertificateHasBadDate: URLError.Code { get }
  static var serverCertificateUntrusted: URLError.Code { get }
  static var serverCertificateHasUnknownRoot: URLError.Code { get }
  static var serverCertificateNotYetValid: URLError.Code { get }
  static var clientCertificateRejected: URLError.Code { get }
  static var clientCertificateRequired: URLError.Code { get }
  static var cannotLoadFromNetwork: URLError.Code { get }
  static var cannotCreateFile: URLError.Code { get }
  static var cannotOpenFile: URLError.Code { get }
  static var cannotCloseFile: URLError.Code { get }
  static var cannotWriteToFile: URLError.Code { get }
  static var cannotRemoveFile: URLError.Code { get }
  static var cannotMoveFile: URLError.Code { get }
  static var downloadDecodingFailedMidStream: URLError.Code { get }
  static var downloadDecodingFailedToComplete: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var internationalRoamingOff: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var callIsActive: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var dataNotAllowed: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var requestBodyStreamExhausted: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionRequiresSharedContainer: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionInUseByAnotherProcess: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionWasDisconnected: URLError.Code { get }
}

extension URLError {
  @available(*, unavailable, renamed: "unknown")
  static var Unknown: URLError.Code { get }
  @available(*, unavailable, renamed: "cancelled")
  static var Cancelled: URLError.Code { get }
  @available(*, unavailable, renamed: "badURL")
  static var BadURL: URLError.Code { get }
  @available(*, unavailable, renamed: "timedOut")
  static var TimedOut: URLError.Code { get }
  @available(*, unavailable, renamed: "unsupportedURL")
  static var UnsupportedURL: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotFindHost")
  static var CannotFindHost: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotConnectToHost")
  static var CannotConnectToHost: URLError.Code { get }
  @available(*, unavailable, renamed: "networkConnectionLost")
  static var NetworkConnectionLost: URLError.Code { get }
  @available(*, unavailable, renamed: "dnsLookupFailed")
  static var DNSLookupFailed: URLError.Code { get }
  @available(*, unavailable, renamed: "httpTooManyRedirects")
  static var HTTPTooManyRedirects: URLError.Code { get }
  @available(*, unavailable, renamed: "resourceUnavailable")
  static var ResourceUnavailable: URLError.Code { get }
  @available(*, unavailable, renamed: "notConnectedToInternet")
  static var NotConnectedToInternet: URLError.Code { get }
  @available(*, unavailable, renamed: "redirectToNonExistentLocation")
  static var RedirectToNonExistentLocation: URLError.Code { get }
  @available(*, unavailable, renamed: "badServerResponse")
  static var BadServerResponse: URLError.Code { get }
  @available(*, unavailable, renamed: "userCancelledAuthentication")
  static var UserCancelledAuthentication: URLError.Code { get }
  @available(*, unavailable, renamed: "userAuthenticationRequired")
  static var UserAuthenticationRequired: URLError.Code { get }
  @available(*, unavailable, renamed: "zeroByteResource")
  static var ZeroByteResource: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotDecodeRawData")
  static var CannotDecodeRawData: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotDecodeContentData")
  static var CannotDecodeContentData: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotParseResponse")
  static var CannotParseResponse: URLError.Code { get }
  @available(*, unavailable, renamed: "appTransportSecurityRequiresSecureConnection")
  static var AppTransportSecurityRequiresSecureConnection: URLError.Code { get }
  @available(*, unavailable, renamed: "fileDoesNotExist")
  static var FileDoesNotExist: URLError.Code { get }
  @available(*, unavailable, renamed: "fileIsDirectory")
  static var FileIsDirectory: URLError.Code { get }
  @available(*, unavailable, renamed: "noPermissionsToReadFile")
  static var NoPermissionsToReadFile: URLError.Code { get }
  @available(*, unavailable, renamed: "dataLengthExceedsMaximum")
  static var DataLengthExceedsMaximum: URLError.Code { get }
  @available(*, unavailable, renamed: "secureConnectionFailed")
  static var SecureConnectionFailed: URLError.Code { get }
  @available(*, unavailable, renamed: "serverCertificateHasBadDate")
  static var ServerCertificateHasBadDate: URLError.Code { get }
  @available(*, unavailable, renamed: "serverCertificateUntrusted")
  static var ServerCertificateUntrusted: URLError.Code { get }
  @available(*, unavailable, renamed: "serverCertificateHasUnknownRoot")
  static var ServerCertificateHasUnknownRoot: URLError.Code { get }
  @available(*, unavailable, renamed: "serverCertificateNotYetValid")
  static var ServerCertificateNotYetValid: URLError.Code { get }
  @available(*, unavailable, renamed: "clientCertificateRejected")
  static var ClientCertificateRejected: URLError.Code { get }
  @available(*, unavailable, renamed: "clientCertificateRequired")
  static var ClientCertificateRequired: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotLoadFromNetwork")
  static var CannotLoadFromNetwork: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotCreateFile")
  static var CannotCreateFile: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotOpenFile")
  static var CannotOpenFile: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotCloseFile")
  static var CannotCloseFile: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotWriteToFile")
  static var CannotWriteToFile: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotRemoveFile")
  static var CannotRemoveFile: URLError.Code { get }
  @available(*, unavailable, renamed: "cannotMoveFile")
  static var CannotMoveFile: URLError.Code { get }
  @available(*, unavailable, renamed: "downloadDecodingFailedMidStream")
  static var DownloadDecodingFailedMidStream: URLError.Code { get }
  @available(*, unavailable, renamed: "downloadDecodingFailedToComplete")
  static var DownloadDecodingFailedToComplete: URLError.Code { get }
  @available(*, unavailable, renamed: "internationalRoamingOff")
  static var InternationalRoamingOff: URLError.Code { get }
  @available(*, unavailable, renamed: "callIsActive")
  static var CallIsActive: URLError.Code { get }
  @available(*, unavailable, renamed: "dataNotAllowed")
  static var DataNotAllowed: URLError.Code { get }
  @available(*, unavailable, renamed: "requestBodyStreamExhausted")
  static var RequestBodyStreamExhausted: URLError.Code { get }
  @available(*, unavailable, renamed: "backgroundSessionRequiresSharedContainer")
  static var BackgroundSessionRequiresSharedContainer: URLError.Code { get }
  @available(*, unavailable, renamed: "backgroundSessionInUseByAnotherProcess")
  static var BackgroundSessionInUseByAnotherProcess: URLError.Code { get }
  @available(*, unavailable, renamed: "backgroundSessionWasDisconnected")
  static var BackgroundSessionWasDisconnected: URLError.Code { get }
}

extension URLError.Code {
  static var unknown: URLError.Code { get }
  static var cancelled: URLError.Code { get }
  static var badURL: URLError.Code { get }
  static var timedOut: URLError.Code { get }
  static var unsupportedURL: URLError.Code { get }
  static var cannotFindHost: URLError.Code { get }
  static var cannotConnectToHost: URLError.Code { get }
  static var networkConnectionLost: URLError.Code { get }
  static var dnsLookupFailed: URLError.Code { get }
  static var httpTooManyRedirects: URLError.Code { get }
  static var resourceUnavailable: URLError.Code { get }
  static var notConnectedToInternet: URLError.Code { get }
  static var redirectToNonExistentLocation: URLError.Code { get }
  static var badServerResponse: URLError.Code { get }
  static var userCancelledAuthentication: URLError.Code { get }
  static var userAuthenticationRequired: URLError.Code { get }
  static var zeroByteResource: URLError.Code { get }
  static var cannotDecodeRawData: URLError.Code { get }
  static var cannotDecodeContentData: URLError.Code { get }
  static var cannotParseResponse: URLError.Code { get }
  @available(macOS 10.11, iOS 9.0, *)
  static var appTransportSecurityRequiresSecureConnection: URLError.Code { get }
  static var fileDoesNotExist: URLError.Code { get }
  static var fileIsDirectory: URLError.Code { get }
  static var noPermissionsToReadFile: URLError.Code { get }
  @available(macOS 10.5, iOS 2.0, *)
  static var dataLengthExceedsMaximum: URLError.Code { get }
  static var secureConnectionFailed: URLError.Code { get }
  static var serverCertificateHasBadDate: URLError.Code { get }
  static var serverCertificateUntrusted: URLError.Code { get }
  static var serverCertificateHasUnknownRoot: URLError.Code { get }
  static var serverCertificateNotYetValid: URLError.Code { get }
  static var clientCertificateRejected: URLError.Code { get }
  static var clientCertificateRequired: URLError.Code { get }
  static var cannotLoadFromNetwork: URLError.Code { get }
  static var cannotCreateFile: URLError.Code { get }
  static var cannotOpenFile: URLError.Code { get }
  static var cannotCloseFile: URLError.Code { get }
  static var cannotWriteToFile: URLError.Code { get }
  static var cannotRemoveFile: URLError.Code { get }
  static var cannotMoveFile: URLError.Code { get }
  static var downloadDecodingFailedMidStream: URLError.Code { get }
  static var downloadDecodingFailedToComplete: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var internationalRoamingOff: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var callIsActive: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var dataNotAllowed: URLError.Code { get }
  @available(macOS 10.7, iOS 3.0, *)
  static var requestBodyStreamExhausted: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionRequiresSharedContainer: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionInUseByAnotherProcess: URLError.Code { get }
  @available(macOS 10.10, iOS 8.0, *)
  static var backgroundSessionWasDisconnected: URLError.Code { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : Equatable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : Hashable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : RawRepresentable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : Equatable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : Hashable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : RawRepresentable {
}

/// A single name-value pair, for use with `URLComponents`.
@available(macOS 10.10, iOS 8.0, *)
struct URLQueryItem : ReferenceConvertible, Hashable, Equatable {
  typealias ReferenceType = NSURLQueryItem
  init(name: __shared String, value: __shared String?)
  var name: String
  var value: String?
  func hash(into hasher: inout Hasher)
  @available(macOS 10.10, iOS 8.0, *)
  static func == (lhs: URLQueryItem, rhs: URLQueryItem) -> Bool
  var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, *)
extension URLQueryItem : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, *)
extension URLQueryItem : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSURLQueryItem
  static func _forceBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLQueryItem?) -> URLQueryItem
  typealias _ObjectiveCType = NSURLQueryItem
}

struct URLRequest : ReferenceConvertible, Equatable, Hashable {
  typealias ReferenceType = NSURLRequest
  typealias CachePolicy = NSURLRequest.CachePolicy
  typealias NetworkServiceType = NSURLRequest.NetworkServiceType
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  typealias Attribution = NSURLRequest.Attribution
  /// Creates and initializes a URLRequest with the given URL and cache policy.
  /// - parameter: url The URL for the request. 
  /// - parameter: cachePolicy The cache policy for the request. Defaults to `.useProtocolCachePolicy`
  /// - parameter: timeoutInterval The timeout interval for the request. See the commentary for the `timeoutInterval` for more information on timeout intervals. Defaults to 60.0
  init(url: URL, cachePolicy: URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: TimeInterval = 60.0)
  /// The URL of the receiver.
  var url: URL?
  /// The cache policy of the receiver.
  var cachePolicy: URLRequest.CachePolicy
  /// Returns the timeout interval of the receiver.
  /// - discussion: The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  var timeoutInterval: TimeInterval
  /// The main document URL associated with this load.
  /// - discussion: This URL is used for the cookie "same domain as main
  /// document" policy, attributing this request as a sub-resource of a
  /// user-specified URL, and possibly other things in the future.
  var mainDocumentURL: URL?
  /// The URLRequest.NetworkServiceType associated with this request.
  /// - discussion: This will return URLRequest.NetworkServiceType.default for requests that have
  /// not explicitly set a networkServiceType
  @available(macOS 10.7, iOS 4.0, *)
  var networkServiceType: URLRequest.NetworkServiceType
  /// `true` if the receiver is allowed to use the built in cellular radios to
  /// satisfy the request, `false` otherwise.
  @available(macOS 10.8, iOS 6.0, *)
  var allowsCellularAccess: Bool
  /// `true` if the receiver is allowed to use an interface marked as expensive to
  /// satify the request, `false` otherwise.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  var allowsExpensiveNetworkAccess: Bool
  /// `true` if the receiver is allowed to use an interface marked as constrained to
  /// satify the request, `false` otherwise.
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  var allowsConstrainedNetworkAccess: Bool
  /// `true` if server endpoint is known to support HTTP/3. Enables QUIC racing
  /// without HTTP/3 service discovery. Defaults to `false`.
  /// The default may be `true` in a future OS update.
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  var assumesHTTP3Capable: Bool
  /// Set to indicate whether the user or developer specified the URL.
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  var attribution: URLRequest.Attribution
  /// The HTTP request method of the receiver.
  var httpMethod: String?
  /// A dictionary containing all the HTTP header fields of the
  /// receiver.
  var allHTTPHeaderFields: [String : String]?
  /// The value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// - parameter: field the header field name to use for the lookup (case-insensitive).
  func value(forHTTPHeaderField field: String) -> String?
  /// If a value was previously set for the given header
  /// field, that value is replaced with the given value. Note that, in
  /// keeping with the HTTP RFC, HTTP header field names are
  /// case-insensitive.
  mutating func setValue(_ value: String?, forHTTPHeaderField field: String)
  /// This method provides a way to add values to header
  /// fields incrementally. If a value was previously set for the given
  /// header field, the given value is appended to the previously-existing
  /// value. The appropriate field delimiter, a comma in the case of HTTP,
  /// is added by the implementation, and should not be added to the given
  /// value by the caller. Note that, in keeping with the HTTP RFC, HTTP
  /// header field names are case-insensitive.
  mutating func addValue(_ value: String, forHTTPHeaderField field: String)
  /// This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  var httpBody: Data?
  /// The stream is returned for examination only; it is
  /// not safe for the caller to manipulate the stream in any way.  Also
  /// note that the HTTPBodyStream and HTTPBody are mutually exclusive - only
  /// one can be set on a given request.  Also note that the body stream is
  /// preserved across copies, but is LOST when the request is coded via the 
  /// NSCoding protocol
  var httpBodyStream: InputStream?
  /// `true` if cookies will be sent with and set for this request; otherwise `false`.
  var httpShouldHandleCookies: Bool
  /// `true` if the receiver should transmit before the previous response
  /// is received.  `false` if the receiver should wait for the previous response
  /// before transmitting.
  @available(macOS 10.7, iOS 4.0, *)
  var httpShouldUsePipelining: Bool
  func hash(into hasher: inout Hasher)
  static func == (lhs: URLRequest, rhs: URLRequest) -> Bool
  var hashValue: Int { get }
}

extension URLRequest : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

extension URLRequest : _ObjectiveCBridgeable {
  static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSURLRequest
  static func _forceBridgeFromObjectiveC(_ input: NSURLRequest, result: inout URLRequest?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSURLRequest, result: inout URLRequest?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLRequest?) -> URLRequest
  typealias _ObjectiveCType = NSURLRequest
}

/**
 URLs to file system resources support the properties defined below. Note that not all property values will exist for all file system URLs. For example, if a file is located on a volume that does not support creation dates, it is valid to request the creation date property, but the returned value will be nil, and no error will be generated.
 
 Only the fields requested by the keys you pass into the `URL` function to receive this value will be populated. The others will return `nil` regardless of the underlying property on the file system.
 
 As a convenience, volume resource values can be requested from any file system URL. The value returned will reflect the property value for the volume on which the resource is located.
*/
struct URLResourceValues {
  init()
  /// A loosely-typed dictionary containing all keys and values.
  ///
  /// If you have set temporary keys or non-standard keys, you can find them in here.
  var allValues: [URLResourceKey : Any] { get }
  /// The resource name provided by the file system.
  var name: String?
  /// Localized or extension-hidden name as displayed to users.
  var localizedName: String? { get }
  /// True for regular files.
  var isRegularFile: Bool? { get }
  /// True for directories.
  var isDirectory: Bool? { get }
  /// True for symlinks.
  var isSymbolicLink: Bool? { get }
  /// True for the root directory of a volume.
  var isVolume: Bool? { get }
  /// True for packaged directories. 
  ///
  /// - note: You can only set or clear this property on directories; if you try to set this property on non-directory objects, the property is ignored. If the directory is a package for some other reason (extension type, etc), setting this property to false will have no effect.
  var isPackage: Bool?
  /// True if resource is an application.
  @available(macOS 10.11, iOS 9.0, *)
  var isApplication: Bool? { get }
  /// True for system-immutable resources.
  var isSystemImmutable: Bool? { get }
  /// True for user-immutable resources
  var isUserImmutable: Bool?
  /// True for resources normally not displayed to users.
  /// 
  /// - note: If the resource is a hidden because its name starts with a period, setting this property to false will not change the property.
  var isHidden: Bool?
  /// True for resources whose filename extension is removed from the localized name property.
  var hasHiddenExtension: Bool?
  /// The date the resource was created.
  var creationDate: Date?
  /// The date the resource was last accessed.
  var contentAccessDate: Date?
  /// The time the resource content was last modified.
  var contentModificationDate: Date?
  /// The time the resource's attributes were last modified.
  var attributeModificationDate: Date? { get }
  /// Number of hard links to the resource.
  var linkCount: Int? { get }
  /// The resource's parent directory, if any.
  var parentDirectory: URL? { get }
  /// URL of the volume on which the resource is stored.
  var volume: URL? { get }
  /// Uniform type identifier (UTI) for the resource.
  @available(macOS, introduced: 10.6, deprecated: 100000.0, message: "Use .contentType instead")
  @available(iOS, introduced: 4.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
  var typeIdentifier: String? { get }
  /// User-visible type or "kind" description.
  var localizedTypeDescription: String? { get }
  /// The label number assigned to the resource.
  var labelNumber: Int?
  /// The user-visible label text.
  var localizedLabel: String? { get }
  /// An identifier which can be used to compare two file system objects for equality using `isEqual`.
  ///
  /// Two object identifiers are equal if they have the same file system path or if the paths are linked to same inode on the same file system. This identifier is not persistent across system restarts.
  var fileResourceIdentifier: (NSCopying & NSSecureCoding & NSObjectProtocol)? { get }
  /// An identifier that can be used to identify the volume the file system object is on. 
  ///
  /// Other objects on the same volume will have the same volume identifier and can be compared using for equality using `isEqual`. This identifier is not persistent across system restarts.
  var volumeIdentifier: (NSCopying & NSSecureCoding & NSObjectProtocol)? { get }
  /// A 64-bit value assigned by APFS that identifies a file's content data stream. Only cloned files and their originals can have the same identifier.
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  var fileContentIdentifier: Int64? { get }
  /// The optimal block size when reading or writing this file's data, or nil if not available.
  var preferredIOBlockSize: Int? { get }
  /// True if this process (as determined by EUID) can read the resource.
  var isReadable: Bool? { get }
  /// True if this process (as determined by EUID) can write to the resource.
  var isWritable: Bool? { get }
  /// True if this process (as determined by EUID) can execute a file resource or search a directory resource.
  var isExecutable: Bool? { get }
  /// The file system object's security information encapsulated in a FileSecurity object.
  var fileSecurity: NSFileSecurity?
  /// True if resource should be excluded from backups, false otherwise.
  ///
  /// This property is only useful for excluding cache and other application support files which are not needed in a backup. Some operations commonly made to user documents will cause this property to be reset to false and so this property should not be used on user documents.
  var isExcludedFromBackup: Bool?
  /// The URL's path as a file system path.
  var path: String? { get }
  /// The URL's path as a canonical absolute file system path.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var canonicalPath: String? { get }
  /// True if this URL is a file system trigger directory. Traversing or opening a file system trigger will cause an attempt to mount a file system on the trigger directory.
  var isMountTrigger: Bool? { get }
  /// An opaque generation identifier which can be compared using `==` to determine if the data in a document has been modified.
  ///
  /// For URLs which refer to the same file inode, the generation identifier will change when the data in the file's data fork is changed (changes to extended attributes or other file system metadata do not change the generation identifier). For URLs which refer to the same directory inode, the generation identifier will change when direct children of that directory are added, removed or renamed (changes to the data of the direct children of that directory will not change the generation identifier). The generation identifier is persistent across system restarts. The generation identifier is tied to a specific document on a specific volume and is not transferred when the document is copied to another volume. This property is not supported by all volumes.
  @available(macOS 10.10, iOS 8.0, *)
  var generationIdentifier: (NSCopying & NSSecureCoding & NSObjectProtocol)? { get }
  /// The document identifier -- a value assigned by the kernel to a document (which can be either a file or directory) and is used to identify the document regardless of where it gets moved on a volume.
  ///
  /// The document identifier survives "safe save" operations; i.e it is sticky to the path it was assigned to (`replaceItem(at:,withItemAt:,backupItemName:,options:,resultingItem:) throws` is the preferred safe-save API). The document identifier is persistent across system restarts. The document identifier is not transferred when the file is copied. Document identifiers are only unique within a single volume. This property is not supported by all volumes.
  @available(macOS 10.10, iOS 8.0, *)
  var documentIdentifier: Int? { get }
  /// The date the resource was created, or renamed into or within its parent directory. Note that inconsistent behavior may be observed when this attribute is requested on hard-linked items. This property is not supported by all volumes.
  @available(macOS 10.10, iOS 8.0, *)
  var addedToDirectoryDate: Date? { get }
  /// True if the file may have extended attributes. False guarantees there are none.
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  var mayHaveExtendedAttributes: Bool? { get }
  /// True if the file can be deleted by the file system when asked to free space.
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  var isPurgeable: Bool? { get }
  /// True if the file has sparse regions.
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  var isSparse: Bool? { get }
  /// True for cloned files and their originals that may share all, some, or no data blocks.
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  var mayShareFileContent: Bool? { get }
  /// Returns the file system object type.
  var fileResourceType: URLFileResourceType? { get }
  /// The user-visible volume format.
  var volumeLocalizedFormatDescription: String? { get }
  /// Total volume capacity in bytes.
  var volumeTotalCapacity: Int? { get }
  /// Total free space in bytes.
  var volumeAvailableCapacity: Int? { get }
  /// Total available capacity in bytes for "Important" resources, including space expected to be cleared by purging non-essential and cached resources. "Important" means something that the user or application clearly expects to be present on the local system, but is ultimately replaceable. This would include items that the user has explicitly requested via the UI, and resources that an application requires in order to provide functionality.
  /// Examples: A video that the user has explicitly requested to watch but has not yet finished watching or an audio file that the user has requested to download.
  /// This value should not be used in determining if there is room for an irreplaceable resource. In the case of irreplaceable resources, always attempt to save the resource regardless of available capacity and handle failure as gracefully as possible.
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var volumeAvailableCapacityForImportantUsage: Int64? { get }
  /// Total available capacity in bytes for "Opportunistic" resources, including space expected to be cleared by purging non-essential and cached resources. "Opportunistic" means something that the user is likely to want but does not expect to be present on the local system, but is ultimately non-essential and replaceable. This would include items that will be created or downloaded without an explicit request from the user on the current device.
  /// Examples: A background download of a newly available episode of a TV series that a user has been recently watching, a piece of content explicitly requested on another device, and a new document saved to a network server by the current user from another device.
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var volumeAvailableCapacityForOpportunisticUsage: Int64? { get }
  /// Total number of resources on the volume.
  var volumeResourceCount: Int? { get }
  /// true if the volume format supports persistent object identifiers and can look up file system objects by their IDs.
  var volumeSupportsPersistentIDs: Bool? { get }
  /// true if the volume format supports symbolic links.
  var volumeSupportsSymbolicLinks: Bool? { get }
  /// true if the volume format supports hard links.
  var volumeSupportsHardLinks: Bool? { get }
  /// true if the volume format supports a journal used to speed recovery in case of unplanned restart (such as a power outage or crash). This does not necessarily mean the volume is actively using a journal. 
  var volumeSupportsJournaling: Bool? { get }
  /// true if the volume is currently using a journal for speedy recovery after an unplanned restart. 
  var volumeIsJournaling: Bool? { get }
  /// true if the volume format supports sparse files, that is, files which can have 'holes' that have never been written to, and thus do not consume space on disk. A sparse file may have an allocated size on disk that is less than its logical length.
  var volumeSupportsSparseFiles: Bool? { get }
  /// For security reasons, parts of a file (runs) that have never been written to must appear to contain zeroes. true if the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media. 
  var volumeSupportsZeroRuns: Bool? { get }
  /// true if the volume format treats upper and lower case characters in file and directory names as different. Otherwise an upper case character is equivalent to a lower case character, and you can't have two names that differ solely in the case of the characters. 
  var volumeSupportsCaseSensitiveNames: Bool? { get }
  /// true if the volume format preserves the case of file and directory names.  Otherwise the volume may change the case of some characters (typically making them all upper or all lower case). 
  var volumeSupportsCasePreservedNames: Bool? { get }
  /// true if the volume supports reliable storage of times for the root directory. 
  var volumeSupportsRootDirectoryDates: Bool? { get }
  /// true if the volume supports returning volume size values (`volumeTotalCapacity` and `volumeAvailableCapacity`).
  var volumeSupportsVolumeSizes: Bool? { get }
  /// true if the volume can be renamed. 
  var volumeSupportsRenaming: Bool? { get }
  /// true if the volume implements whole-file flock(2) style advisory locks, and the O_EXLOCK and O_SHLOCK flags of the open(2) call. 
  var volumeSupportsAdvisoryFileLocking: Bool? { get }
  /// true if the volume implements extended security (ACLs). 
  var volumeSupportsExtendedSecurity: Bool? { get }
  /// true if the volume should be visible via the GUI (i.e., appear on the Desktop as a separate volume). 
  var volumeIsBrowsable: Bool? { get }
  /// The largest file size (in bytes) supported by this file system, or nil if this cannot be determined. 
  var volumeMaximumFileSize: Int? { get }
  /// true if the volume's media is ejectable from the drive mechanism under software control. 
  var volumeIsEjectable: Bool? { get }
  /// true if the volume's media is removable from the drive mechanism. 
  var volumeIsRemovable: Bool? { get }
  /// true if the volume's device is connected to an internal bus, false if connected to an external bus, or nil if not available. 
  var volumeIsInternal: Bool? { get }
  /// true if the volume is automounted. Note: do not mistake this with the functionality provided by kCFURLVolumeSupportsBrowsingKey. 
  var volumeIsAutomounted: Bool? { get }
  /// true if the volume is stored on a local device. 
  var volumeIsLocal: Bool? { get }
  /// true if the volume is read-only. 
  var volumeIsReadOnly: Bool? { get }
  /// The volume's creation date, or nil if this cannot be determined. 
  var volumeCreationDate: Date? { get }
  /// The `URL` needed to remount a network volume, or nil if not available.
  var volumeURLForRemounting: URL? { get }
  /// The volume's persistent `UUID` as a string, or nil if a persistent `UUID` is not available for the volume.
  var volumeUUIDString: String? { get }
  /// The name of the volume 
  var volumeName: String?
  /// The user-presentable name of the volume 
  var volumeLocalizedName: String? { get }
  /// true if the volume is encrypted. 
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeIsEncrypted: Bool? { get }
  /// true if the volume is the root filesystem. 
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeIsRootFileSystem: Bool? { get }
  /// true if the volume supports transparent decompression of compressed files using decmpfs. 
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeSupportsCompression: Bool? { get }
  /// true if the volume supports clonefile(2).
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeSupportsFileCloning: Bool? { get }
  /// true if the volume supports renamex_np(2)'s RENAME_SWAP option.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeSupportsSwapRenaming: Bool? { get }
  /// true if the volume supports renamex_np(2)'s RENAME_EXCL option.
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  var volumeSupportsExclusiveRenaming: Bool? { get }
  /// true if the volume supports making files immutable with isUserImmutable or isSystemImmutable.
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  var volumeSupportsImmutableFiles: Bool? { get }
  /// true if the volume supports setting POSIX access permissions with fileSecurity.
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  var volumeSupportsAccessPermissions: Bool? { get }
  /// true if this item is synced to the cloud, false if it is only a local file. 
  var isUbiquitousItem: Bool? { get }
  /// true if this item has conflicts outstanding. 
  var ubiquitousItemHasUnresolvedConflicts: Bool? { get }
  /// true if data is being downloaded for this item. 
  var ubiquitousItemIsDownloading: Bool? { get }
  /// true if there is data present in the cloud for this item. 
  var ubiquitousItemIsUploaded: Bool? { get }
  /// true if data is being uploaded for this item. 
  var ubiquitousItemIsUploading: Bool? { get }
  /// returns the download status of this item.
  var ubiquitousItemDownloadingStatus: URLUbiquitousItemDownloadingStatus? { get }
  /// returns the error when downloading the item from iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h
  var ubiquitousItemDownloadingError: NSError? { get }
  /// returns the error when uploading the item to iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h
  var ubiquitousItemUploadingError: NSError? { get }
  /// returns whether a download of this item has already been requested with an API like `startDownloadingUbiquitousItem(at:) throws`.
  @available(macOS 10.10, iOS 8.0, *)
  var ubiquitousItemDownloadRequested: Bool? { get }
  /// returns the name of this item's container as displayed to users.
  @available(macOS 10.10, iOS 8.0, *)
  var ubiquitousItemContainerDisplayName: String? { get }
  /// true if the item is excluded from sync, which means it is locally on disk but won't be available on the server. An excluded item is no longer ubiquitous.
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  var ubiquitousItemIsExcludedFromSync: Bool?
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var ubiquitousItemIsShared: Bool? { get }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var ubiquitousSharedItemCurrentUserRole: URLUbiquitousSharedItemRole? { get }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var ubiquitousSharedItemCurrentUserPermissions: URLUbiquitousSharedItemPermissions? { get }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var ubiquitousSharedItemOwnerNameComponents: PersonNameComponents? { get }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  var ubiquitousSharedItemMostRecentEditorNameComponents: PersonNameComponents? { get }
  /// The protection level for this file
  @available(macOS 11.0, iOS 9.0, *)
  var fileProtection: URLFileProtection? { get }
  /// Total file size in bytes
  ///
  /// - note: Only applicable to regular files.
  var fileSize: Int? { get }
  /// Total size allocated on disk for the file in bytes (number of blocks times block size)
  ///
  /// - note: Only applicable to regular files.
  var fileAllocatedSize: Int? { get }
  /// Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available.
  ///
  /// - note: Only applicable to regular files.
  var totalFileSize: Int? { get }
  /// Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by `totalFileSize` if the resource is compressed.
  ///
  /// - note: Only applicable to regular files.
  var totalFileAllocatedSize: Int? { get }
  /// true if the resource is a Finder alias file or a symlink, false otherwise
  ///
  /// - note: Only applicable to regular files.
  var isAliasFile: Bool? { get }
}

/// Represents UUID strings, which can be used to uniquely identify types, interfaces, and other items.
@available(macOS 10.8, iOS 6.0, *)
struct UUID : ReferenceConvertible, Hashable, Equatable, CustomStringConvertible {
  typealias ReferenceType = NSUUID
  var uuid: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8) { get }
  init()
  /// Create a UUID from a string such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F".
  /// 
  /// Returns nil for invalid strings.
  init?(uuidString string: __shared String)
  /// Create a UUID from a `uuid_t`.
  init(uuid: uuid_t)
  /// Returns a string created from the UUID, such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F"
  var uuidString: String { get }
  func hash(into hasher: inout Hasher)
  var description: String { get }
  var debugDescription: String { get }
  static func == (lhs: UUID, rhs: UUID) -> Bool
  var hashValue: Int { get }
}

extension UUID : CustomReflectable {
  var customMirror: Mirror { get }
}

extension UUID : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSUUID
  static func _forceBridgeFromObjectiveC(_ x: NSUUID, result: inout UUID?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSUUID, result: inout UUID?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSUUID?) -> UUID
  typealias _ObjectiveCType = NSUUID
}

extension UUID : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@usableFromInline
@frozen struct _AsyncBytesBuffer {
  var storage: AnyObject?
  @usableFromInline
  var nextPointer: UnsafeMutableRawPointer
  @usableFromInline
  var endPointer: UnsafeMutableRawPointer
  @usableFromInline
  init(capacity: Int)
  @usableFromInline
  @inline(never) mutating func reloadBufferAndNext() async throws -> UInt8?
  @inlinable @inline(__always) mutating func next() async throws -> UInt8?
}

/// Describes a raw representable type that is bridged to a particular
/// NSError domain.
///
/// This protocol is used primarily to generate the conformance to
/// _ObjectiveCBridgeableError for such an enum defined in Swift.
protocol _BridgedNSError : _ObjectiveCBridgeableError, Hashable, RawRepresentable where Self.RawValue : FixedWidthInteger {
  /// The NSError domain to which this type is bridged.
  static var _nsErrorDomain: String { get }
}

extension _BridgedNSError {
  var _domain: String { get }
}

extension _BridgedNSError {
  var _code: Int { get }
  init?(_bridgedNSError: __shared NSError)
  func hash(into hasher: inout Hasher)
}

/// Describes a bridged error that stores the underlying NSError, so
/// it can be queried.
protocol _BridgedStoredNSError : CustomNSError, _ObjectiveCBridgeableError, Hashable {
  /// The type of an error code.
  associatedtype Code : _ErrorCodeProtocol, RawRepresentable where Self.Code.RawValue : FixedWidthInteger
  //// Retrieves the embedded NSError.
  var _nsError: NSError { get }
  /// Create a new instance of the error type with the given embedded
  /// NSError.
  ///
  /// The \c error must have the appropriate domain for this error
  /// type.
  init(_nsError error: NSError)
}

/// Various helper implementations for _BridgedStoredNSError
extension _BridgedStoredNSError {
  var code: Self.Code { get }
  /// Initialize an error within this domain with the given ``code``
  /// and ``userInfo``.
  init(_ code: Self.Code, userInfo: [String : Any] = [:])
  /// The user-info dictionary for an error that was bridged from
  /// NSError.
  var userInfo: [String : Any] { get }
}

/// Implementation of _ObjectiveCBridgeableError for all _BridgedStoredNSErrors.
extension _BridgedStoredNSError {
  /// Default implementation of ``init(_bridgedNSError:)`` to provide
  /// bridging from NSError.
  init?(_bridgedNSError error: NSError)
}

/// Implementation of CustomNSError for all _BridgedStoredNSErrors.
extension _BridgedStoredNSError {
  var errorCode: Int { get }
  var errorUserInfo: [String : Any] { get }
}

/// Implementation of Hashable for all _BridgedStoredNSErrors.
extension _BridgedStoredNSError {
  func hash(into hasher: inout Hasher)
  @_alwaysEmitIntoClient var hashValue: Int { get }
}

extension _BridgedStoredNSError {
  /// Retrieve the embedded NSError from a bridged, stored NSError.
  func _getEmbeddedNSError() -> AnyObject?
  static func == (lhs: Self, rhs: Self) -> Bool
}

/// Describes the code of an error.
protocol _ErrorCodeProtocol : Equatable {
  /// The corresponding error code.
  associatedtype _ErrorType : _BridgedStoredNSError where Self == Self._ErrorType.Code
}

extension _ErrorCodeProtocol {
  /// Allow one to match an error code against an arbitrary error.
  static func ~= (match: Self, error: Error) -> Bool
}

typealias _FileReferenceLiteralType = URL

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
protocol _FormatSpecifiable : Equatable {
  associatedtype _Arg : CVarArg
  var _arg: Self._Arg { get }
}

protocol _KeyValueCodingAndObserving {
}

extension _KeyValueCodingAndObserving {
  ///when the returned NSKeyValueObservation is deinited or invalidated, it will stop observing
  func observe<Value>(_ keyPath: KeyPath<Self, Value>, options: NSKeyValueObservingOptions = [], changeHandler: @escaping (Self, NSKeyValueObservedChange<Value>) -> Void) -> NSKeyValueObservation
  func willChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>)
  func willChange<Value>(_ changeKind: NSKeyValueChange, valuesAt indexes: IndexSet, for keyPath: __owned KeyPath<Self, Value>)
  func willChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>, withSetMutation mutation: NSKeyValueSetMutationKind, using set: Set<Value>) where Value : Hashable
  func didChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>)
  func didChange<Value>(_ changeKind: NSKeyValueChange, valuesAt indexes: IndexSet, for keyPath: __owned KeyPath<Self, Value>)
  func didChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>, withSetMutation mutation: NSKeyValueSetMutationKind, using set: Set<Value>) where Value : Hashable
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
protocol _KeyValueCodingAndObservingPublishing {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension _KeyValueCodingAndObservingPublishing where Self : NSObject {
  /// Publish values when the value identified by a KVO-compliant keypath changes.
  ///
  /// - Parameters:
  ///   - keyPath: The keypath of the property to publish.
  ///   - options: Key-value observing options.
  /// - Returns: A publisher that emits elements each time the property’s value changes.
  func publisher<Value>(for keyPath: KeyPath<Self, Value>, options: NSKeyValueObservingOptions = [.initial, .new]) -> NSObject.KeyValueObservingPublisher<Self, Value>
}

/// An internal protocol to represent Swift error enums that map to standard
/// Cocoa NSError domains.
protocol _ObjectiveCBridgeableError : Error {
  /// Produce a value of the error type corresponding to the given NSError,
  /// or return nil if it cannot be bridged.
  init?(_bridgedNSError: __shared NSError)
}

@usableFromInline
final class __DataStorage {
  @usableFromInline
  static let maxSize: Int
  @usableFromInline
  static let vmOpsThreshold: Int
  @inlinable static func allocate(_ size: Int, _ clear: Bool) -> UnsafeMutableRawPointer?
  @usableFromInline
  static func move(_ dest_: UnsafeMutableRawPointer, _ source_: UnsafeRawPointer?, _ num_: Int)
  @inlinable static func shouldAllocateCleared(_ size: Int) -> Bool
  @usableFromInline
  final var _bytes: UnsafeMutableRawPointer?
  @usableFromInline
  final var _length: Int
  @usableFromInline
  final var _capacity: Int
  @usableFromInline
  final var _offset: Int
  @usableFromInline
  final var _deallocator: ((UnsafeMutableRawPointer, Int) -> Void)?
  @usableFromInline
  final var _needToZero: Bool
  @inlinable final var bytes: UnsafeRawPointer? { get }
  @discardableResult
  @inlinable final func withUnsafeBytes<Result>(in range: Range<Int>, apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result
  @discardableResult
  @inlinable final func withUnsafeMutableBytes<Result>(in range: Range<Int>, apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result
  @inlinable final var mutableBytes: UnsafeMutableRawPointer? { get }
  @inlinable final var capacity: Int { get }
  @inlinable final var length: Int
  @inlinable final var isExternallyOwned: Bool { get }
  @usableFromInline
  final func ensureUniqueBufferReference(growingTo newLength: Int = 0, clear: Bool = false)
  @inlinable final func _freeBytes()
  @inlinable final func enumerateBytes(in range: Range<Int>, _ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Data.Index, _ stop: inout Bool) -> Void)
  @inlinable final func setLength(_ length: Int)
  @inlinable final func append(_ bytes: UnsafeRawPointer, length: Int)
  @inlinable final func get(_ index: Int) -> UInt8
  @inlinable final func set(_ index: Int, to value: UInt8)
  @inlinable final func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>)
  @usableFromInline
  final func replaceBytes(in range_: NSRange, with replacementBytes: UnsafeRawPointer?, length replacementLength: Int)
  @usableFromInline
  final func resetBytes(in range_: Range<Int>)
  @usableFromInline
  init(length: Int)
  @usableFromInline
  init(capacity capacity_: Int = 0)
  @usableFromInline
  init(bytes: UnsafeRawPointer?, length: Int)
  @usableFromInline
  init(bytes: UnsafeMutableRawPointer?, length: Int, copy: Bool, deallocator: ((UnsafeMutableRawPointer, Int) -> Void)?, offset: Int)
  @usableFromInline
  init(immutableReference: NSData, offset: Int)
  @usableFromInline
  init(mutableReference: NSMutableData, offset: Int)
  @usableFromInline
  init(customReference: NSData, offset: Int)
  @usableFromInline
  init(customMutableReference: NSMutableData, offset: Int)
  @inlinable final func mutableCopy(_ range: Range<Int>) -> __DataStorage
  @inlinable final func withInteriorPointerReference<T>(_ range: Range<Int>, _ work: (NSData) throws -> T) rethrows -> T
  @usableFromInline
  @inline(never) final func bridgedReference(_ range: Range<Int>) -> NSData
}

/// A hook for the runtime to use _ObjectiveCBridgeableError in order to
/// attempt an "errorTypeValue as? SomeError" cast.
///
/// If the bridge succeeds, the bridged value is written to the uninitialized
/// memory pointed to by 'out', and true is returned. Otherwise, 'out' is
/// left uninitialized, and false is returned.
func _bridgeNSErrorToError<T>(_ error: NSError, out: UnsafeMutablePointer<T>) -> Bool where T : _ObjectiveCBridgeableError

func _convertErrorToNSError(_ error: Error) -> NSError

func _convertNSErrorToError(_ error: NSError?) -> Error

/// Retrieve the default userInfo dictionary for a given error.
func _getErrorDefaultUserInfo<T>(_ error: T) -> AnyObject? where T : Error

@_alwaysEmitIntoClient func _withStackOrHeapBuffer(capacity: Int, _ body: (UnsafeMutableBufferPointer<UInt8>) -> Void)

@_alwaysEmitIntoClient var doubleSpecifier: String { get }

@_alwaysEmitIntoClient var floatSpecifier: String { get }

@_alwaysEmitIntoClient @_semantics("constant_evaluable") func formatSpecifier<T>(_ type: T.Type) -> String

@_alwaysEmitIntoClient var int32Specifier: String { get }

@_alwaysEmitIntoClient var int64Specifier: String { get }

var kCFStringEncodingASCII: CFStringEncoding { get }

func pow(_ x: Decimal, _ y: Int) -> Decimal

@_alwaysEmitIntoClient var uint32Specifier: String { get }

@_alwaysEmitIntoClient var uint64Specifier: String { get }

extension String {
  init(_ cocoaString: NSString)
}

extension String : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSString
  static func _forceBridgeFromObjectiveC(_ x: NSString, result: inout String?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout String?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> String
  typealias _ObjectiveCType = NSString
}

extension Substring : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSString
  static func _forceBridgeFromObjectiveC(_ x: NSString, result: inout Substring?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout Substring?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> Substring
  typealias _ObjectiveCType = NSString
}

extension String : CVarArg {
}

extension NSURL : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Slice : DataProtocol where Base : DataProtocol {
  typealias Regions = [Base.Regions.Element.SubSequence]
  var regions: [Base.Regions.Element.SubSequence] { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionWebSocketTask {
  enum Message {
    case data(Data)
    case string(String)
  }
  func send(_ message: URLSessionWebSocketTask.Message, completionHandler: @escaping (Error?) -> Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE4sendyyAbCE7MessageOYaKF")
  @_alwaysEmitIntoClient func send(_ message: URLSessionWebSocketTask.Message) async throws
  func receive(completionHandler: @escaping (Result<URLSessionWebSocketTask.Message, Error>) -> Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE7receiveAbCE7MessageOyYaKF")
  @_alwaysEmitIntoClient func receive() async throws -> URLSessionWebSocketTask.Message
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionTaskTransactionMetrics {
  var localPort: Int? { get }
  var remotePort: Int? { get }
  var negotiatedTLSProtocolVersion: tls_protocol_version_t? { get }
  var negotiatedTLSCipherSuite: tls_ciphersuite_t? { get }
}

extension URLSession {
  @_alwaysEmitIntoClient func makeState() -> ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>
  @_alwaysEmitIntoClient func cancel(state: ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>)
  @_alwaysEmitIntoClient func activate(state: ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>, task: URLSessionTask)
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension URLSession {
  /// Convenience method to load data using an URLRequest, creates and resumes an URLSessionDataTask internally.
  ///
  /// - Parameter request: The URLRequest for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func data(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.
  ///
  /// - Parameter url: The URL for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to upload data.
  /// - Parameter fileURL: File to upload.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func upload(for request: URLRequest, fromFile fileURL: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to upload data.
  /// - Parameter bodyData: Data to upload.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func upload(for request: URLRequest, from bodyData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter url: The URL for which to download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter resumeData: Resume data from an incomplete download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(resumeFrom resumeData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// AsyncBytes conforms to AsyncSequence for data delivery. The sequence is single pass. Delegate will not be called for response and data delivery.
  struct AsyncBytes : AsyncSequence {
    /// Underlying data task providing the bytes.
    var task: URLSessionDataTask { get }
    typealias Element = UInt8
    typealias AsyncIterator = URLSession.AsyncBytes.Iterator
    @frozen struct Iterator : AsyncIteratorProtocol {
      typealias Element = UInt8
      @usableFromInline
      var buffer: _AsyncBytesBuffer
      @inlinable @inline(__always) mutating func next() async throws -> UInt8?
    }
    __consuming func makeAsyncIterator() -> URLSession.AsyncBytes.Iterator
  }
  /// Returns a byte stream that conforms to AsyncSequence protocol.
  ///
  /// - Parameter request: The URLRequest for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data stream and response.
  func bytes(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)
  /// Returns a byte stream that conforms to AsyncSequence protocol.
  ///
  /// - Parameter url: The URL for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data stream and response.
  func bytes(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)
}

extension NSDateComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedEncodingContainer {
  mutating func encode<T, C>(_ wrapper: CodableConfiguration<T?, C>, forKey key: KeyedEncodingContainer<K>.Key) throws where T : DecodableWithConfiguration, T : EncodableWithConfiguration, C : DecodingConfigurationProviding, C : EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedDecodingContainer {
  func decode<T, C>(_: CodableConfiguration<T?, C>.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> CodableConfiguration<T?, C> where T : DecodableWithConfiguration, T : EncodableWithConfiguration, C : DecodingConfigurationProviding, C : EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedEncodingContainer {
  mutating func encode<T, C>(_ t: T, forKey key: KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  mutating func encodeIfPresent<T, C>(_ t: T?, forKey key: KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  mutating func encode<T>(_ t: T, forKey key: KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration
  mutating func encodeIfPresent<T>(_ t: T?, forKey key: KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedDecodingContainer {
  func decode<T, C>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  func decodeIfPresent<T, C>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T? where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  func decode<T>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration
  func decodeIfPresent<T>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T? where T : DecodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UnkeyedEncodingContainer {
  mutating func encode<T, C>(_ t: T, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  mutating func encode<T>(_ t: T, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UnkeyedDecodingContainer {
  mutating func decode<T, C>(_: T.Type, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  mutating func decodeIfPresent<T, C>(_: T.Type, configuration: C.Type) throws -> T? where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  mutating func decode<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration
  mutating func decodeIfPresent<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T? where T : DecodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Optional : EncodableWithConfiguration where Wrapped : EncodableWithConfiguration {
  func encode(to encoder: Encoder, configuration: Wrapped.EncodingConfiguration) throws
  typealias EncodingConfiguration = Wrapped.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Optional : DecodableWithConfiguration where Wrapped : DecodableWithConfiguration {
  init(from decoder: Decoder, configuration: Wrapped.DecodingConfiguration) throws
  typealias DecodingConfiguration = Wrapped.DecodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Array : EncodableWithConfiguration where Element : EncodableWithConfiguration {
  func encode(to encoder: Encoder, configuration: Element.EncodingConfiguration) throws
  typealias EncodingConfiguration = Element.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Array : DecodableWithConfiguration where Element : DecodableWithConfiguration {
  init(from decoder: Decoder, configuration: Element.DecodingConfiguration) throws
  typealias DecodingConfiguration = Element.DecodingConfiguration
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject : _KeyValueCodingAndObservingPublishing {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject {
  /// A publisher that emits events when the value of a KVO-compliant property changes.
  struct KeyValueObservingPublisher<Subject, Value> : Equatable where Subject : NSObject {
    let object: Subject
    let keyPath: KeyPath<Subject, Value>
    let options: NSKeyValueObservingOptions
    init(object: Subject, keyPath: KeyPath<Subject, Value>, options: NSKeyValueObservingOptions)
    static func == (lhs: NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: NSObject.KeyValueObservingPublisher<Subject, Value>) -> Bool
  }
}

extension NSObject : _KeyValueCodingAndObserving {
}

extension Progress {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  var estimatedTimeRemaining: TimeInterval?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  var throughput: Int?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  var fileTotalCount: Int?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  var fileCompletedCount: Int?
  func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}

extension NSString : ExpressibleByStringLiteral {
  /// Create an instance initialized to `value`.
  required convenience init(stringLiteral value: StaticString)
  typealias ExtendedGraphemeClusterLiteralType = StaticString
  typealias StringLiteralType = StaticString
  typealias UnicodeScalarLiteralType = StaticString
}

extension NSString : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSString {
  convenience init(format: __shared NSString, _ args: CVarArg...)
  convenience init(format: __shared NSString, locale: Locale?, _ args: CVarArg...)
  class func localizedStringWithFormat(_ format: NSString, _ args: CVarArg...) -> Self
  func appendingFormat(_ format: NSString, _ args: CVarArg...) -> NSString
}

extension NSMutableString {
  func appendFormat(_ format: NSString, _ args: CVarArg...)
}

extension NSString {
  /// Returns an `NSString` object initialized by copying the characters
  /// from another given string.
  ///
  /// - Returns: An `NSString` object initialized by copying the
  ///   characters from `aString`. The returned object may be different
  ///   from the original receiver.
  @nonobjc convenience init(string aString: __shared NSString)
}

extension NSString : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UndoManager {
  @available(*, unavailable, renamed: "registerUndo(withTarget:handler:)")
  func registerUndoWithTarget<TargetType>(_ target: TargetType, handler: (TargetType) -> Void) where TargetType : AnyObject
  @available(macOS 10.11, iOS 9.0, *)
  func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping (TargetType) -> Void) where TargetType : AnyObject
}

extension NSIndexPath : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension Array : DataProtocol where Element == UInt8 {
  var regions: CollectionOfOne<Array<UInt8>> { get }
  typealias Regions = CollectionOfOne<Array<UInt8>>
}

extension ArraySlice : DataProtocol where Element == UInt8 {
  var regions: CollectionOfOne<ArraySlice<UInt8>> { get }
  typealias Regions = CollectionOfOne<ArraySlice<UInt8>>
}

extension ContiguousArray : DataProtocol where Element == UInt8 {
  var regions: CollectionOfOne<ContiguousArray<UInt8>> { get }
  typealias Regions = CollectionOfOne<ContiguousArray<UInt8>>
}

extension EmptyCollection : DataProtocol where Element == UInt8 {
  var regions: EmptyCollection<Data> { get }
  typealias Regions = EmptyCollection<Data>
}

extension Repeated : DataProtocol where Element == UInt8 {
  typealias Regions = Repeated<Data>
  var regions: Repeated<Data> { get }
}

extension Array : MutableDataProtocol where Element == UInt8 {
}

extension ContiguousArray : MutableDataProtocol where Element == UInt8 {
}

extension NSTimeZone : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSIndexSet : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSEnumerator : Sequence {
  /// Return an *iterator* over the *enumerator*.
  ///
  /// - Complexity: O(1).
  func makeIterator() -> NSFastEnumerationIterator
  typealias Element = Any
  typealias Iterator = NSFastEnumerationIterator
}

extension NSTextCheckingResult.CheckingType {
  static var allSystemTypes: NSTextCheckingResult.CheckingType { get }
  static var allCustomTypes: NSTextCheckingResult.CheckingType { get }
  static var allTypes: NSTextCheckingResult.CheckingType { get }
}

extension NSDictionary : ExpressibleByDictionaryLiteral {
  required convenience init(dictionaryLiteral elements: (Any, Any)...)
  typealias Key = Any
  typealias Value = Any
}

extension Dictionary : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSDictionary
  static func _forceBridgeFromObjectiveC(_ d: NSDictionary, result: inout Dictionary<Key, Value>?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSDictionary, result: inout Dictionary<Key, Value>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ d: NSDictionary?) -> Dictionary<Key, Value>
  typealias _ObjectiveCType = NSDictionary
}

extension NSDictionary : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSDictionary : Sequence {
  final class Iterator : IteratorProtocol {
    final func next() -> (key: Any, value: Any)?
    typealias Element = (key: Any, value: Any)
  }
  @objc dynamic subscript(key: Any) -> Any? { get }
  /// Return an *iterator* over the elements of this *sequence*.
  ///
  /// - Complexity: O(1).
  func makeIterator() -> NSDictionary.Iterator
  /// A value less than or equal to the number of elements in the collection.
  ///
  /// - Complexity: O(1).
  @_alwaysEmitIntoClient @nonobjc var underestimatedCount: Int { get }
  typealias Element = (key: Any, value: Any)
}

extension NSMutableDictionary {
  @objc override dynamic subscript(key: Any) -> Any?
}

extension NSDictionary {
  /// Initializes a newly allocated dictionary and adds to it objects from
  /// another given dictionary.
  ///
  /// - Returns: An initialized dictionary--which might be different
  ///   than the original receiver--containing the keys and values
  ///   found in `otherDictionary`.
  @objc(__swiftInitWithDictionary_NSDictionary:) dynamic convenience init(dictionary otherDictionary: __shared NSDictionary)
}

extension NSDictionary : CustomReflectable {
  var customMirror: Mirror { get }
}

extension Dictionary : CVarArg {
}

extension NSObject : CustomStringConvertible {
}

extension NSObject : CustomDebugStringConvertible {
}

extension AnyHashable : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSObject
  static func _forceBridgeFromObjectiveC(_ x: NSObject, result: inout AnyHashable?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSObject, result: inout AnyHashable?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSObject?) -> AnyHashable
  typealias _ObjectiveCType = NSObject
}

extension CVarArg where Self : _ObjectiveCBridgeable {
  /// Default implementation for bridgeable types.
  var _cVarArgEncoding: [Int] { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Timer {
  /// Returns a publisher that repeatedly emits the current date on the given interval.
  ///
  /// - Parameters:
  ///   - interval: The time interval on which to publish events. For example, a value of `0.5` publishes an event approximately every half-second.
  ///   - tolerance: The allowed timing variance when emitting events. Defaults to `nil`, which allows any variance.
  ///   - runLoop: The run loop on which the timer runs.
  ///   - mode: The run loop mode in which to run the timer.
  ///   - options: Scheduler options passed to the timer. Defaults to `nil`.
  /// - Returns: A publisher that repeatedly emits the current date on the given interval.
  static func publish(every interval: TimeInterval, tolerance: TimeInterval? = nil, on runLoop: RunLoop, in mode: RunLoop.Mode, options: RunLoop.SchedulerOptions? = nil) -> Timer.TimerPublisher
  /// A publisher that repeatedly emits the current date on a given interval.
  final class TimerPublisher : ConnectablePublisher {
    typealias Output = Date
    typealias Failure = Never
    final let interval: TimeInterval
    final let tolerance: TimeInterval?
    final let runLoop: RunLoop
    final let mode: RunLoop.Mode
    final let options: RunLoop.SchedulerOptions?
    /// Creates a publisher that repeatedly emits the current date on the given interval.
    ///
    /// - Parameters:
    ///   - interval: The interval on which to publish events.
    ///   - tolerance: The allowed timing variance when emitting events. Defaults to `nil`, which allows any variance.
    ///   - runLoop: The run loop on which the timer runs.
    ///   - mode: The run loop mode in which to run the timer.
    ///   - options: Scheduler options passed to the timer. Defaults to `nil`.
    init(interval: TimeInterval, tolerance: TimeInterval? = nil, runLoop: RunLoop, mode: RunLoop.Mode, options: RunLoop.SchedulerOptions? = nil)
    final func connect() -> Cancellable
    final func receive<S>(subscriber: S) where S : Subscriber, S.Failure == Never, S.Input == Date
  }
}

@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension NSItemProvider {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  func registerObject<T>(ofClass: T.Type, visibility: NSItemProviderRepresentationVisibility, loadHandler: @escaping ((T?, Error?) -> Void) -> Progress?) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  func canLoadObject<T>(ofClass: T.Type) -> Bool where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  func loadObject<T>(ofClass: T.Type, completionHandler: @escaping (T?, Error?) -> Void) -> Progress where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

extension NSArray : ExpressibleByArrayLiteral {
  /// Create an instance initialized with `elements`.
  required convenience init(arrayLiteral elements: Any...)
  typealias ArrayLiteralElement = Any
}

extension Array : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSArray
  static func _forceBridgeFromObjectiveC(_ source: NSArray, result: inout Array<Element>?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSArray, result: inout Array<Element>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSArray?) -> Array<Element>
  typealias _ObjectiveCType = NSArray
}

extension NSArray : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSArray : Sequence {
  /// Return an *iterator* over the elements of this *sequence*.
  ///
  /// - Complexity: O(1).
  final func makeIterator() -> NSFastEnumerationIterator
  /// A value less than or equal to the number of elements in the collection.
  ///
  /// - Complexity: O(1).
  @_alwaysEmitIntoClient @nonobjc var underestimatedCount: Int { get }
  typealias Element = Any
  typealias Iterator = NSFastEnumerationIterator
}

extension NSArray {
  convenience init(objects elements: Any...)
}

extension NSArray {
  /// Initializes a newly allocated array by placing in it the objects
  /// contained in a given array.
  ///
  /// - Returns: An array initialized to contain the objects in
  ///    `anArray``. The returned object might be different than the
  ///    original receiver.
  ///
  /// Discussion: After an immutable array has been initialized in
  /// this way, it cannot be modified.
  @nonobjc convenience init(array anArray: __shared NSArray)
}

extension NSArray : CustomReflectable {
  var customMirror: Mirror { get }
}

extension Array : CVarArg {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Range where Bound == Date {
  /// Formats the date range using the specified style.
  func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Range<Date>
  /// Formats the date range as an interval.
  func formatted() -> String
  func formatted(date: Date.IntervalFormatStyle.DateStyle, time: Date.IntervalFormatStyle.TimeStyle) -> String
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSAttributedString {
  convenience init(contentsOf url: URL, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
  convenience init(markdown: Data, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
  convenience init(markdown: String, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {
  /**
   A non-blocking sequence of `Characters` created by decoding the elements of `self` as UTF8.
   */
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var characters: AsyncCharacterSequence<Self> { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {
  /// Returns a publisher that emits events when broadcasting notifications.
  ///
  /// - Parameters:
  ///   - name: The name of the notification to publish.
  ///   - object: The object posting the named notfication. If `nil`, the publisher emits elements for any object producing a notification with the given name.
  /// - Returns: A publisher that emits events when broadcasting notifications.
  func publisher(for name: Notification.Name, object: AnyObject? = nil) -> NotificationCenter.Publisher
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {
  /// A publisher that emits elements when broadcasting notifications.
  struct Publisher : Publisher {
    typealias Output = Notification
    typealias Failure = Never
    /// The notification center this publisher uses as a source.
    let center: NotificationCenter
    /// The name of notifications published by this publisher.
    let name: Notification.Name
    /// The object posting the named notfication.
    let object: AnyObject?
    /// Creates a publisher that emits events when broadcasting notifications.
    ///
    /// - Parameters:
    ///   - center: The notification center to publish notifications for.
    ///   - name: The name of the notification to publish.
    ///   - object: The object posting the named notfication. If `nil`, the publisher emits elements for any object producing a notification with the given name.
    init(center: NotificationCenter, name: Notification.Name, object: AnyObject? = nil)
    func receive<S>(subscriber: S) where S : Subscriber, S.Failure == Never, S.Input == Notification
  }
}

extension NSData : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSPredicate {
  convenience init(format predicateFormat: __shared String, _ args: CVarArg...)
}

extension NSSortDescriptor {
  convenience init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool)
  convenience init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool, comparator cmptr: @escaping Comparator)
  var keyPath: AnyKeyPath? { get }
}

extension FileHandle {
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  func readToEnd() throws -> Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  func read(upToCount count: Int) throws -> Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  func offset() throws -> UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @discardableResult
  func seekToEnd() throws -> UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  func write<T>(contentsOf data: T) throws where T : DataProtocol
}

extension EncodingError : LocalizedError {
}

extension DecodingError : LocalizedError {
}

extension _NSRange : Hashable {
  func hash(into hasher: inout Hasher)
  static func == (lhs: NSRange, rhs: NSRange) -> Bool
  var hashValue: Int { get }
}

extension _NSRange : CustomStringConvertible, CustomDebugStringConvertible {
  var description: String { get }
  var debugDescription: String { get }
}

extension _NSRange {
  init?(_ string: __shared String)
}

extension _NSRange {
  var lowerBound: Int { get }
  var upperBound: Int { get }
  func contains(_ index: Int) -> Bool
  mutating func formUnion(_ other: NSRange)
  func union(_ other: NSRange) -> NSRange
  func intersection(_ other: NSRange) -> NSRange?
}

extension _NSRange {
  init<R>(_ region: R) where R : RangeExpression, R.Bound : FixedWidthInteger
  init<R, S>(_ region: R, in target: S) where R : RangeExpression, S : StringProtocol, R.Bound == String.Index
  @available(swift, deprecated: 4, message: "Use Range.init(_:) instead")
  func toRange() -> Range<Int>?
}

extension Range where Bound : BinaryInteger {
  init?(_ range: NSRange)
}

extension Range where Bound == Int {
  init?(_ range: NSRange)
}

extension Range where Bound == String.Index {
  init?(_ range: NSRange, in string: __shared String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  init?<S>(_ range: NSRange, in string: __shared S) where S : StringProtocol
}

extension _NSRange : CustomReflectable {
  var customMirror: Mirror { get }
}

extension _NSRange : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension _NSRange : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
  struct FormatStyle : FormatStyle {
    var locale: Locale
    init(locale: Locale = .autoupdatingCurrent)
    var attributed: Decimal.FormatStyle.Attributed { get }
    typealias Configuration = NumberFormatStyleConfiguration
    func grouping(_ group: Decimal.FormatStyle.Configuration.Grouping) -> Decimal.FormatStyle
    func precision(_ p: Decimal.FormatStyle.Configuration.Precision) -> Decimal.FormatStyle
    func sign(strategy: Decimal.FormatStyle.Configuration.SignDisplayStrategy) -> Decimal.FormatStyle
    func decimalSeparator(strategy: Decimal.FormatStyle.Configuration.DecimalSeparatorDisplayStrategy) -> Decimal.FormatStyle
    func rounded(rule: Decimal.FormatStyle.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> Decimal.FormatStyle
    func scale(_ multiplicand: Double) -> Decimal.FormatStyle
    func notation(_ notation: Decimal.FormatStyle.Configuration.Notation) -> Decimal.FormatStyle
    func format(_ value: Decimal) -> String
    func locale(_ locale: Locale) -> Decimal.FormatStyle
    func hash(into hasher: inout Hasher)
    static func == (a: Decimal.FormatStyle, b: Decimal.FormatStyle) -> Bool
    typealias FormatInput = Decimal
    typealias FormatOutput = String
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
  /// Format `self` using `Decimal.FormatStyle`
  func formatted() -> String
  /// Format `self` with the given format.
  func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Decimal
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension OperationQueue : Scheduler {
  /// The scheduler time type used by the operation queue.
  struct SchedulerTimeType : Strideable, Codable, Hashable {
    /// The date represented by this type.
    var date: Date
    /// Initializes a operation queue scheduler time with the given date.
    ///
    /// - Parameter date: The date to represent.
    init(_ date: Date)
    /// Returns the distance to another operation queue scheduler time.
    ///
    /// - Parameter other: Another operation queue time.
    /// - Returns: The time interval between this time and the provided time.
    func distance(to other: OperationQueue.SchedulerTimeType) -> OperationQueue.SchedulerTimeType.Stride
    /// Returns a operation queue scheduler time calculated by advancing this instance’s time by the given interval.
    ///
    /// - Parameter n: A time interval to advance.
    /// - Returns: A operation queue time advanced by the given interval from this instance’s time.
    func advanced(by n: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType
    /// The interval by which operation queue times advance.
    struct Stride : ExpressibleByFloatLiteral, Comparable, SignedNumeric, Codable, SchedulerTimeIntervalConvertible {
      typealias FloatLiteralType = TimeInterval
      typealias IntegerLiteralType = TimeInterval
      typealias Magnitude = TimeInterval
      /// The value of this time interval in seconds.
      var magnitude: TimeInterval
      /// The value of this time interval in seconds.
      var timeInterval: TimeInterval { get }
      init(integerLiteral value: TimeInterval)
      init(floatLiteral value: TimeInterval)
      init(_ timeInterval: TimeInterval)
      init?<T>(exactly source: T) where T : BinaryInteger
      static func < (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> Bool
      static func * (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride
      static func + (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride
      static func - (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride
      static func *= (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)
      static func += (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)
      static func -= (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)
      static func seconds(_ s: Int) -> OperationQueue.SchedulerTimeType.Stride
      static func seconds(_ s: Double) -> OperationQueue.SchedulerTimeType.Stride
      static func milliseconds(_ ms: Int) -> OperationQueue.SchedulerTimeType.Stride
      static func microseconds(_ us: Int) -> OperationQueue.SchedulerTimeType.Stride
      static func nanoseconds(_ ns: Int) -> OperationQueue.SchedulerTimeType.Stride
      static func == (a: OperationQueue.SchedulerTimeType.Stride, b: OperationQueue.SchedulerTimeType.Stride) -> Bool
      func encode(to encoder: Encoder) throws
      init(from decoder: Decoder) throws
    }
    func hash(into hasher: inout Hasher)
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  /// Options that affect the operation of the operation queue scheduler.
  struct SchedulerOptions {
  }
  func schedule(options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void)
  func schedule(after date: OperationQueue.SchedulerTimeType, tolerance: OperationQueue.SchedulerTimeType.Stride, options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void)
  func schedule(after date: OperationQueue.SchedulerTimeType, interval: OperationQueue.SchedulerTimeType.Stride, tolerance: OperationQueue.SchedulerTimeType.Stride, options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void) -> Cancellable
  var now: OperationQueue.SchedulerTimeType { get }
  var minimumTolerance: OperationQueue.SchedulerTimeType.Stride { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
  struct ParseStrategy<Format> : ParseStrategy, Codable, Hashable where Format : FormatStyle, Format.FormatInput == Decimal {
    var formatStyle: Format
    var lenient: Bool
    func parse(_ value: String) throws -> Format.FormatInput
    func hash(into hasher: inout Hasher)
    static func == (a: Decimal.ParseStrategy<Format>, b: Decimal.ParseStrategy<Format>) -> Bool
    typealias ParseInput = String
    typealias ParseOutput = Decimal
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {
  /// Initialize an instance by parsing `value` with the given `strategy`.
  init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput == Decimal
  init(_ value: String, format: Decimal.FormatStyle, lenient: Bool = true) throws
  init(_ value: String, format: Decimal.FormatStyle.Percent, lenient: Bool = true) throws
  init(_ value: String, format: Decimal.FormatStyle.Currency, lenient: Bool = true) throws
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Scanner {
  enum NumberRepresentation {
    case decimal
    case hexadecimal
    static func == (a: Scanner.NumberRepresentation, b: Scanner.NumberRepresentation) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  var currentIndex: String.Index
  func scanInt(representation: Scanner.NumberRepresentation = .decimal) -> Int?
  func scanInt32(representation: Scanner.NumberRepresentation = .decimal) -> Int32?
  func scanInt64(representation: Scanner.NumberRepresentation = .decimal) -> Int64?
  func scanUInt64(representation: Scanner.NumberRepresentation = .decimal) -> UInt64?
  func scanFloat(representation: Scanner.NumberRepresentation = .decimal) -> Float?
  func scanDouble(representation: Scanner.NumberRepresentation = .decimal) -> Double?
  func scanDecimal() -> Decimal?
  func scanString(_ searchString: String) -> String?
  func scanCharacters(from set: CharacterSet) -> String?
  func scanUpToString(_ substring: String) -> String?
  func scanUpToCharacters(from set: CharacterSet) -> String?
  func scanCharacter() -> Character?
}

extension NotificationCenter {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  func notifications(named name: Notification.Name, object: AnyObject? = nil) -> NotificationCenter.Notifications
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  final class Notifications : AsyncSequence {
    typealias Element = Notification
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    struct Iterator : AsyncIteratorProtocol {
      func next() async -> Notification?
      typealias Element = Notification
    }
    final __consuming func makeAsyncIterator() -> NotificationCenter.Notifications.Iterator
    typealias AsyncIterator = NotificationCenter.Notifications.Iterator
  }
}

extension NSLocale : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference.Change : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSOrderedCollectionChange
  static func _forceBridgeFromObjectiveC(_ input: NSOrderedCollectionChange, result: inout CollectionDifference<ChangeElement>.Change?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSOrderedCollectionChange, result: inout CollectionDifference<ChangeElement>.Change?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ s: NSOrderedCollectionChange?) -> CollectionDifference<ChangeElement>.Change
  typealias _ObjectiveCType = NSOrderedCollectionChange
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension CollectionDifference : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSOrderedCollectionDifference
  static func _forceBridgeFromObjectiveC(_ input: NSOrderedCollectionDifference, result: inout CollectionDifference<ChangeElement>?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSOrderedCollectionDifference, result: inout CollectionDifference<ChangeElement>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ s: NSOrderedCollectionDifference?) -> CollectionDifference<ChangeElement>
  typealias _ObjectiveCType = NSOrderedCollectionDifference
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSDateInterval : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSURL : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension URLSession {
  /// Returns a publisher that wraps a URL session data task for a given URL.
  ///
  /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
  /// - Parameter url: The URL for which to create a data task.
  /// - Returns: A publisher that wraps a data task for the URL.
  func dataTaskPublisher(for url: URL) -> URLSession.DataTaskPublisher
  /// Returns a publisher that wraps a URL session data task for a given URL request.
  ///
  /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
  /// - Parameter request: The URL request for which to create a data task.
  /// - Returns: A publisher that wraps a data task for the URL request.
  func dataTaskPublisher(for request: URLRequest) -> URLSession.DataTaskPublisher
  struct DataTaskPublisher : Publisher {
    typealias Output = (data: Data, response: URLResponse)
    typealias Failure = URLError
    let request: URLRequest
    let session: URLSession
    init(request: URLRequest, session: URLSession)
    func receive<S>(subscriber: S) where S : Subscriber, S.Failure == URLError, S.Input == (data: Data, response: URLResponse)
  }
}

extension NSDate : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  func replaceItemAtURL(originalItemURL: NSURL, withItemAtURL newItemURL: NSURL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?
  @available(macOS 10.6, iOS 4.0, *)
  @available(swift, obsoleted: 4)
  func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?
  @available(swift 4)
  @available(macOS 10.6, iOS 4.0, *)
  func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> URL?
  @available(macOS 10.6, iOS 4.0, *)
  @nonobjc func enumerator(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((URL, Error) -> Bool)? = nil) -> FileManager.DirectoryEnumerator?
}

extension NSExpression {
  convenience init(format expressionFormat: __shared String, _ args: CVarArg...)
}

extension NSExpression {
  convenience init<Root, Value>(forKeyPath keyPath: KeyPath<Root, Value>)
}

extension NSData : DataProtocol {
  @nonobjc var startIndex: Int { get }
  @nonobjc var endIndex: Int { get }
  @nonobjc func lastRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : DataProtocol, R : RangeExpression, R.Bound == Int
  @nonobjc func firstRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : DataProtocol, R : RangeExpression, R.Bound == Int
  @nonobjc var regions: [Data] { get }
  @nonobjc subscript(position: Int) -> UInt8 { get }
  typealias Element = UInt8
  typealias Index = Int
  typealias Indices = Range<Int>
  typealias Iterator = IndexingIterator<NSData>
  typealias Regions = [Data]
  typealias SubSequence = Slice<NSData>
}

extension NSCoder {
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  func decodeObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: String) -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding
  func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  @nonobjc func decodeObjectOfClasses(_ classes: NSSet?, forKey key: String) -> AnyObject?
  @nonobjc func decodeObject(of classes: [AnyClass]?, forKey key: String) -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc func decodeTopLevelObject() throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(forKey:)")
  func decodeTopLevelObjectForKey(_ key: String) throws -> AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc func decodeTopLevelObject(forKey key: String) throws -> AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc func decodeTopLevelObject(forKey key: String) throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  func decodeTopLevelObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: String) throws -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding
  @available(macOS 10.11, iOS 9.0, *)
  func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) throws -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  @nonobjc func decodeTopLevelObjectOfClasses(_ classes: NSSet?, forKey key: String) throws -> AnyObject?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc func decodeTopLevelObject(of classes: [AnyClass]?, forKey key: String) throws -> Any?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: String) -> [DecodedObject]? where DecodedObject : NSObject, DecodedObject : NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc func decodeArrayOfObjects(ofClasses classes: [AnyClass], forKey key: String) -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: String) -> [DecodedKey : DecodedObject]? where DecodedKey : NSObject, DecodedKey : NSCopying, DecodedKey : NSSecureCoding, DecodedObject : NSObject, DecodedObject : NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc func decodeDictionary(withKeysOfClasses keyClasses: [AnyClass], objectsOfClasses classes: [AnyClass], forKey key: String) -> [AnyHashable : Any]?
}

extension NSKeyedArchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc func encodeEncodable<T>(_ value: T, forKey key: String) throws where T : Encodable
}

extension NSKeyedUnarchiver {
  @available(macOS 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc class func unarchiveTopLevelObjectWithData(_ data: NSData) throws -> AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc class func unarchiveTopLevelObjectWithData(_ data: Data) throws -> Any?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Data) throws -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc static func unarchivedObject(ofClasses classes: [AnyClass], from data: Data) throws -> Any?
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc func decodeDecodable<T>(_ type: T.Type, forKey key: String) -> T? where T : Decodable
  @available(macOS 10.11, iOS 9.0, *)
  @nonobjc func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: String) throws -> T? where T : Decodable
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Data) throws -> [DecodedObject]? where DecodedObject : NSObject, DecodedObject : NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc static func unarchivedArrayOfObjects(ofClasses classes: [AnyClass], from data: Data) throws -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : NSObject, DecodedKey : NSCopying, DecodedKey : NSSecureCoding, DecodedObject : NSObject, DecodedObject : NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc static func unarchivedDictionary(keysOfClasses keyClasses: [AnyClass], objectsOfClasses objectClasses: [AnyClass], from data: Data) throws -> [AnyHashable : Any]?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {
  /**
   A non-blocking sequence of newline-separated `Strings` created by decoding the elements of `self` as UTF8.
   */
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var lines: AsyncLineSequence<Self> { get }
}

extension DispatchData : DataProtocol {
  struct Region : DataProtocol, ContiguousBytes {
    var regions: CollectionOfOne<DispatchData.Region> { get }
    subscript(position: DispatchData.Index) -> UInt8 { get }
    var startIndex: DispatchData.Index { get }
    var endIndex: DispatchData.Index { get }
    func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    typealias Element = UInt8
    typealias Index = DispatchData.Index
    typealias Indices = Range<DispatchData.Index>
    typealias Iterator = IndexingIterator<DispatchData.Region>
    typealias Regions = CollectionOfOne<DispatchData.Region>
    typealias SubSequence = Slice<DispatchData.Region>
  }
  var regions: [DispatchData.Region] { get }
  typealias Regions = [DispatchData.Region]
}

extension NSUUID : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension Decimal {
  typealias RoundingMode = NSDecimalNumber.RoundingMode
  typealias CalculationError = NSDecimalNumber.CalculationError
}

extension Decimal : Hashable, Comparable {
  func hash(into hasher: inout Hasher)
  static func == (lhs: Decimal, rhs: Decimal) -> Bool
  static func < (lhs: Decimal, rhs: Decimal) -> Bool
  var hashValue: Int { get }
}

extension Decimal : CustomStringConvertible {
  init?(string: __shared String, locale: __shared Locale? = nil)
  var description: String { get }
}

extension Decimal : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension Decimal : ExpressibleByFloatLiteral {
  init(floatLiteral value: Double)
  typealias FloatLiteralType = Double
}

extension Decimal : ExpressibleByIntegerLiteral {
  init(integerLiteral value: Int)
  typealias IntegerLiteralType = Int
}

extension Decimal : SignedNumeric {
  var magnitude: Decimal { get }
  init?<T>(exactly source: T) where T : BinaryInteger
  static func += (lhs: inout Decimal, rhs: Decimal)
  static func -= (lhs: inout Decimal, rhs: Decimal)
  static func *= (lhs: inout Decimal, rhs: Decimal)
  static func /= (lhs: inout Decimal, rhs: Decimal)
  static func + (lhs: Decimal, rhs: Decimal) -> Decimal
  static func - (lhs: Decimal, rhs: Decimal) -> Decimal
  static func * (lhs: Decimal, rhs: Decimal) -> Decimal
  static func / (lhs: Decimal, rhs: Decimal) -> Decimal
  mutating func negate()
  typealias Magnitude = Decimal
}

extension Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating func add(_ other: Decimal)
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating func subtract(_ other: Decimal)
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating func multiply(by other: Decimal)
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating func divide(by other: Decimal)
}

extension Decimal : Strideable {
  func distance(to other: Decimal) -> Decimal
  func advanced(by n: Decimal) -> Decimal
  typealias Stride = Decimal
}

extension Decimal {
  static let leastFiniteMagnitude: Decimal
  static let greatestFiniteMagnitude: Decimal
  static let leastNormalMagnitude: Decimal
  static let leastNonzeroMagnitude: Decimal
  static let pi: Decimal
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  static var infinity: Decimal { get }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  static var signalingNaN: Decimal { get }
  static var quietNaN: Decimal { get }
  static var nan: Decimal { get }
  static var radix: Int { get }
  init(_ value: UInt8)
  init(_ value: Int8)
  init(_ value: UInt16)
  init(_ value: Int16)
  init(_ value: UInt32)
  init(_ value: Int32)
  init(_ value: UInt64)
  init(_ value: Int64)
  init(_ value: UInt)
  init(_ value: Int)
  init(_ value: Double)
  init(sign: FloatingPointSign, exponent: Int, significand: Decimal)
  init(signOf: Decimal, magnitudeOf magnitude: Decimal)
  var exponent: Int { get }
  var significand: Decimal { get }
  var sign: FloatingPointSign { get }
  var ulp: Decimal { get }
  var nextUp: Decimal { get }
  var nextDown: Decimal { get }
  /// The IEEE 754 "class" of this type.
  var floatingPointClass: FloatingPointClassification { get }
  var isCanonical: Bool { get }
  /// `true` if `self` is negative, `false` otherwise.
  var isSignMinus: Bool { get }
  /// `true` if `self` is +0.0 or -0.0, `false` otherwise.
  var isZero: Bool { get }
  /// `true` if `self` is subnormal, `false` otherwise.
  var isSubnormal: Bool { get }
  /// `true` if `self` is normal (not zero, subnormal, infinity, or NaN),
  /// `false` otherwise.
  var isNormal: Bool { get }
  /// `true` if `self` is zero, subnormal, or normal (not infinity or NaN),
  /// `false` otherwise.
  var isFinite: Bool { get }
  /// `true` if `self` is infinity, `false` otherwise.
  var isInfinite: Bool { get }
  /// `true` if `self` is NaN, `false` otherwise.
  var isNaN: Bool { get }
  /// `true` if `self` is a signaling NaN, `false` otherwise.
  var isSignaling: Bool { get }
  /// `true` if `self` is a signaling NaN, `false` otherwise.
  var isSignalingNaN: Bool { get }
  func isEqual(to other: Decimal) -> Bool
  func isLess(than other: Decimal) -> Bool
  func isLessThanOrEqualTo(_ other: Decimal) -> Bool
  func isTotallyOrdered(belowOrEqualTo other: Decimal) -> Bool
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  mutating func formTruncatingRemainder(dividingBy other: Decimal)
}

extension Decimal : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSDecimalNumber
  static func _forceBridgeFromObjectiveC(_ x: NSDecimalNumber, result: inout Decimal?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSDecimalNumber, result: inout Decimal?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSDecimalNumber?) -> Decimal
  typealias _ObjectiveCType = NSDecimalNumber
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension String {
  /// Compares `String`s using one of a fixed set of standard comparison
  /// algorithms.
  struct StandardComparator : SortComparator, Codable {
    /// Compares `String`s as compared by the Finder.
    ///
    /// Uses a localized, numeric comparison in the current locale.
    ///
    /// The default `SortComparator` used in `String` comparisons.
    static let localizedStandard: String.StandardComparator
    /// Compares `String`s using a localized comparison in the current
    /// locale.
    static let localized: String.StandardComparator
    /// Compares `String`s lexically.
    static let lexical: String.StandardComparator
    var order: SortOrder
    /// Create a `StandardComparator` from the given `StandardComparator`
    /// with the given new `order`.
    ///
    /// - Parameters:
    ///     - base: The standard comparator to modify the order of.
    ///     - order: The initial order of the new `StandardComparator`.
    init(_ base: String.StandardComparator, order: SortOrder = .forward)
    init(from decoder: Decoder) throws
    func compare(_ lhs: String, _ rhs: String) -> ComparisonResult
    func hash(into hasher: inout Hasher)
    func encode(to encoder: Encoder) throws
    static func == (a: String.StandardComparator, b: String.StandardComparator) -> Bool
    typealias Compared = String
    var hashValue: Int { get }
  }
  /// A `String` comparison performed using the given comparison options
  /// and locale.
  struct Comparator : SortComparator, Codable {
    let options: String.CompareOptions
    /// The locale to use for comparison if the comparator is localized,
    /// otherwise nil.
    let locale: Locale?
    var order: SortOrder
    init(options: String.CompareOptions, locale: Locale? = Locale.current, order: SortOrder = .forward)
    /// Creates a `String.Comparator` that represents the same comparison
    /// as the given `String.StandardComparator`.
    ///
    /// - Parameters:
    ///    - standardComparison: The `String.StandardComparator` to convert.
    init(_ standardComparison: String.StandardComparator)
    init(from decoder: Decoder) throws
    func compare(_ lhs: String, _ rhs: String) -> ComparisonResult
    func hash(into hasher: inout Hasher)
    func encode(to encoder: Encoder) throws
    static func == (a: String.Comparator, b: String.Comparator) -> Bool
    typealias Compared = String
    var hashValue: Int { get }
  }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Never : SortComparator {
  typealias Compared = Never
  func compare(_ lhs: Never, _ rhs: Never) -> ComparisonResult
  var order: SortOrder
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {
  /// Returns the elements of the sequence, sorted using the given comparator
  /// to compare elements.
  ///
  /// - Parameters:
  ///   - comparator: the comparator to use in ordering elements
  /// - Returns: an array of the elements sorted using `comparator`.
  func sorted<Comparator>(using comparator: Comparator) -> [Self.Element] where Comparator : SortComparator, Self.Element == Comparator.Compared
  /// Returns the elements of the sequence, sorted using the given array of
  /// `SortComparator`s to compare elements.
  ///
  /// - Parameters:
  ///   - comparators: an array of comparators used to compare elements. The
  ///   first comparator specifies the primary comparator to be used in
  ///   sorting the sequence's elements. Any subsequent comparators are used
  ///   to further refine the order of elements with equal values.
  /// - Returns: an array of the elements sorted using `comparators`.
  func sorted<S, Comparator>(using comparators: S) -> [Self.Element] where S : Sequence, Comparator : SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {
  /// If `lhs` is ordered before `rhs` in the ordering described by the given
  /// sequence of `SortComparator`s
  ///
  /// The first element of the sequence of comparators specifies the primary
  /// comparator to be used in sorting the sequence's elements. Any subsequent
  /// comparators are used to further refine the order of elements with equal
  /// values.
  func compare<Comparator>(_ lhs: Comparator.Compared, _ rhs: Comparator.Compared) -> ComparisonResult where Comparator : SortComparator, Comparator == Self.Element
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MutableCollection where Self : RandomAccessCollection {
  /// Sorts the collection using the given comparator to compare elements.
  /// - Parameters:
  ///     - comparator: the sort comparator used to compare elements.
  mutating func sort<Comparator>(using comparator: Comparator) where Comparator : SortComparator, Self.Element == Comparator.Compared
  /// Sorts the collection using the given array of `SortComparator`s to
  /// compare elements.
  ///
  /// - Parameters:
  ///   - comparators: an array of comparators used to compare elements. The
  ///   first comparator specifies the primary comparator to be used in
  ///   sorting the sequence's elements. Any subsequent comparators are used
  ///   to further refine the order of elements with equal values.
  mutating func sort<S, Comparator>(using comparators: S) where S : Sequence, Comparator : SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}

extension URLCache {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  convenience init(memoryCapacity: Int, diskCapacity: Int, directory: URL? = nil)
}

extension UnsafeRawBufferPointer : DataProtocol {
  var regions: CollectionOfOne<UnsafeRawBufferPointer> { get }
  typealias Regions = CollectionOfOne<UnsafeRawBufferPointer>
}

extension UnsafeBufferPointer : DataProtocol where Element == UInt8 {
  var regions: CollectionOfOne<UnsafeBufferPointer<UInt8>> { get }
  typealias Regions = CollectionOfOne<UnsafeBufferPointer<UInt8>>
}

extension Error where Self : CustomNSError {
  /// Default implementation for customized NSErrors.
  var _domain: String { get }
  /// Default implementation for customized NSErrors.
  var _code: Int { get }
}

extension Error where Self : CustomNSError, Self : RawRepresentable, Self.RawValue : FixedWidthInteger {
  /// Default implementation for customized NSErrors.
  var _code: Int { get }
}

extension Error {
  /// Retrieve the localized description for this error.
  var localizedDescription: String { get }
}

extension NSError : Error {
  @nonobjc var _domain: String { get }
  @nonobjc var _code: Int { get }
  @nonobjc var _userInfo: AnyObject? { get }
  /// The "embedded" NSError is itself.
  @nonobjc func _getEmbeddedNSError() -> AnyObject?
}

extension CFError : Error {
  var _domain: String { get }
  var _code: Int { get }
  var _userInfo: AnyObject? { get }
  /// The "embedded" NSError is itself.
  func _getEmbeddedNSError() -> AnyObject?
}

extension _SwiftNewtypeWrapper where Self.RawValue == Error {
  @inlinable func _bridgeToObjectiveC() -> NSError
  @inlinable static func _forceBridgeFromObjectiveC(_ source: NSError, result: inout Self?)
  @inlinable static func _conditionallyBridgeFromObjectiveC(_ source: NSError, result: inout Self?) -> Bool
  @inlinable @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSError?) -> Self
}

extension POSIXErrorCode : _ErrorCodeProtocol {
  typealias _ErrorType = POSIXError
}

extension MachErrorCode : _ErrorCodeProtocol {
  typealias _ErrorType = MachError
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Dictionary where Key == NSAttributedString.Key, Value == Any {
  init(_ container: AttributeContainer)
  init<S>(_ container: AttributeContainer, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope
  init<S>(_ container: AttributeContainer, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSAttributedString {
  convenience init(_ attrStr: AttributedString)
  convenience init<S>(_ attrStr: AttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope
  convenience init<S>(_ attrStr: AttributedString, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String.Index {
  init?<S>(_ sourcePosition: AttributedString.Index, within target: S) where S : StringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension _NSRange {
  init<R, S>(_ region: R, in target: S) where R : RangeExpression, S : AttributedStringProtocol, R.Bound == AttributedString.Index
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == AttributedString.Index {
  init?<S>(_ range: NSRange, in attrStr: S) where S : AttributedStringProtocol
  init?<R, S>(_ region: R, in attrStr: S) where R : RangeExpression, S : AttributedStringProtocol, R.Bound == String.Index
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == String.Index {
  init?<R, S>(_ region: R, in string: S) where R : RangeExpression, S : StringProtocol, R.Bound == AttributedString.Index
}

extension Int8 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int8?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int8?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int8
  typealias _ObjectiveCType = NSNumber
}

extension UInt8 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt8?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt8?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt8
  typealias _ObjectiveCType = NSNumber
}

extension Int16 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int16?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int16?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int16
  typealias _ObjectiveCType = NSNumber
}

extension UInt16 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt16?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt16?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt16
  typealias _ObjectiveCType = NSNumber
}

extension Int32 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int32?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int32?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int32
  typealias _ObjectiveCType = NSNumber
}

extension UInt32 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt32?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt32?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt32
  typealias _ObjectiveCType = NSNumber
}

extension Int64 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int64?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int64?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int64
  typealias _ObjectiveCType = NSNumber
}

extension UInt64 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt64?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt64?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt64
  typealias _ObjectiveCType = NSNumber
}

extension Int : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int
  typealias _ObjectiveCType = NSNumber
}

extension UInt : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt
  typealias _ObjectiveCType = NSNumber
}

extension Float : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Float?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Float?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Float
  typealias _ObjectiveCType = NSNumber
}

extension Double : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Double?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Double?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Double
  typealias _ObjectiveCType = NSNumber
}

extension Bool : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Bool?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Bool?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Bool
  typealias _ObjectiveCType = NSNumber
}

extension CGFloat : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  init(_ number: __shared NSNumber)
  init(truncating number: __shared NSNumber)
  init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSNumber
  static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout CGFloat?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout CGFloat?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> CGFloat
  typealias _ObjectiveCType = NSNumber
}

extension NSNumber : ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, ExpressibleByBooleanLiteral {
  /// Create an instance initialized to `value`.
  @nonobjc required convenience init(integerLiteral value: Int)
  /// Create an instance initialized to `value`.
  @nonobjc required convenience init(floatLiteral value: Double)
  /// Create an instance initialized to `value`.
  @nonobjc required convenience init(booleanLiteral value: Bool)
  typealias BooleanLiteralType = Bool
  typealias FloatLiteralType = Double
  typealias IntegerLiteralType = Int
}

extension NSNumber : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSMeasurement : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension MeasurementFormatter {
  func string<UnitType>(from measurement: Measurement<UnitType>) -> String where UnitType : Unit
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointRoundingRule : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryFloatingPoint {
  /// Format `self` with `FloatingPointFormatStyle()`.
  func formatted() -> String
  /// Format `self` with the given format.
  func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle
  /// Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.
  func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryFloatingPoint {
  /// Initialize an instance by parsing `value` with the given `strategy`.
  init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput : BinaryFloatingPoint
  init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : ParseStrategy
  /// Initialize an instance by parsing `value` with a `ParseStrategy` created with the given `format` and the `lenient` argument.
  init(_ value: String, format: FloatingPointFormatStyle<Self>, lenient: Bool = true) throws
  init(_ value: String, format: FloatingPointFormatStyle<Self>.Percent, lenient: Bool = true) throws
  init(_ value: String, format: FloatingPointFormatStyle<Self>.Currency, lenient: Bool = true) throws
}

extension String {
  struct Encoding : RawRepresentable {
    var rawValue: UInt
    init(rawValue: UInt)
    static let ascii: String.Encoding
    static let nextstep: String.Encoding
    static let japaneseEUC: String.Encoding
    static let utf8: String.Encoding
    static let isoLatin1: String.Encoding
    static let symbol: String.Encoding
    static let nonLossyASCII: String.Encoding
    static let shiftJIS: String.Encoding
    static let isoLatin2: String.Encoding
    static let unicode: String.Encoding
    static let windowsCP1251: String.Encoding
    static let windowsCP1252: String.Encoding
    static let windowsCP1253: String.Encoding
    static let windowsCP1254: String.Encoding
    static let windowsCP1250: String.Encoding
    static let iso2022JP: String.Encoding
    static let macOSRoman: String.Encoding
    static let utf16: String.Encoding
    static let utf16BigEndian: String.Encoding
    static let utf16LittleEndian: String.Encoding
    static let utf32: String.Encoding
    static let utf32BigEndian: String.Encoding
    static let utf32LittleEndian: String.Encoding
    typealias RawValue = UInt
  }
  typealias EncodingConversionOptions = NSString.EncodingConversionOptions
  typealias EnumerationOptions = NSString.EnumerationOptions
  typealias CompareOptions = NSString.CompareOptions
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {
  func formatted<S>(_ style: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence where Self.Element == String {
  func formatted() -> String
}

extension Array : ContiguousBytes where Element == UInt8 {
}

extension ArraySlice : ContiguousBytes where Element == UInt8 {
}

extension ContiguousArray : ContiguousBytes where Element == UInt8 {
}

extension UnsafeRawBufferPointer : ContiguousBytes {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension UnsafeMutableRawBufferPointer : ContiguousBytes {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension UnsafeBufferPointer : ContiguousBytes where Element == UInt8 {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension UnsafeMutableBufferPointer : ContiguousBytes where Element == UInt8 {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension EmptyCollection : ContiguousBytes where Element == UInt8 {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension CollectionOfOne : ContiguousBytes where Element == UInt8 {
  @inlinable func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension Slice : ContiguousBytes where Base : ContiguousBytes {
  func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}

extension _NSRange : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout NSRange?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout NSRange?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> NSRange
  typealias _ObjectiveCType = NSValue
}

extension CGRect : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGRect?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGRect?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGRect
  typealias _ObjectiveCType = NSValue
}

extension CGPoint : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGPoint?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGPoint?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGPoint
  typealias _ObjectiveCType = NSValue
}

extension CGVector : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGVector?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGVector?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGVector
  typealias _ObjectiveCType = NSValue
}

extension CGSize : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGSize?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGSize?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGSize
  typealias _ObjectiveCType = NSValue
}

extension CGAffineTransform : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGAffineTransform?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGAffineTransform?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGAffineTransform
  typealias _ObjectiveCType = NSValue
}

extension NSValue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  func value<StoredType>(of type: StoredType.Type) -> StoredType?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String {
  init(_ attrStrSlice: Slice<AttributedString.CharacterView>)
}

extension NSIndexSet : Sequence {
  /// Return an *iterator* over the elements of this *sequence*.
  ///
  /// - Complexity: O(1).
  func makeIterator() -> NSIndexSetIterator
  /// A value less than or equal to the number of elements in the collection.
  ///
  /// - Complexity: O(1).
  @_alwaysEmitIntoClient @nonobjc var underestimatedCount: Int { get }
  typealias Element = NSIndexSetIterator.Element
  typealias Iterator = NSIndexSetIterator
}

@available(macOS 10.11, iOS 9.0, *)
extension NSPersonNameComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InlinePresentationIntent : Hashable, Codable {
}

extension NSCharacterSet : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension NSSortDescriptor {
  /// Creates an `NSSortDescriptor` representing the same sort as the given
  /// `SortDescriptor`.
  ///
  /// - Parameters:
  ///     - sortDescriptor: The `SortDescriptor` to convert.
  convenience init<Compared>(_ sortDescriptor: SortDescriptor<Compared>)
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {
  /**
   A non-blocking sequence of `UnicodeScalars` created by decoding the elements of `self` as UTF8.
   */
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var unicodeScalars: AsyncUnicodeScalarSequence<Self> { get }
}

extension NSURLComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.10, iOS 8.0, *)
extension NSURLQueryItem : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSDate : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension FileHandle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  struct AsyncBytes : AsyncSequence {
    typealias Element = UInt8
    typealias AsyncIterator = FileHandle.AsyncBytes.Iterator
    func makeAsyncIterator() -> FileHandle.AsyncBytes.Iterator
    @frozen struct Iterator : AsyncIteratorProtocol {
      typealias Element = UInt8
      @usableFromInline
      var buffer: _AsyncBytesBuffer
      @inlinable @inline(__always) mutating func next() async throws -> UInt8?
    }
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  var bytes: FileHandle.AsyncBytes { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ISO8601DateFormatter.Options : Hashable {
}

extension NSNotification : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSCalendar : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension String {
  /// An array of the encodings that strings support in the application's
  /// environment.
  static var availableStringEncodings: [String.Encoding] { get }
  /// The C-string encoding assumed for any method accepting a C string as an
  /// argument.
  static var defaultCStringEncoding: String.Encoding { get }
  /// Returns a human-readable string giving the name of the specified encoding.
  ///
  /// - Parameter encoding: A string encoding. For possible values, see
  ///   `String.Encoding`.
  /// - Returns: A human-readable string giving the name of `encoding` in the
  ///   current locale.
  static func localizedName(of encoding: String.Encoding) -> String
  /// Returns a string created by using a given format string as a
  /// template into which the remaining argument values are substituted
  /// according to the user's default locale.
  static func localizedStringWithFormat(_ format: String, _ arguments: CVarArg...) -> String
  /// Creates a string by copying the data from a given
  /// C array of UTF8-encoded bytes.
  init?(utf8String bytes: UnsafePointer<CChar>)
}

extension String {
  /// Creates a new string equivalent to the given bytes interpreted in the
  /// specified encoding.
  ///
  /// - Parameters:
  ///   - bytes: A sequence of bytes to interpret using `encoding`.
  ///   - encoding: The ecoding to use to interpret `bytes`.
  init?<S>(bytes: __shared S, encoding: String.Encoding) where S : Sequence, S.Element == UInt8
  /// Creates a new string that contains the specified number of bytes from the
  /// given buffer, interpreted in the specified encoding, and optionally
  /// frees the buffer.
  ///
  /// - Warning: This initializer is not memory-safe!
  init?(bytesNoCopy bytes: UnsafeMutableRawPointer, length: Int, encoding: String.Encoding, freeWhenDone flag: Bool)
  /// Creates a new string that contains the specified number of characters
  /// from the given C array of Unicode characters.
  init(utf16CodeUnits: UnsafePointer<unichar>, count: Int)
  /// Creates a new string that contains the specified number of characters
  /// from the given C array of UTF-16 code units.
  init(utf16CodeUnitsNoCopy: UnsafePointer<unichar>, count: Int, freeWhenDone flag: Bool)
  /// Produces a string created by reading data from the file at a
  /// given path interpreted using a given encoding.
  init(contentsOfFile path: __shared String, encoding enc: String.Encoding) throws
  /// Produces a string created by reading data from the file at
  /// a given path and returns by reference the encoding used to
  /// interpret the file.
  init(contentsOfFile path: __shared String, usedEncoding: inout String.Encoding) throws
  init(contentsOfFile path: __shared String) throws
  /// Produces a string created by reading data from a given URL
  /// interpreted using a given encoding.  Errors are written into the
  /// inout `error` argument.
  init(contentsOf url: __shared URL, encoding enc: String.Encoding) throws
  /// Produces a string created by reading data from a given URL
  /// and returns by reference the encoding used to interpret the
  /// data.  Errors are written into the inout `error` argument.
  init(contentsOf url: __shared URL, usedEncoding: inout String.Encoding) throws
  init(contentsOf url: __shared URL) throws
  /// Produces a string containing the bytes in a given C array,
  /// interpreted according to a given encoding.
  init?(cString: UnsafePointer<CChar>, encoding enc: String.Encoding)
  /// Returns a `String` initialized by converting given `data` into
  /// Unicode characters using a given `encoding`.
  init?(data: __shared Data, encoding: String.Encoding)
  /// Returns a `String` object initialized by using a given
  /// format string as a template into which the remaining argument
  /// values are substituted.
  init(format: __shared String, _ arguments: CVarArg...)
  /// Returns a `String` object initialized by using a given
  /// format string as a template into which the remaining argument
  /// values are substituted according to the user's default locale.
  init(format: __shared String, arguments: __shared [CVarArg])
  /// Returns a `String` object initialized by using a given
  /// format string as a template into which the remaining argument
  /// values are substituted according to given locale information.
  init(format: __shared String, locale: __shared Locale?, _ args: CVarArg...)
  /// Returns a `String` object initialized by using a given
  /// format string as a template into which the remaining argument
  /// values are substituted according to given locale information.
  init(format: __shared String, locale: __shared Locale?, arguments: __shared [CVarArg])
}

extension StringProtocol {
  @inlinable func _toRelativeNSRange(_ r: Range<String.Index>) -> NSRange
  /// Returns a Boolean value that indicates whether the string can be
  /// converted to the specified encoding without loss of information.
  ///
  /// - Parameter encoding: A string encoding.
  /// - Returns: `true` if the string can be encoded in `encoding` without loss
  ///   of information; otherwise, `false`.
  func canBeConverted(to encoding: String.Encoding) -> Bool
  /// A copy of the string with each word changed to its corresponding
  /// capitalized spelling.
  ///
  /// This property performs the canonical (non-localized) mapping. It is
  /// suitable for programming operations that require stable results not
  /// depending on the current locale.
  ///
  /// A capitalized string is a string with the first character in each word
  /// changed to its corresponding uppercase value, and all remaining
  /// characters set to their corresponding lowercase values. A "word" is any
  /// sequence of characters delimited by spaces, tabs, or line terminators.
  /// Some common word delimiting punctuation isn't considered, so this
  /// property may not generally produce the desired results for multiword
  /// strings. See the `getLineStart(_:end:contentsEnd:for:)` method for
  /// additional information.
  ///
  /// Case transformations aren’t guaranteed to be symmetrical or to produce
  /// strings of the same lengths as the originals.
  var capitalized: String { get }
  /// A capitalized representation of the string that is produced
  /// using the current locale.
  @available(macOS 10.11, iOS 9.0, *)
  var localizedCapitalized: String { get }
  /// Returns a capitalized representation of the string
  /// using the specified locale.
  func capitalized(with locale: Locale?) -> String
  /// Returns the result of invoking `compare:options:` with
  /// `NSCaseInsensitiveSearch` as the only option.
  func caseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol
  func commonPrefix<T>(with aString: T, options: String.CompareOptions = []) -> String where T : StringProtocol
  func compare<T>(_ aString: T, options mask: String.CompareOptions = [], range: Range<Self.Index>? = nil, locale: Locale? = nil) -> ComparisonResult where T : StringProtocol
  /// Interprets the string as a path in the file system and
  /// attempts to perform filename completion, returning a numeric
  /// value that indicates whether a match was possible, and by
  /// reference the longest path that matches the string.
  ///
  /// - Returns: The actual number of matching paths.
  func completePath(into outputName: UnsafeMutablePointer<String>? = nil, caseSensitive: Bool, matchesInto outputArray: UnsafeMutablePointer<[String]>? = nil, filterTypes: [String]? = nil) -> Int
  /// Returns an array containing substrings from the string
  /// that have been divided by characters in the given set.
  func components(separatedBy separator: CharacterSet) -> [String]
  func components<T>(separatedBy separator: T) -> [String] where T : StringProtocol
  /// Returns a representation of the string as a C string
  /// using a given encoding.
  func cString(using encoding: String.Encoding) -> [CChar]?
  /// Returns a `Data` containing a representation of
  /// the `String` encoded using a given encoding.
  func data(using encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?
  /// A string created by normalizing the string's contents using Form D.
  var decomposedStringWithCanonicalMapping: String { get }
  /// A string created by normalizing the string's contents using Form KD.
  var decomposedStringWithCompatibilityMapping: String { get }
  /// Enumerates all the lines in a string.
  func enumerateLines(invoking body: @escaping (_ line: String, _ stop: inout Bool) -> Void)
  /// The fastest encoding to which the string can be converted without loss
  /// of information.
  var fastestEncoding: String.Encoding { get }
  /// Converts the `String`'s content to a given encoding and
  /// stores them in a buffer.
  /// - Note: will store a maximum of `min(buffer.count, maxLength)` bytes.
  func getCString(_ buffer: inout [CChar], maxLength: Int, encoding: String.Encoding) -> Bool
  /// An unsigned integer that can be used as a hash table address.
  var hash: Int { get }
  /// Returns the number of bytes required to store the
  /// `String` in a given encoding.
  func lengthOfBytes(using encoding: String.Encoding) -> Int
  /// Compares the string and the given string using a case-insensitive,
  /// localized, comparison.
  func localizedCaseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol
  /// Compares the string and the given string using a localized comparison.
  func localizedCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol
  /// Compares the string and the given string as sorted by the Finder.
  func localizedStandardCompare<T>(_ string: T) -> ComparisonResult where T : StringProtocol
  /// A lowercase version of the string that is produced using the current
  /// locale.
  @available(macOS 10.11, iOS 9.0, *)
  var localizedLowercase: String { get }
  /// Returns a version of the string with all letters
  /// converted to lowercase, taking into account the specified
  /// locale.
  func lowercased(with locale: Locale?) -> String
  /// Returns the maximum number of bytes needed to store the
  /// `String` in a given encoding.
  func maximumLengthOfBytes(using encoding: String.Encoding) -> Int
  /// A string created by normalizing the string's contents using Form C.
  var precomposedStringWithCanonicalMapping: String { get }
  /// A string created by normalizing the string's contents using Form KC.
  var precomposedStringWithCompatibilityMapping: String { get }
  /// Parses the `String` as a text representation of a
  /// property list, returning an NSString, NSData, NSArray, or
  /// NSDictionary object, according to the topmost element.
  func propertyList() -> Any
  /// Returns a dictionary object initialized with the keys and
  /// values found in the `String`.
  func propertyListFromStringsFileFormat() -> [String : String]
  /// Returns a Boolean value indicating whether the string contains the given
  /// string, taking the current locale into account.
  ///
  /// This is the most appropriate method for doing user-level string searches,
  /// similar to how searches are done generally in the system.  The search is
  /// locale-aware, case and diacritic insensitive.  The exact list of search
  /// options applied may change over time.
  @available(macOS 10.11, iOS 9.0, *)
  func localizedStandardContains<T>(_ string: T) -> Bool where T : StringProtocol
  /// The smallest encoding to which the string can be converted without
  /// loss of information.
  var smallestEncoding: String.Encoding { get }
  /// Returns a new string created by replacing all characters in the string
  /// not in the specified set with percent encoded characters.
  func addingPercentEncoding(withAllowedCharacters allowedCharacters: CharacterSet) -> String?
  /// Returns a string created by appending a string constructed from a given
  /// format string and the following arguments.
  func appendingFormat<T>(_ format: T, _ arguments: CVarArg...) -> String where T : StringProtocol
  func appending<T>(_ aString: T) -> String where T : StringProtocol
  func folding(options: String.CompareOptions = [], locale: Locale?) -> String
  /// Returns a new string formed from the `String` by either
  /// removing characters from the end, or by appending as many
  /// occurrences as necessary of a given pad string.
  func padding<T>(toLength newLength: Int, withPad padString: T, startingAt padIndex: Int) -> String where T : StringProtocol
  /// A new string made from the string by replacing all percent encoded
  /// sequences with the matching UTF-8 characters.
  var removingPercentEncoding: String? { get }
  /// Returns a new string in which the characters in a
  /// specified range of the `String` are replaced by a given string.
  func replacingCharacters<T, R>(in range: R, with replacement: T) -> String where T : StringProtocol, R : RangeExpression, R.Bound == String.Index
  func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil) -> String where Target : StringProtocol, Replacement : StringProtocol
  /// Returns a new string made by replacing in the `String`
  /// all percent escapes with the matching characters as determined
  /// by a given encoding.
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  func replacingPercentEscapes(using encoding: String.Encoding) -> String?
  /// Returns a new string made by removing from both ends of
  /// the `String` characters contained in a given character set.
  func trimmingCharacters(in set: CharacterSet) -> String
  /// An uppercase version of the string that is produced using the current
  /// locale.
  @available(macOS 10.11, iOS 9.0, *)
  var localizedUppercase: String { get }
  /// Returns a version of the string with all letters
  /// converted to uppercase, taking into account the specified
  /// locale.
  func uppercased(with locale: Locale?) -> String
  /// Writes the contents of the `String` to a file at a given
  /// path using a given encoding.
  func write<T>(toFile path: T, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws where T : StringProtocol
  /// Writes the contents of the `String` to the URL specified
  /// by url using the specified encoding.
  func write(to url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
  /// Perform string transliteration.
  @available(macOS 10.11, iOS 9.0, *)
  func applyingTransform(_ transform: StringTransform, reverse: Bool) -> String?
  func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, invoking body: (String, Range<Self.Index>, Range<Self.Index>, inout Bool) -> Void) where T : StringProtocol, R : RangeExpression, R.Bound == String.Index
  func enumerateSubstrings<R>(in range: R, options opts: String.EnumerationOptions = [], _ body: @escaping (_ substring: String?, _ substringRange: Range<Self.Index>, _ enclosingRange: Range<Self.Index>, inout Bool) -> Void) where R : RangeExpression, R.Bound == String.Index
  func getBytes<R>(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer<Int>, encoding: String.Encoding, options: String.EncodingConversionOptions = [], range: R, remaining leftover: UnsafeMutablePointer<Range<Self.Index>>) -> Bool where R : RangeExpression, R.Bound == String.Index
  /// Returns by reference the beginning of the first line and
  /// the end of the last line touched by the given range.
  func getLineStart<R>(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, for range: R) where R : RangeExpression, R.Bound == String.Index
  /// Returns by reference the beginning of the first paragraph
  /// and the end of the last paragraph touched by the given range.
  func getParagraphStart<R>(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, for range: R) where R : RangeExpression, R.Bound == String.Index
  /// Returns the range of characters representing the line or lines
  /// containing a given range.
  func lineRange<R>(for aRange: R) -> Range<Self.Index> where R : RangeExpression, R.Bound == String.Index
  func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, tokenRanges: UnsafeMutablePointer<[Range<Self.Index>]>? = nil) -> [String] where T : StringProtocol, R : RangeExpression, R.Bound == String.Index
  /// Returns the range of characters representing the
  /// paragraph or paragraphs containing a given range.
  func paragraphRange<R>(for aRange: R) -> Range<Self.Index> where R : RangeExpression, R.Bound == String.Index
  func rangeOfCharacter(from aSet: CharacterSet, options mask: String.CompareOptions = [], range aRange: Range<Self.Index>? = nil) -> Range<Self.Index>?
  /// Returns the range in the `String` of the composed
  /// character sequence located at a given index.
  func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Range<Self.Index>
  /// Returns the range in the string of the composed character
  /// sequences for a given range.
  func rangeOfComposedCharacterSequences<R>(for range: R) -> Range<Self.Index> where R : RangeExpression, R.Bound == String.Index
  func range<T>(of aString: T, options mask: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil, locale: Locale? = nil) -> Range<Self.Index>? where T : StringProtocol
  /// Finds and returns the range of the first occurrence of a given string,
  /// taking the current locale into account.  Returns `nil` if the string was
  /// not found.
  ///
  /// This is the most appropriate method for doing user-level string searches,
  /// similar to how searches are done generally in the system.  The search is
  /// locale-aware, case and diacritic insensitive.  The exact list of search
  /// options applied may change over time.
  @available(macOS 10.11, iOS 9.0, *)
  func localizedStandardRange<T>(of string: T) -> Range<Self.Index>? where T : StringProtocol
  /// Returns a representation of the `String` using a given
  /// encoding to determine the percent escapes necessary to convert
  /// the `String` into a legal URL string.
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  func addingPercentEscapes(using encoding: String.Encoding) -> String?
  /// Returns `true` if `other` is non-empty and contained within `self` by
  /// case-sensitive, non-literal search. Otherwise, returns `false`.
  ///
  /// Equivalent to `self.range(of: other) != nil`
  func contains<T>(_ other: T) -> Bool where T : StringProtocol
  /// Returns a Boolean value indicating whether the given string is non-empty
  /// and contained within this string by case-insensitive, non-literal
  /// search, taking into account the current locale.
  ///
  /// Locale-independent case-insensitive operation, and other needs, can be
  /// achieved by calling `range(of:options:range:locale:)`.
  ///
  /// Equivalent to:
  ///
  ///     range(of: other, options: .caseInsensitiveSearch,
  ///           locale: Locale.current) != nil
  func localizedCaseInsensitiveContains<T>(_ other: T) -> Bool where T : StringProtocol
}

extension StringProtocol {
  /// Returns a new string containing the characters of the
  /// `String` from the one at a given index to the end.
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  func substring(from index: Self.Index) -> String
  /// Returns a new string containing the characters of the
  /// `String` up to, but not including, the one at a given index.
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  func substring(to index: Self.Index) -> String
  /// Returns a string object containing the characters of the
  /// `String` that lie within a given range.
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  func substring(with aRange: Range<Self.Index>) -> String
}

extension StringProtocol {
  /// Returns a file system-specific representation of the `String`.
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  var fileSystemRepresentation: [CChar] { get }
  /// Interprets the `String` as a system-independent path and
  /// fills a buffer with a C-string in a format and encoding suitable
  /// for use with file-system calls.
  /// - Note: will store a maximum of `min(buffer.count, maxLength)` bytes.
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  func getFileSystemRepresentation(_ buffer: inout [CChar], maxLength: Int) -> Bool
  /// Returns the last path component of the `String`.
  @available(*, unavailable, message: "Use lastPathComponent on URL instead.")
  var lastPathComponent: String { get }
  /// Returns the number of Unicode characters in the `String`.
  @available(*, unavailable, message: "Take the count of a UTF-16 view instead, i.e. str.utf16.count")
  var utf16Count: Int { get }
  /// Returns an array of NSString objects containing, in
  /// order, each path component of the `String`.
  @available(*, unavailable, message: "Use pathComponents on URL instead.")
  var pathComponents: [String] { get }
  /// Interprets the `String` as a path and returns the
  /// `String`'s extension, if any.
  @available(*, unavailable, message: "Use pathExtension on URL instead.")
  var pathExtension: String { get }
  /// Returns a new string that replaces the current home
  /// directory portion of the current path with a tilde (`~`)
  /// character.
  @available(*, unavailable, message: "Use abbreviatingWithTildeInPath on NSString instead.")
  var abbreviatingWithTildeInPath: String { get }
  /// Returns a new string made by appending to the `String` a given string.
  @available(*, unavailable, message: "Use appendingPathComponent on URL instead.")
  func appendingPathComponent(_ aString: String) -> String
  /// Returns a new string made by appending to the `String` an
  /// extension separator followed by a given extension.
  @available(*, unavailable, message: "Use appendingPathExtension on URL instead.")
  func appendingPathExtension(_ ext: String) -> String?
  /// Returns a new string made by deleting the last path
  /// component from the `String`, along with any final path
  /// separator.
  @available(*, unavailable, message: "Use deletingLastPathComponent on URL instead.")
  var deletingLastPathComponent: String { get }
  /// Returns a new string made by deleting the extension (if
  /// any, and only the last) from the `String`.
  @available(*, unavailable, message: "Use deletingPathExtension on URL instead.")
  var deletingPathExtension: String { get }
  /// Returns a new string made by expanding the initial
  /// component of the `String` to its full path value.
  @available(*, unavailable, message: "Use expandingTildeInPath on NSString instead.")
  var expandingTildeInPath: String { get }
  @available(*, unavailable, renamed: "folding(options:locale:)")
  func folding(_ options: String.CompareOptions = [], locale: Locale?) -> String
  /// Returns a new string made from the `String` by resolving
  /// all symbolic links and standardizing path.
  @available(*, unavailable, message: "Use resolvingSymlinksInPath on URL instead.")
  var resolvingSymlinksInPath: String { get }
  /// Returns a new string made by removing extraneous path
  /// components from the `String`.
  @available(*, unavailable, message: "Use standardizingPath on URL instead.")
  var standardizingPath: String { get }
  /// Returns an array of strings made by separately appending
  /// to the `String` each string in a given array.
  @available(*, unavailable, message: "Map over paths with appendingPathComponent instead.")
  func strings(byAppendingPaths paths: [String]) -> [String]
}

extension String {
  @available(*, unavailable, renamed: "localizedName(of:)")
  static func localizedNameOfStringEncoding(_ encoding: String.Encoding) -> String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  static func pathWithComponents(_ components: [String]) -> String
  /// Returns a string built from the strings in a given array
  /// by concatenating them with a path separator between each pair.
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  static func path(withComponents components: [String]) -> String
}

extension StringProtocol {
  @available(*, unavailable, renamed: "canBeConverted(to:)")
  func canBeConvertedToEncoding(_ encoding: String.Encoding) -> Bool
  @available(*, unavailable, renamed: "capitalizedString(with:)")
  func capitalizedStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "commonPrefix(with:options:)")
  func commonPrefixWith(_ aString: String, options: String.CompareOptions) -> String
  @available(*, unavailable, renamed: "completePath(into:outputName:caseSensitive:matchesInto:filterTypes:)")
  func completePathInto(_ outputName: UnsafeMutablePointer<String>? = nil, caseSensitive: Bool, matchesInto matchesIntoArray: UnsafeMutablePointer<[String]>? = nil, filterTypes: [String]? = nil) -> Int
  @available(*, unavailable, renamed: "components(separatedBy:)")
  func componentsSeparatedByCharactersIn(_ separator: CharacterSet) -> [String]
  @available(*, unavailable, renamed: "components(separatedBy:)")
  func componentsSeparatedBy(_ separator: String) -> [String]
  @available(*, unavailable, renamed: "cString(usingEncoding:)")
  func cStringUsingEncoding(_ encoding: String.Encoding) -> [CChar]?
  @available(*, unavailable, renamed: "data(usingEncoding:allowLossyConversion:)")
  func dataUsingEncoding(_ encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?
  @available(*, unavailable, renamed: "enumerateLinguisticTags(in:scheme:options:orthography:_:)")
  func enumerateLinguisticTagsIn(_ range: Range<Self.Index>, scheme tagScheme: String, options opts: NSLinguisticTagger.Options, orthography: NSOrthography?, _ body: (String, Range<Self.Index>, Range<Self.Index>, inout Bool) -> Void)
  @available(*, unavailable, renamed: "enumerateSubstrings(in:options:_:)")
  func enumerateSubstringsIn(_ range: Range<Self.Index>, options opts: String.EnumerationOptions = [], _ body: (_ substring: String?, _ substringRange: Range<Self.Index>, _ enclosingRange: Range<Self.Index>, inout Bool) -> Void)
  @available(*, unavailable, renamed: "getBytes(_:maxLength:usedLength:encoding:options:range:remaining:)")
  func getBytes(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer<Int>, encoding: String.Encoding, options: String.EncodingConversionOptions = [], range: Range<Self.Index>, remainingRange leftover: UnsafeMutablePointer<Range<Self.Index>>) -> Bool
  @available(*, unavailable, renamed: "getLineStart(_:end:contentsEnd:for:)")
  func getLineStart(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, forRange: Range<Self.Index>)
  @available(*, unavailable, renamed: "getParagraphStart(_:end:contentsEnd:for:)")
  func getParagraphStart(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, forRange: Range<Self.Index>)
  @available(*, unavailable, renamed: "lengthOfBytes(using:)")
  func lengthOfBytesUsingEncoding(_ encoding: String.Encoding) -> Int
  @available(*, unavailable, renamed: "lineRange(for:)")
  func lineRangeFor(_ aRange: Range<Self.Index>) -> Range<Self.Index>
  @available(*, unavailable, renamed: "linguisticTags(in:scheme:options:orthography:tokenRanges:)")
  func linguisticTagsIn(_ range: Range<Self.Index>, scheme tagScheme: String, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, tokenRanges: UnsafeMutablePointer<[Range<Self.Index>]>? = nil) -> [String]
  @available(*, unavailable, renamed: "lowercased(with:)")
  func lowercaseStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "maximumLengthOfBytes(using:)")
  func maximumLengthOfBytesUsingEncoding(_ encoding: String.Encoding) -> Int
  @available(*, unavailable, renamed: "paragraphRange(for:)")
  func paragraphRangeFor(_ aRange: Range<Self.Index>) -> Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfCharacter(from:options:range:)")
  func rangeOfCharacterFrom(_ aSet: CharacterSet, options mask: String.CompareOptions = [], range aRange: Range<Self.Index>? = nil) -> Range<Self.Index>?
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequence(at:)")
  func rangeOfComposedCharacterSequenceAt(_ anIndex: Self.Index) -> Range<Self.Index>
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequences(for:)")
  func rangeOfComposedCharacterSequencesFor(_ range: Range<Self.Index>) -> Range<Self.Index>
  @available(*, unavailable, renamed: "range(of:options:range:locale:)")
  func rangeOf(_ aString: String, options mask: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil, locale: Locale? = nil) -> Range<Self.Index>?
  @available(*, unavailable, renamed: "localizedStandardRange(of:)")
  func localizedStandardRangeOf(_ string: String) -> Range<Self.Index>?
  @available(*, unavailable, renamed: "addingPercentEncoding(withAllowedCharacters:)")
  func addingPercentEncodingWithAllowedCharacters(_ allowedCharacters: CharacterSet) -> String?
  @available(*, unavailable, renamed: "addingPercentEscapes(using:)")
  func addingPercentEscapesUsingEncoding(_ encoding: String.Encoding) -> String?
  @available(*, unavailable, renamed: "appendingFormat")
  func stringByAppendingFormat(_ format: String, _ arguments: CVarArg...) -> String
  @available(*, unavailable, renamed: "padding(toLength:with:startingAt:)")
  func byPaddingToLength(_ newLength: Int, withString padString: String, startingAt padIndex: Int) -> String
  @available(*, unavailable, renamed: "replacingCharacters(in:with:)")
  func replacingCharactersIn(_ range: Range<Self.Index>, withString replacement: String) -> String
  @available(*, unavailable, renamed: "replacingOccurrences(of:with:options:range:)")
  func replacingOccurrencesOf(_ target: String, withString replacement: String, options: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil) -> String
  @available(*, unavailable, renamed: "replacingPercentEscapes(usingEncoding:)")
  func replacingPercentEscapesUsingEncoding(_ encoding: String.Encoding) -> String?
  @available(*, unavailable, renamed: "trimmingCharacters(in:)")
  func byTrimmingCharactersIn(_ set: CharacterSet) -> String
  @available(*, unavailable, renamed: "strings(byAppendingPaths:)")
  func stringsByAppendingPaths(_ paths: [String]) -> [String]
  @available(*, unavailable, renamed: "substring(from:)")
  func substringFrom(_ index: Self.Index) -> String
  @available(*, unavailable, renamed: "substring(to:)")
  func substringTo(_ index: Self.Index) -> String
  @available(*, unavailable, renamed: "substring(with:)")
  func substringWith(_ aRange: Range<Self.Index>) -> String
  @available(*, unavailable, renamed: "uppercased(with:)")
  func uppercaseStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "write(toFile:atomically:encoding:)")
  func writeToFile(_ path: String, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
  @available(*, unavailable, renamed: "write(to:atomically:encoding:)")
  func writeToURL(_ url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
}

extension NSSet : Sequence {
  /// Return an *iterator* over the elements of this *sequence*.
  ///
  /// - Complexity: O(1).
  func makeIterator() -> NSFastEnumerationIterator
  /// A value less than or equal to the number of elements in the collection.
  ///
  /// - Complexity: O(1).
  @_alwaysEmitIntoClient @nonobjc var underestimatedCount: Int { get }
  typealias Element = Any
  typealias Iterator = NSFastEnumerationIterator
}

extension NSOrderedSet : Sequence {
  /// Return an *iterator* over the elements of this *sequence*.
  ///
  /// - Complexity: O(1).
  func makeIterator() -> NSFastEnumerationIterator
  /// A value less than or equal to the number of elements in the collection.
  ///
  /// - Complexity: O(1).
  @_alwaysEmitIntoClient @nonobjc var underestimatedCount: Int { get }
  typealias Element = Any
  typealias Iterator = NSFastEnumerationIterator
}

extension Set : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") func _bridgeToObjectiveC() -> NSSet
  static func _forceBridgeFromObjectiveC(_ s: NSSet, result: inout Set<Element>?)
  static func _conditionallyBridgeFromObjectiveC(_ x: NSSet, result: inout Set<Element>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ s: NSSet?) -> Set<Element>
  typealias _ObjectiveCType = NSSet
}

extension NSSet : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

extension NSOrderedSet {
  convenience init(objects elements: Any...)
}

extension NSSet {
  convenience init(objects elements: Any...)
}

extension NSSet : ExpressibleByArrayLiteral {
  required convenience init(arrayLiteral elements: Any...)
  typealias ArrayLiteralElement = Any
}

extension NSOrderedSet : ExpressibleByArrayLiteral {
  required convenience init(arrayLiteral elements: Any...)
  typealias ArrayLiteralElement = Any
}

extension NSSet {
  /// Initializes a newly allocated set and adds to it objects from
  /// another given set.
  ///
  /// - Returns: An initialized objects set containing the objects from
  ///   `set`. The returned set might be different than the original
  ///   receiver.
  @nonobjc convenience init(set anSet: __shared NSSet)
}

extension NSSet : CustomReflectable {
  var customMirror: Mirror { get }
}

extension Set : CVarArg {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String {
  struct LocalizationValue : Equatable, ExpressibleByStringInterpolation {
    init(_ value: String)
    @_semantics("localization_key.init_literal") init(stringLiteral value: String)
    @_semantics("localization_key.init_interpolation") init(stringInterpolation: String.LocalizationValue.StringInterpolation)
    struct StringInterpolation : StringInterpolationProtocol {
      @_semantics("localization.interpolation_init") init(literalCapacity: Int, interpolationCount: Int)
      @_semantics("localization.interpolation.appendLiteral") mutating func appendLiteral(_ literal: String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") mutating func appendInterpolation(_ string: String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") mutating func appendInterpolation<Subject>(_ subject: Subject) where Subject : NSObject
      @_transparent mutating func appendInterpolation<T>(_ value: T) where T : _FormatSpecifiable
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") mutating func appendInterpolation<T>(_ value: T, specifier: String) where T : _FormatSpecifiable
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : FormatStyle, F.FormatOutput : StringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") mutating func appendInterpolation<T, F>(_ value: T, format: F) where T == F.FormatInput, F : FormatStyle, F.FormatOutput : AttributedStringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") mutating func appendInterpolation(_ attrStr: AttributedString, options: AttributedString.InterpolationOptions = [])
      typealias StringLiteralType = String
    }
    static func == (a: String.LocalizationValue, b: String.LocalizationValue) -> Bool
    typealias ExtendedGraphemeClusterLiteralType = String
    typealias StringLiteralType = String
    typealias UnicodeScalarLiteralType = String
  }
  @_semantics("string.init_localized") init(localized keyAndValue: String.LocalizationValue, table: String? = nil, bundle: Bundle? = nil, locale: Locale = .current, comment: StaticString? = nil)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Int : _FormatSpecifiable {
  var _arg: Int64 { get }
  typealias _Arg = Int64
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Int8 : _FormatSpecifiable {
  var _arg: Int32 { get }
  typealias _Arg = Int32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Int16 : _FormatSpecifiable {
  var _arg: Int32 { get }
  typealias _Arg = Int32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Int32 : _FormatSpecifiable {
  var _arg: Int32 { get }
  typealias _Arg = Int32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Int64 : _FormatSpecifiable {
  var _arg: Int64 { get }
  typealias _Arg = Int64
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UInt : _FormatSpecifiable {
  var _arg: UInt64 { get }
  typealias _Arg = UInt64
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UInt8 : _FormatSpecifiable {
  var _arg: UInt32 { get }
  typealias _Arg = UInt32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UInt16 : _FormatSpecifiable {
  var _arg: UInt32 { get }
  typealias _Arg = UInt32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UInt32 : _FormatSpecifiable {
  var _arg: UInt32 { get }
  typealias _Arg = UInt32
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UInt64 : _FormatSpecifiable {
  var _arg: UInt64 { get }
  typealias _Arg = UInt64
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Float : _FormatSpecifiable {
  var _arg: Float { get }
  typealias _Arg = Float
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Double : _FormatSpecifiable {
  var _arg: Double { get }
  typealias _Arg = Double
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CGFloat : _FormatSpecifiable {
  var _arg: CGFloat { get }
  typealias _Arg = CGFloat
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryInteger {
  /// Format `self` using `IntegerFormatStyle()`
  func formatted() -> String
  /// Format `self` with the given format.
  func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle
  /// Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.
  func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryInteger {
  /// Initialize an instance by parsing `value` with the given `strategy`.
  init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput : BinaryInteger
  init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : ParseStrategy
  init(_ value: String, format: IntegerFormatStyle<Self>, lenient: Bool = true) throws
  init(_ value: String, format: IntegerFormatStyle<Self>.Percent, lenient: Bool = true) throws
  init(_ value: String, format: IntegerFormatStyle<Self>.Currency, lenient: Bool = true) throws
}

extension NSURLRequest : _HasCustomAnyHashableRepresentation {
  @nonobjc func _toCustomAnyHashable() -> AnyHashable?
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RunLoop : Scheduler {
  /// The scheduler time type used by the run loop.
  struct SchedulerTimeType : Strideable, Codable, Hashable {
    /// The date represented by this type.
    var date: Date
    /// Initializes a run loop scheduler time with the given date.
    ///
    /// - Parameter date: The date to represent.
    init(_ date: Date)
    /// Returns the distance to another run loop scheduler time.
    ///
    /// - Parameter other: Another dispatch queue time.
    /// - Returns: The time interval between this time and the provided time.
    func distance(to other: RunLoop.SchedulerTimeType) -> RunLoop.SchedulerTimeType.Stride
    /// Returns a run loop scheduler time calculated by advancing this instance’s time by the given interval.
    ///
    /// - Parameter n: A time interval to advance.
    /// - Returns: A dispatch queue time advanced by the given interval from this instance’s time.
    func advanced(by n: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType
    /// The interval by which run loop times advance.
    struct Stride : ExpressibleByFloatLiteral, Comparable, SignedNumeric, Codable, SchedulerTimeIntervalConvertible {
      typealias FloatLiteralType = TimeInterval
      typealias IntegerLiteralType = TimeInterval
      typealias Magnitude = TimeInterval
      /// The value of this time interval in seconds.
      var magnitude: TimeInterval
      /// The value of this time interval in seconds.
      var timeInterval: TimeInterval { get }
      init(integerLiteral value: TimeInterval)
      init(floatLiteral value: TimeInterval)
      init(_ timeInterval: TimeInterval)
      init?<T>(exactly source: T) where T : BinaryInteger
      static func < (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> Bool
      static func * (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride
      static func + (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride
      static func - (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride
      static func *= (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)
      static func += (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)
      static func -= (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)
      static func seconds(_ s: Int) -> RunLoop.SchedulerTimeType.Stride
      static func seconds(_ s: Double) -> RunLoop.SchedulerTimeType.Stride
      static func milliseconds(_ ms: Int) -> RunLoop.SchedulerTimeType.Stride
      static func microseconds(_ us: Int) -> RunLoop.SchedulerTimeType.Stride
      static func nanoseconds(_ ns: Int) -> RunLoop.SchedulerTimeType.Stride
      static func == (a: RunLoop.SchedulerTimeType.Stride, b: RunLoop.SchedulerTimeType.Stride) -> Bool
      func encode(to encoder: Encoder) throws
      init(from decoder: Decoder) throws
    }
    func hash(into hasher: inout Hasher)
    func encode(to encoder: Encoder) throws
    var hashValue: Int { get }
    init(from decoder: Decoder) throws
  }
  /// Options that affect the operation of the run loop scheduler.
  struct SchedulerOptions {
  }
  func schedule(options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void)
  func schedule(after date: RunLoop.SchedulerTimeType, tolerance: RunLoop.SchedulerTimeType.Stride, options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void)
  func schedule(after date: RunLoop.SchedulerTimeType, interval: RunLoop.SchedulerTimeType.Stride, tolerance: RunLoop.SchedulerTimeType.Stride, options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void) -> Cancellable
  var now: RunLoop.SchedulerTimeType { get }
  var minimumTolerance: RunLoop.SchedulerTimeType.Stride { get }
}

var NSNotFound: Int

let kCFStringEncodingASCII: CFStringEncoding { get }

@available(*, unavailable, renamed: "String.Encoding.ascii")
let NSASCIIStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.nextstep")
let NSNEXTSTEPStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.japaneseEUC")
let NSJapaneseEUCStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf8")
let NSUTF8StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.isoLatin1")
let NSISOLatin1StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.symbol")
let NSSymbolStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.nonLossyASCII")
let NSNonLossyASCIIStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.shiftJIS")
let NSShiftJISStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.isoLatin2")
let NSISOLatin2StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.unicode")
let NSUnicodeStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1251")
let NSWindowsCP1251StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1252")
let NSWindowsCP1252StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1253")
let NSWindowsCP1253StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1254")
let NSWindowsCP1254StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.windowsCP1250")
let NSWindowsCP1250StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.iso2022JP")
let NSISO2022JPStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.macOSRoman")
let NSMacOSRomanStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16")
let NSUTF16StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16BigEndian")
let NSUTF16BigEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf16LittleEndian")
let NSUTF16LittleEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32")
let NSUTF32StringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32BigEndian")
let NSUTF32BigEndianStringEncoding: String.Encoding { get }

@available(*, unavailable, renamed: "String.Encoding.utf32LittleEndian")
let NSUTF32LittleEndianStringEncoding: String.Encoding { get }

@_alwaysEmitIntoClient let int64Specifier: String { get }

@_alwaysEmitIntoClient let int32Specifier: String { get }

@_alwaysEmitIntoClient let uint64Specifier: String { get }

@_alwaysEmitIntoClient let uint32Specifier: String { get }

@_alwaysEmitIntoClient let floatSpecifier: String { get }

@_alwaysEmitIntoClient let doubleSpecifier: String { get }

