
/// Common protocol to which all actors conform.
///
/// The `Actor` protocol generalizes over all `actor` types. Actor types
/// implicitly conform to this protocol.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
protocol Actor : AnyActor {
  /// Retrieve the executor for this actor as an optimized, unowned
  /// reference.
  ///
  /// This property must always evaluate to the same executor for a
  /// given actor instance, and holding on to the actor must keep the
  /// executor alive.
  ///
  /// This property will be implicitly accessed when work needs to be
  /// scheduled onto this actor.  These accesses may be merged,
  /// eliminated, and rearranged with other work, and they may even
  /// be introduced when not strictly required.  Visible side effects
  /// are therefore strongly discouraged within this property.
  nonisolated var unownedExecutor: UnownedSerialExecutor { get }
}

/// Common marker protocol providing a shared "base" for both (local) `Actor`
/// and (potentially remote) `DistributedActor` types.
///
/// The `AnyActor` marker protocol generalizes over all actor types, including
/// distributed ones. In practice, this protocol can be used to restrict
/// protocols, or generic parameters to only be usable with actors, which
/// provides the guarantee that calls may be safely made on instances of given
/// type without worrying about the thread-safety of it -- as they are
/// guaranteed to follow the actor-style isolation semantics.
///
/// While both local and distributed actors are conceptually "actors", there are
/// some important isolation model differences between the two, which make it
/// impossible for one to refine the other.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_marker protocol AnyActor : AnyObject, Sendable {
}

/// An asynchronous sequence that maps a given closure over the asynchronous
/// sequenceâ€™s elements, omitting results that don't return a value.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncCompactMapSequence<Base, ElementOfResult> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async -> ElementOfResult?
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async -> ElementOfResult?)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncCompactMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The compact map sequence produces whatever type of element its
  /// transforming closure produces.
  typealias Element = ElementOfResult
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncCompactMapSequence<Base, ElementOfResult>.Iterator
  /// The iterator that produces elements of the compact map sequence.
  struct Iterator : AsyncIteratorProtocol {
    typealias Element = ElementOfResult
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async -> ElementOfResult?
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> ElementOfResult?)
    /// Produces the next element in the compact map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns `nil`. Otherwise, `next()` calls the
    /// transforming closure on the received element, returning it if the
    /// transform returns a non-`nil` value. If the transform returns `nil`,
    /// this method continues to wait for further elements until it gets one
    /// that transforms to a non-`nil` value.
    @inlinable mutating func next() async rethrows -> ElementOfResult?
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncCompactMapSequence<Base, ElementOfResult>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncCompactMapSequence : @unchecked Sendable where Base : Sendable, ElementOfResult : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncCompactMapSequence.Iterator : @unchecked Sendable where ElementOfResult : Sendable, Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence which omits a specified number of elements from the
/// base asynchronous sequence, then passes through all remaining elements.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncDropFirstSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let count: Int
  @usableFromInline
  init(_ base: Base, dropping count: Int)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropFirstSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The drop-first sequence produces whatever type of element its base
  /// iterator produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncDropFirstSequence<Base>.Iterator
  /// The iterator that produces elements of the drop-first sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    var count: Int
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, count: Int)
    /// Produces the next element in the drop-first sequence.
    ///
    /// Until reaching the number of elements to drop, this iterator calls
    /// `next()` on its base iterator and discards the result. If the base
    /// iterator returns `nil`, indicating the end of the sequence, this
    /// iterator returns `nil`. After reaching the number of elements to
    /// drop, this iterator passes along the result of calling `next()` on
    /// the base iterator.
    @inlinable mutating func next() async rethrows -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncDropFirstSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropFirstSequence {
  /// Omits a specified number of elements from the base asynchronous sequence,
  /// then passes through all remaining elements.
  ///
  /// When you call `dropFirst(_:)` on an asynchronous sequence that is already
  /// an `AsyncDropFirstSequence`, the returned sequence simply adds the new
  /// drop count to the current drop count.
  @inlinable __consuming func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Base>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropFirstSequence : Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropFirstSequence.Iterator : Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence which omits elements from the base sequence until a
/// given closure returns false, after which it passes through all remaining
/// elements.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncDropWhileSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let predicate: (Base.Element) async -> Bool
  @usableFromInline
  init(_ base: Base, predicate: @escaping (Base.Element) async -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropWhileSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The drop-while sequence produces whatever type of element its base
  /// sequence produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncDropWhileSequence<Base>.Iterator
  /// The iterator that produces elements of the drop-while sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    var predicate: ((Base.Element) async -> Bool)?
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Bool)
    /// Produces the next element in the drop-while sequence.
    ///
    /// This iterator calls `next()` on its base iterator and evaluates the
    /// result with the `predicate` closure. As long as the predicate returns
    /// `true`, this method returns `nil`. After the predicate returns `false`,
    /// for a value received from the base iterator, this method returns that
    /// value. After that, the iterator returns values received from its
    /// base iterator as-is, and never executes the predicate closure again.
    @inlinable mutating func next() async rethrows -> Base.Element?
    typealias Element = Base.Element
  }
  /// Creates an instance of the drop-while sequence iterator.
  @inlinable __consuming func makeAsyncIterator() -> AsyncDropWhileSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropWhileSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncDropWhileSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence that contains, in order, the elements of
/// the base sequence that satisfy a given predicate.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncFilterSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let isIncluded: (AsyncFilterSequence<Base>.Element) async -> Bool
  @usableFromInline
  init(_ base: Base, isIncluded: @escaping (Base.Element) async -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFilterSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The filter sequence produces whatever type of element its base
  /// sequence produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncFilterSequence<Base>.Iterator
  /// The iterator that produces elements of the filter sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let isIncluded: (Base.Element) async -> Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async -> Bool)
    /// Produces the next element in the filter sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns nil. Otherwise, `next()` evaluates the
    /// result with the `predicate` closure. If the closure returns `true`,
    /// `next()` returns the received element; otherwise it awaits the next
    /// element from the base iterator.
    @inlinable mutating func next() async rethrows -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncFilterSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFilterSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFilterSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence that concatenates the results of calling a given
/// transformation with each element of this sequence.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncFlatMapSequence<Base, SegmentOfResult> where Base : AsyncSequence, SegmentOfResult : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async -> SegmentOfResult
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async -> SegmentOfResult)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFlatMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The flat map sequence produces the type of element in the asynchronous
  /// sequence produced by the `transform` closure.
  typealias Element = SegmentOfResult.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator
  /// The iterator that produces elements of the flat map sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async -> SegmentOfResult
    @usableFromInline
    var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    var finished: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> SegmentOfResult)
    /// Produces the next element in the flat map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns `nil`. Otherwise, `next()` calls the
    /// transforming closure on the received element, takes the resulting
    /// asynchronous sequence, and creates an asynchronous iterator from it.
    /// `next()` then consumes values from this iterator until it terminates.
    /// At this point, `next()` is ready to receive the next value from the base
    /// sequence.
    @inlinable mutating func next() async rethrows -> SegmentOfResult.Element?
    typealias Element = SegmentOfResult.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncFlatMapSequence<Base, SegmentOfResult>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFlatMapSequence : @unchecked Sendable where Base : Sendable, SegmentOfResult : Sendable, Base.Element : Sendable, SegmentOfResult.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncFlatMapSequence.Iterator : @unchecked Sendable where SegmentOfResult : Sendable, Base.AsyncIterator : Sendable, Base.Element : Sendable, SegmentOfResult.AsyncIterator : Sendable, SegmentOfResult.Element : Sendable {
}

/// A type that asynchronously supplies the values of a sequence one at a
/// time.
///
/// The `AsyncIteratorProtocol` defines the type returned by the
/// `makeAsyncIterator()` method of the `AsyncSequence` protocol. In short,
/// the iterator is what produces the asynchronous sequence's values. The
/// protocol defines a single asynchronous method, `next()`, which either
/// produces the next element of the sequence, or returns `nil` to signal
/// the end of the sequence.
///
/// To implement your own `AsyncSequence`, implement a wrapped type that
/// conforms to `AsyncIteratorProtocol`. The following example shows a `Counter`
/// type that uses an inner iterator to monotonically generate `Int` values
/// until reaching a `howHigh` value. While this example isn't itself
/// asychronous, it shows the shape of a custom sequence and iterator, and how
/// to use it as if it were asynchronous:
///
///     struct Counter: AsyncSequence {
///         typealias Element = Int
///         let howHigh: Int
///
///         struct AsyncIterator: AsyncIteratorProtocol {
///             let howHigh: Int
///             var current = 1
///
///             mutating func next() async -> Int? {
///                 // A genuinely asychronous implementation uses the `Task`
///                 // API to check for cancellation here and return early.
///                 guard current <= howHigh else {
///                     return nil
///                 }
///
///                 let result = current
///                 current += 1
///                 return result
///             }
///         }
///
///         func makeAsyncIterator() -> AsyncIterator {
///             return AsyncIterator(howHigh: howHigh)
///         }
///     }
///
/// At the call site, this looks like:
///
///     for await i in Counter(howHigh: 10) {
///       print(i, terminator: " ")
///     }
///     // Prints "1 2 3 4 5 6 7 8 9 10"
///
/// ### End of Iteration
///
/// The iterator returns `nil` to indicate the end of the sequence. After
/// returning `nil` (or throwing an error) from `next()`, the iterator enters
/// a terminal state, and all future calls to `next()` must return `nil`.
///
/// ### Cancellation
///
/// Types conforming to `AsyncIteratorProtocol` should use the cancellation
/// primitives provided by Swift's `Task` API. The iterator can choose how to
/// handle and respond to cancellation, including:
///
/// - Checking the `isCancelled` value of the current `Task` inside `next()`
///   and returning `nil` to terminate the sequence.
/// - Calling `checkCancellation()` on the `Task`, which throws a
///   `CancellationError`.
/// - Implementing `next()` with a
///   `withTaskCancellationHandler(handler:operation:)` invocation to
///   immediately react to cancellation.
///
/// If the iterator needs to clean up on cancellation, it can do so after
/// checking for cancellation as described above, or in `deinit` if it's
/// a reference type.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows protocol AsyncIteratorProtocol {
  associatedtype Element
  /// Asynchronously advances to the next element and returns it, or ends the
  /// sequence if there is no next element.
  /// 
  /// - Returns: The next element, if it exists, or `nil` to signal the end of
  ///   the sequence.
  mutating func next() async throws -> Self.Element?
}

/// An asynchronous sequence that maps the given closure over the asynchronous
/// sequenceâ€™s elements.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncMapSequence<Base, Transformed> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async -> Transformed
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async -> Transformed)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The map sequence produces whatever type of element its transforming
  /// closure produces.
  typealias Element = Transformed
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncMapSequence<Base, Transformed>.Iterator
  /// The iterator that produces elements of the map sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async -> Transformed
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async -> Transformed)
    /// Produces the next element in the map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns `nil`. Otherwise, `next()` returns the result of
    /// calling the transforming closure on the received element.
    @inlinable mutating func next() async rethrows -> Transformed?
    typealias Element = Transformed
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncMapSequence<Base, Transformed>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncMapSequence : @unchecked Sendable where Base : Sendable, Transformed : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncMapSequence.Iterator : @unchecked Sendable where Transformed : Sendable, Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence, up to a specified maximum length,
/// containing the initial elements of a base asynchronous sequence.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncPrefixSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let count: Int
  @usableFromInline
  init(_ base: Base, count: Int)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The prefix sequence produces whatever type of element its base iterator
  /// produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncPrefixSequence<Base>.Iterator
  /// The iterator that produces elements of the prefix sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    var remaining: Int
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, count: Int)
    /// Produces the next element in the prefix sequence.
    ///
    /// Until reaching the number of elements to include, this iterator calls
    /// `next()` on its base iterator and passes through the result. After
    /// reaching the maximum number of elements, subsequent calls to `next()`
    /// return `nil`.
    @inlinable mutating func next() async rethrows -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncPrefixSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixSequence : Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixSequence.Iterator : Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence, containing the initial, consecutive
/// elements of the base sequence that satisfy a given predicate.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncPrefixWhileSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let predicate: (Base.Element) async -> Bool
  @usableFromInline
  init(_ base: Base, predicate: @escaping (Base.Element) async -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixWhileSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The prefix-while sequence produces whatever type of element its base
  /// iterator produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncPrefixWhileSequence<Base>.Iterator
  /// The iterator that produces elements of the prefix-while sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var predicateHasFailed: Bool
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let predicate: (Base.Element) async -> Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async -> Bool)
    /// Produces the next element in the prefix-while sequence.
    ///
    /// If the predicate hasn't yet failed, this method gets the next element
    /// from the base sequence and calls the predicate with it. If this call
    /// succeeds, this method passes along the element. Otherwise, it returns
    /// `nil`, ending the sequence.
    @inlinable mutating func next() async rethrows -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncPrefixWhileSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixWhileSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncPrefixWhileSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// A type that provides asynchronous, sequential, iterated access to its
/// elements.
///
/// An `AsyncSequence` resembles the `Sequence` type --- offering a list of
/// values you can step through one at a time --- and adds asynchronicity. An
/// `AsyncSequence` may have all, some, or none of its values available when
/// you first use it. Instead, you use `await` to receive values as they become
/// available.
///
/// As with `Sequence`, you typically iterate through an `AsyncSequence` with a
/// `for await`-`in` loop. However, because the caller must potentially wait for values,
/// you use the `await` keyword. The following example shows how to iterate
/// over `Counter`, a custom `AsyncSequence` that produces `Int` values from
/// `1` up to a `howHigh` value:
///
///     for await i in Counter(howHigh: 10) {
///         print(i, terminator: " ")
///     }
///     // Prints "1 2 3 4 5 6 7 8 9 10"
///
/// An `AsyncSequence` doesn't generate or contain the values; it just defines
/// how you access them. Along with defining the type of values as an associated
/// type called `Element`, the `AsyncSequence` defines a `makeAsyncIterator()`
/// method. This returns an instance of type `AsyncIterator`. Like the standard
/// `IteratorProtocol`, the `AsyncIteratorProtocol` defines a single `next()`
/// method to produce elements. The difference is that the `AsyncIterator`
/// defines its `next()` method as `async`, which requires a caller to wait for
/// the next value with the `await` keyword.
///
/// `AsyncSequence` also defines methods for processing the elements you
/// receive, modeled on the operations provided by the basic `Sequence` in the
/// standard library. There are two categories of methods: those that return a
/// single value, and those that return another `AsyncSequence`.
///
/// Single-value methods eliminate the need for a `for await`-`in` loop, and instead
/// let you make a single `await` call. For example, the `contains(_:)` method
/// returns a Boolean value that indicates if a given value exists in the
/// `AsyncSequence`. Given the `Counter` sequence from the previous example,
/// you can test for the existence of a sequence member with a one-line call:
///
///     let found = await Counter(howHigh: 10).contains(5) // true
///
/// Methods that return another `AsyncSequence` return a type specific to the
/// method's semantics. For example, the `.map(_:)` method returns a
/// `AsyncMapSequence` (or a `AsyncThrowingMapSequence`, if the closure you
/// provide to the `map(_:)` method can throw an error). These returned
/// sequences don't eagerly await the next member of the sequence, which allows
/// the caller to decide when to start work. Typically, you'll iterate over
/// these sequences with `for await`-`in`, like the base `AsyncSequence` you started
/// with. In the following example, the `map(_:)` method transforms each `Int`
/// received from a `Counter` sequence into a `String`:
///
///     let stream = Counter(howHigh: 10)
///         .map { $0 % 2 == 0 ? "Even" : "Odd" }
///     for await s in stream {
///         print(s, terminator: " ")
///     }
///     // Prints "Odd Even Odd Even Odd Even Odd Even Odd Even"
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@rethrows protocol AsyncSequence {
  /// The type of asynchronous iterator that produces elements of this
  /// asynchronous sequence.
  associatedtype AsyncIterator : AsyncIteratorProtocol
  /// The type of element produced by this asynchronous sequence.
  associatedtype Element where Self.Element == Self.AsyncIterator.Element
  /// Creates the asynchronous iterator that produces elements of this
  /// asynchronous sequence.
  ///
  /// - Returns: An instance of the `AsyncIterator` type used to produce
  /// elements of the asynchronous sequence.
  __consuming func makeAsyncIterator() -> Self.AsyncIterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that maps the given closure over the
  /// asynchronous sequenceâ€™s elements, omitting results that don't return a
  /// value.
  ///
  /// Use the `compactMap(_:)` method to transform every element received from
  /// a base asynchronous sequence, while also discarding any `nil` results
  /// from the closure. Typically, you use this to transform from one type of
  /// element to another.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The closure provided to the `compactMap(_:)`
  /// method takes each `Int` and looks up a corresponding `String` from a
  /// `romanNumeralDict` dictionary. Because there is no key for `4`, the closure
  /// returns `nil` in this case, which `compactMap(_:)` omits from the
  /// transformed asynchronous sequence.
  ///
  ///     let romanNumeralDict: [Int: String] =
  ///         [1: "I", 2: "II", 3: "III", 5: "V"]
  ///         
  ///     let stream = Counter(howHigh: 5)
  ///         .compactMap { romanNumeralDict[$0] }
  ///     for await numeral in stream {
  ///         print(numeral, terminator: " ")
  ///     }
  ///     // Prints "I II III V"
  ///
  /// - Parameter transform: A mapping closure. `transform` accepts an element
  ///   of this sequence as its parameter and returns a transformed value of the
  ///   same or of a different type.
  /// - Returns: An asynchronous sequence that contains, in order, the
  ///   non-`nil` elements produced by the `transform` closure.
  @preconcurrency @inlinable __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Omits a specified number of elements from the base asynchronous sequence,
  /// then passes through all remaining elements.
  ///
  /// Use `dropFirst(_:)` when you want to drop the first *n* elements from the
  /// base sequence and pass through the remaining elements.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `dropFirst(_:)` method causes the modified
  /// sequence to ignore the values `1` through `3`, and instead emit `4` through `10`:
  ///
  ///     for await number in Counter(howHigh: 10).dropFirst(3) {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "4 5 6 7 8 9 10"
  ///
  /// If the number of elements to drop exceeds the number of elements in the
  /// sequence, the result is an empty sequence.
  ///
  /// - Parameter count: The number of elements to drop from the beginning of
  ///   the sequence. `count` must be greater than or equal to zero.
  /// - Returns: An asynchronous sequence that drops the first `count`
  ///   elements from the base sequence.
  @inlinable __consuming func dropFirst(_ count: Int = 1) -> AsyncDropFirstSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Omits elements from the base asynchronous sequence until a given closure
  /// returns false, after which it passes through all remaining elements.
  ///
  /// Use `drop(while:)` to omit elements from an asynchronous sequence until
  /// the element received meets a condition you specify.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `drop(while:)` method causes the modified
  /// sequence to ignore received values until it encounters one that is
  /// divisible by `3`:
  ///
  ///     let stream = Counter(howHigh: 10)
  ///         .drop { $0 % 3 != 0 }
  ///     for await number in stream {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "3 4 5 6 7 8 9 10"
  ///
  /// After the predicate returns `false`, the sequence never executes it again,
  /// and from then on the sequence passes through elements from its underlying
  /// sequence as-is.
  ///
  /// - Parameter predicate: A closure that takes an element as a parameter and
  ///   returns a Boolean value indicating whether to drop the element from the
  ///   modified sequence.
  /// - Returns: An asynchronous sequence that skips over values from the
  ///   base sequence until the provided closure returns `false`.
  @preconcurrency @inlinable __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that contains, in order, the elements of
  /// the base sequence that satisfy the given predicate.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `filter(_:)` method returns `true` for even
  /// values and `false` for odd values, thereby filtering out the odd values:
  ///
  ///     let stream = Counter(howHigh: 10)
  ///         .filter { $0 % 2 == 0 }
  ///     for await number in stream {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "2 4 6 8 10"
  ///
  /// - Parameter isIncluded: A closure that takes an element of the
  ///   asynchronous sequence as its argument and returns a Boolean value
  ///   that indicates whether to include the element in the filtered sequence.
  /// - Returns: An asynchronous sequence that contains, in order, the elements
  ///   of the base sequence that satisfy the given predicate.
  @preconcurrency @inlinable __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async -> Bool) -> AsyncFilterSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that concatenates the results of calling
  /// the given transformation with each element of this sequence.
  ///
  /// Use this method to receive a single-level asynchronous sequence when your
  /// transformation produces an asynchronous sequence for each element.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The transforming closure takes the received `Int`
  /// and returns a new `Counter` that counts that high. For example, when the
  /// transform receives `3` from the base sequence, it creates a new `Counter`
  /// that produces the values `1`, `2`, and `3`. The `flatMap(_:)` method
  /// "flattens" the resulting sequence-of-sequences into a single
  /// `AsyncSequence`.
  ///
  ///     let stream = Counter(howHigh: 5)
  ///         .flatMap { Counter(howHigh: $0) }
  ///     for await number in stream {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "1 1 2 1 2 3 1 2 3 4 1 2 3 4 5"
  ///
  /// - Parameter transform: A mapping closure. `transform` accepts an element
  ///   of this sequence as its parameter and returns an `AsyncSequence`.
  /// - Returns: A single, flattened asynchronous sequence that contains all
  ///   elements in all the asychronous sequences produced by `transform`.
  @preconcurrency @inlinable __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : AsyncSequence
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that maps the given closure over the
  /// asynchronous sequenceâ€™s elements.
  ///
  /// Use the `map(_:)` method to transform every element received from a base
  /// asynchronous sequence. Typically, you use this to transform from one type
  /// of element to another.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The closure provided to the `map(_:)` method
  /// takes each `Int` and looks up a corresponding `String` from a
  /// `romanNumeralDict` dictionary. This means the outer `for await in` loop
  /// iterates over `String` instances instead of the underlying `Int` values
  /// that `Counter` produces:
  ///
  ///     let romanNumeralDict: [Int: String] =
  ///         [1: "I", 2: "II", 3: "III", 5: "V"]
  ///
  ///     let stream = Counter(howHigh: 5)
  ///         .map { romanNumeralDict[$0] ?? "(unknown)" }
  ///     for await numeral in stream {
  ///         print(numeral, terminator: " ")
  ///     }
  ///     // Prints "I II III (unknown) V"
  ///
  /// - Parameter transform: A mapping closure. `transform` accepts an element
  ///   of this sequence as its parameter and returns a transformed value of the
  ///   same or of a different type.
  /// - Returns: An asynchronous sequence that contains, in order, the elements
  ///   produced by the `transform` closure.
  @preconcurrency @inlinable __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns an asynchronous sequence, up to the specified maximum length,
  /// containing the initial elements of the base asynchronous sequence.
  ///
  /// Use `prefix(_:)` to reduce the number of elements produced by the
  /// asynchronous sequence.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `prefix(_:)` method causes the modified
  /// sequence to pass through the first six values, then end.
  ///
  ///     for await number in Counter(howHigh: 10).prefix(6) {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "1 2 3 4 5 6"
  ///
  /// If the count passed to `prefix(_:)` exceeds the number of elements in the
  /// base sequence, the result contains all of the elements in the sequence.
  ///
  /// - Parameter count: The maximum number of elements to return. The value of
  ///   `count` must be greater than or equal to zero.
  /// - Returns: An asynchronous sequence starting at the beginning of the
  ///   base sequence with at most `count` elements.
  @inlinable __consuming func prefix(_ count: Int) -> AsyncPrefixSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns an asynchronous sequence, containing the initial, consecutive
  /// elements of the base sequence that satisfy the given predicate.
  ///
  /// Use `prefix(while:)` to produce values while elements from the base
  /// sequence meet a condition you specify. The modified sequence ends when
  /// the predicate closure returns `false`.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `prefix(while:)` method causes the modified
  /// sequence to pass along values so long as they arenâ€™t divisible by `2` and
  /// `3`. Upon reaching `6`, the sequence ends:
  ///
  ///     let stream = Counter(howHigh: 10)
  ///         .prefix { $0 % 2 != 0 || $0 % 3 != 0 }
  ///     for try await number in stream {
  ///         print(number, terminator: " ")
  ///     }
  ///     // Prints "1 2 3 4 5"
  ///     
  /// - Parameter predicate: A closure that takes an element as a parameter and
  ///   returns a Boolean value indicating whether the element should be
  ///   included in the modified sequence.
  /// - Returns: An asynchronous sequence of the initial, consecutive
  ///   elements that satisfy `predicate`.
  @preconcurrency @inlinable __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns the result of combining the elements of the asynchronous sequence
  /// using the given closure.
  ///
  /// Use the `reduce(_:_:)` method to produce a single value from the elements of
  /// an entire sequence. For example, you can use this method on an sequence of
  /// numbers to find their sum or product.
  ///
  /// The `nextPartialResult` closure executes sequentially with an accumulating
  /// value initialized to `initialResult` and each element of the sequence.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `4`. The `reduce(_:_:)` method sums the values
  /// received from the asynchronous sequence.
  ///
  ///     let sum = await Counter(howHigh: 4)
  ///         .reduce(0) {
  ///             $0 + $1
  ///         }
  ///     print(sum)
  ///     // Prints "10"
  ///
  ///
  /// - Parameters:
  ///   - initialResult: The value to use as the initial accumulating value.
  ///     The `nextPartialResult` closure receives `initialResult` the first
  ///     time the closure runs.
  ///   - nextPartialResult: A closure that combines an accumulating value and
  ///     an element of the asynchronous sequence into a new accumulating value,
  ///     for use in the next call of the `nextPartialResult` closure or
  ///     returned to the caller.
  /// - Returns: The final accumulated value. If the sequence has no elements,
  ///   the result is `initialResult`.
  @inlinable func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) async throws -> Result) async rethrows -> Result
  /// Returns the result of combining the elements of the asynchronous sequence
  /// using the given closure, given a mutable initial value.
  ///
  /// Use the `reduce(into:_:)` method to produce a single value from the
  /// elements of an entire sequence. For example, you can use this method on a
  /// sequence of numbers to find their sum or product.
  ///
  /// The `nextPartialResult` closure executes sequentially with an accumulating
  /// value initialized to `initialResult` and each element of the sequence.
  ///
  /// Prefer this method over `reduce(_:_:)` for efficiency when the result is
  /// a copy-on-write type, for example an `Array` or `Dictionary`.
  ///
  /// - Parameters:
  ///   - initialResult: The value to use as the initial accumulating value.
  ///     The `nextPartialResult` closure receives `initialResult` the first
  ///     time the closure executes.
  ///   - nextPartialResult: A closure that combines an accumulating value and
  ///     an element of the asynchronous sequence into a new accumulating value,
  ///     for use in the next call of the `nextPartialResult` closure or
  ///     returned to the caller.
  /// - Returns: The final accumulated value. If the sequence has no elements,
  ///   the result is `initialResult`.
  @inlinable func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element) async throws -> Void) async rethrows -> Result
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns a Boolean value that indicates whether the asynchronous sequence
  /// contains an element that satisfies the given predicate.
  ///
  /// You can use the predicate to check for an element of a type that doesnâ€™t
  /// conform to the `Equatable` protocol, or to find an element that satisfies
  /// a general condition.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `contains(where:)` method checks to see
  /// whether the sequence produces a value divisible by `3`:
  ///
  ///     let containsDivisibleByThree = await Counter(howHigh: 10)
  ///         .contains { $0 % 3 == 0 }
  ///     print(containsDivisibleByThree)
  ///     // Prints "true"
  ///
  /// The predicate executes each time the asynchronous sequence produces an
  /// element, until either the predicate finds a match or the sequence ends.
  ///
  /// - Parameter predicate: A closure that takes an element of the asynchronous
  ///   sequence as its argument and returns a Boolean value that indicates
  ///   whether the passed element represents a match.
  /// - Returns: `true` if the sequence contains an element that satisfies
  ///   predicate; otherwise, `false`.
  @inlinable func contains(where predicate: (Self.Element) async throws -> Bool) async rethrows -> Bool
  /// Returns a Boolean value that indicates whether all elements produced by the
  /// asynchronous sequence satisfy the given predicate.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `allSatisfy(_:)` method checks to see whether
  /// all elements produced by the sequence are less than `10`.
  ///
  ///     let allLessThanTen = await Counter(howHigh: 10)
  ///         .allSatisfy { $0 < 10 }
  ///     print(allLessThanTen)
  ///     // Prints "false"
  ///
  /// The predicate executes each time the asynchronous sequence produces an
  /// element, until either the predicate returns `false` or the sequence ends.
  ///
  /// If the asynchronous sequence is empty, this method returns `true`.
  ///
  /// - Parameter predicate: A closure that takes an element of the asynchronous
  ///   sequence as its argument and returns a Boolean value that indicates
  ///   whether the passed element satisfies a condition.
  /// - Returns: `true` if the sequence contains only elements that satisfy
  ///   `predicate`; otherwise, `false`.
  @inlinable func allSatisfy(_ predicate: (Self.Element) async throws -> Bool) async rethrows -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence where Self.Element : Equatable {
  /// Returns a Boolean value that indicates whether the asynchronous sequence
  /// contains the given element.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `contains(_:)` method checks to see whether
  /// the sequence produces the value `5`:
  ///
  ///     let containsFive = await Counter(howHigh: 10)
  ///         .contains(5)
  ///     print(containsFive)
  ///     // Prints "true"
  ///
  /// - Parameter search: The element to find in the asynchronous sequence.
  /// - Returns: `true` if the method found the element in the asynchronous
  ///   sequence; otherwise, `false`.
  @inlinable func contains(_ search: Self.Element) async rethrows -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns the first element of the sequence that satisfies the given
  /// predicate.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `first(where:)` method returns the first
  /// member of the sequence that's evenly divisible by both `2` and `3`.
  ///
  ///     let divisibleBy2And3 = await Counter(howHigh: 10)
  ///         .first { $0 % 2 == 0 && $0 % 3 == 0 }
  ///     print(divisibleBy2And3 ?? "none")
  ///     // Prints "6"
  ///
  /// The predicate executes each time the asynchronous sequence produces an
  /// element, until either the predicate finds a match or the sequence ends.
  ///
  /// - Parameter predicate: A closure that takes an element of the asynchronous
  ///  sequence as its argument and returns a Boolean value that indicates
  ///  whether the element is a match.
  /// - Returns: The first element of the sequence that satisfies `predicate`,
  ///   or `nil` if there is no element that satisfies `predicate`.
  @inlinable func first(where predicate: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns the minimum element in the asynchronous sequence, using the given
  /// predicate as the comparison between elements.
  ///
  /// Use this method when the asynchronous sequence's values don't conform
  /// to `Comparable`, or when you want to apply a custom ordering to the
  /// sequence.
  ///
  /// The predicate must be a *strict weak ordering* over the elements. That is,
  /// for any elements `a`, `b`, and `c`, the following conditions must hold:
  ///
  /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
  /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  ///   both `true`, then `areInIncreasingOrder(a, c)` is also
  ///   `true`. (Transitive comparability)
  /// - Two elements are *incomparable* if neither is ordered before the other
  ///   according to the predicate. If `a` and `b` are incomparable, and `b`
  ///   and `c` are incomparable, then `a` and `c` are also incomparable.
  ///   (Transitive incomparability)
  ///
  /// The following example uses an enumeration of playing cards ranks, `Rank`,
  /// which ranges from `ace` (low) to `king` (high). An asynchronous sequence
  /// called `RankCounter` produces all elements of the array. The predicate
  /// provided to the `min(by:)` method sorts ranks based on their `rawValue`:
  ///
  ///     enum Rank: Int {
  ///         case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
  ///     }
  ///
  ///     let min = await RankCounter()
  ///         .min { $0.rawValue < $1.rawValue }
  ///     print(min ?? "none")
  ///     // Prints "ace"
  ///
  /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
  ///   first argument should be ordered before its second argument; otherwise,
  ///   `false`.
  /// - Returns: The sequenceâ€™s minimum element, according to
  ///   `areInIncreasingOrder`. If the sequence has no elements, returns `nil`.
  @warn_unqualified_access
  @inlinable func min(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?
  /// Returns the maximum element in the asynchronous sequence, using the given
  /// predicate as the comparison between elements.
  ///
  /// Use this method when the asynchronous sequence's values don't conform
  /// to `Comparable`, or when you want to apply a custom ordering to the
  /// sequence.
  ///
  /// The predicate must be a *strict weak ordering* over the elements. That is,
  /// for any elements `a`, `b`, and `c`, the following conditions must hold:
  ///
  /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
  /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
  ///   both `true`, then `areInIncreasingOrder(a, c)` is also
  ///   `true`. (Transitive comparability)
  /// - Two elements are *incomparable* if neither is ordered before the other
  ///   according to the predicate. If `a` and `b` are incomparable, and `b`
  ///   and `c` are incomparable, then `a` and `c` are also incomparable.
  ///   (Transitive incomparability)
  ///
  /// The following example uses an enumeration of playing cards ranks, `Rank`,
  /// which ranges from `ace` (low) to `king` (high). An asynchronous sequence
  /// called `RankCounter` produces all elements of the array. The predicate
  /// provided to the `max(by:)` method sorts ranks based on their `rawValue`:
  ///
  ///     enum Rank: Int {
  ///         case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
  ///     }
  ///
  ///     let max = await RankCounter()
  ///         .max { $0.rawValue < $1.rawValue }
  ///     print(max ?? "none")
  ///     // Prints "king"
  ///
  /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
  ///   first argument should be ordered before its second argument; otherwise,
  ///   `false`.
  /// - Returns: The sequenceâ€™s minimum element, according to
  ///   `areInIncreasingOrder`. If the sequence has no elements, returns `nil`.
  @warn_unqualified_access
  @inlinable func max(by areInIncreasingOrder: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence where Self.Element : Comparable {
  /// Returns the minimum element in an asynchronous sequence of comparable
  /// elements.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `min()` method returns the minimum value
  /// of the sequence.
  ///
  ///     let min = await Counter(howHigh: 10)
  ///         .min()
  ///     print(min ?? "none")
  ///     // Prints "1"
  ///
  /// - Returns: The sequenceâ€™s minimum element. If the sequence has no
  ///   elements, returns `nil`.
  @warn_unqualified_access
  @inlinable func min() async rethrows -> Self.Element?
  /// Returns the maximum element in an asynchronous sequence of comparable
  /// elements.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `max()` method returns the max value
  /// of the sequence.
  ///
  ///     let max = await Counter(howHigh: 10)
  ///         .max()
  ///     print(max ?? "none")
  ///     // Prints "10"
  ///
  /// - Returns: The sequenceâ€™s maximum element. If the sequence has no
  ///   elements, returns `nil`.
  @warn_unqualified_access
  @inlinable func max() async rethrows -> Self.Element?
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that maps an error-throwing closure over
  /// the base sequenceâ€™s elements, omitting results that don't return a value.
  ///
  /// Use the `compactMap(_:)` method to transform every element received from
  /// a base asynchronous sequence, while also discarding any `nil` results
  /// from the closure. Typically, you use this to transform from one type of
  /// element to another.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The closure provided to the `compactMap(_:)`
  /// method takes each `Int` and looks up a corresponding `String` from a
  /// `romanNumeralDict` dictionary. Since there is no key for `4`, the closure
  /// returns `nil` in this case, which `compactMap(_:)` omits from the
  /// transformed asynchronous sequence. When the value is `5`, the closure
  /// throws `MyError`, terminating the sequence.
  ///
  ///     let romanNumeralDict: [Int: String] =
  ///         [1: "I", 2: "II", 3: "III", 5: "V"]
  ///
  ///     do {
  ///         let stream = Counter(howHigh: 5)
  ///             .compactMap { (value) throws -> String? in
  ///                 if value == 5 {
  ///                     throw MyError()
  ///                 }
  ///                 return romanNumeralDict[value]
  ///             }
  ///         for try await numeral in stream {
  ///             print(numeral, terminator: " ")
  ///         }
  ///     } catch {
  ///         print("Error: \(error)")
  ///     }
  ///     // Prints "I II III Error: MyError()"
  ///
  /// - Parameter transform: An error-throwing mapping closure. `transform`
  ///   accepts an element of this sequence as its parameter and returns a
  ///   transformed value of the same or of a different type. If `transform`
  ///   throws an error, the sequence ends.
  /// - Returns: An asynchronous sequence that contains, in order, the
  ///   non-`nil` elements produced by the `transform` closure. The sequence
  ///   ends either when the base sequence ends or when `transform` throws an
  ///   error.
  @preconcurrency @inlinable __consuming func compactMap<ElementOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Omits elements from the base sequence until a given error-throwing closure
  /// returns false, after which it passes through all remaining elements.
  ///
  /// Use `drop(while:)` to omit elements from an asynchronous sequence until
  /// the element received meets a condition you specify. If the closure you
  /// provide throws an error, the sequence produces no elements and throws
  /// the error instead.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The predicate passed to the `drop(while:)`
  /// method throws an error if it encounters an even number, and otherwise
  /// returns `true` while it receives elements less than `5`. Because the
  /// predicate throws when it receives `2` from the base sequence, this example
  /// throws without ever printing anything.
  ///
  ///     do {
  ///         let stream = Counter(howHigh: 10)
  ///             .drop {
  ///                 if $0 % 2 == 0 {
  ///                     throw EvenError()
  ///                 }
  ///                 return $0 < 5
  ///             }
  ///         for try await number in stream {
  ///             print(number)
  ///         }
  ///     } catch {
  ///         print(error)
  ///     }
  ///     // Prints "EvenError()"
  ///
  /// After the predicate returns `false`, the sequence never executes it again,
  /// and from then on the sequence passes through elements from its underlying
  /// sequence. A predicate that throws an error also never executes again.
  ///
  /// - Parameter predicate: An error-throwing closure that takes an element as
  ///   a parameter and returns a Boolean value indicating whether to drop the
  ///   element from the modified sequence.
  /// - Returns: An asynchronous sequence that skips over values until the
  ///   provided closure returns `false` or throws an error.
  @preconcurrency @inlinable __consuming func drop(while predicate: @escaping @Sendable (Self.Element) async throws -> Bool) -> AsyncThrowingDropWhileSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that contains, in order, the elements of
  /// the base sequence that satisfy the given error-throwing predicate.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `filter(_:)` method returns `true` for even
  /// values and `false` for odd values, thereby filtering out the odd values,
  /// but also throws an error for values divisible by 5:
  ///
  ///     do {
  ///         let stream = Counter(howHigh: 10)
  ///             .filter {
  ///                 if $0 % 5 == 0 {
  ///                     throw MyError()
  ///                 }
  ///                 return $0 % 2 == 0
  ///             }
  ///         for try await number in stream {
  ///             print(number, terminator: " ")
  ///         }
  ///     } catch {
  ///         print("Error: \(error)")
  ///     }
  ///     // Prints "2 4 Error: MyError()"
  ///
  /// - Parameter isIncluded: An error-throwing closure that takes an element
  ///   of the asynchronous sequence as its argument and returns a Boolean value
  ///   that indicates whether to include the element in the filtered sequence.
  /// - Returns: An asynchronous sequence that contains, in order, the elements
  ///   of the base sequence that satisfy the given predicate. If the predicate
  ///   throws an error, the sequence contains only values produced prior to
  ///   the error.
  @preconcurrency @inlinable __consuming func filter(_ isIncluded: @escaping @Sendable (Self.Element) async throws -> Bool) -> AsyncThrowingFilterSequence<Self>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that concatenates the results of calling
  /// the given error-throwing transformation with each element of this
  /// sequence.
  ///
  /// Use this method to receive a single-level asynchronous sequence when your
  /// transformation produces an asynchronous sequence for each element.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The transforming closure takes the received `Int`
  /// and returns a new `Counter` that counts that high. For example, when the
  /// transform receives `3` from the base sequence, it creates a new `Counter`
  /// that produces the values `1`, `2`, and `3`. The `flatMap(_:)` method
  /// "flattens" the resulting sequence-of-sequences into a single
  /// `AsyncSequence`. However, when the closure receives `4`, it throws an
  /// error, terminating the sequence.
  ///
  ///     do {
  ///         let stream = Counter(howHigh: 5)
  ///             .flatMap { (value) -> Counter in
  ///                 if value == 4 {
  ///                     throw MyError()
  ///                 }
  ///                 return Counter(howHigh: value)
  ///             }
  ///         for try await number in stream {
  ///             print(number, terminator: " ")
  ///         }
  ///     } catch {
  ///         print(error)
  ///     }
  ///     // Prints "1 1 2 1 2 3 MyError()"
  ///
  /// - Parameter transform: An error-throwing mapping closure. `transform`
  ///   accepts an element of this sequence as its parameter and returns an
  ///   `AsyncSequence`. If `transform` throws an error, the sequence ends.
  /// - Returns: A single, flattened asynchronous sequence that contains all
  ///   elements in all the asychronous sequences produced by `transform`. The
  ///   sequence ends either when the the last sequence created from the last
  ///   element from base sequence ends, or when `transform` throws an error.
  @preconcurrency @inlinable __consuming func flatMap<SegmentOfResult>(_ transform: @escaping @Sendable (Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult> where SegmentOfResult : AsyncSequence
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Creates an asynchronous sequence that maps the given error-throwing
  /// closure over the asynchronous sequenceâ€™s elements.
  ///
  /// Use the `map(_:)` method to transform every element received from a base
  /// asynchronous sequence. Typically, you use this to transform from one type
  /// of element to another.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `5`. The closure provided to the `map(_:)` method
  /// takes each `Int` and looks up a corresponding `String` from a
  /// `romanNumeralDict` dictionary. This means the outer `for await in` loop
  /// iterates over `String` instances instead of the underlying `Int` values
  /// that `Counter` produces. Also, the dictionary doesn't provide a key for
  /// `4`, and the closure throws an error for any key it can't look up, so
  /// receiving this value from `Counter` ends the modified sequence with an
  /// error.
  ///
  ///     let romanNumeralDict: [Int: String] =
  ///         [1: "I", 2: "II", 3: "III", 5: "V"]
  ///
  ///     do {
  ///         let stream = Counter(howHigh: 5)
  ///             .map { (value) throws -> String in
  ///                 guard let roman = romanNumeralDict[value] else {
  ///                     throw MyError()
  ///                 }
  ///                 return roman
  ///             }
  ///         for try await numeral in stream {
  ///             print(numeral, terminator: " ")
  ///         }
  ///     } catch {
  ///         print("Error: \(error)")
  ///     }
  ///     // Prints "I II III Error: MyError()"
  ///
  /// - Parameter transform: A mapping closure. `transform` accepts an element
  ///   of this sequence as its parameter and returns a transformed value of the
  ///   same or of a different type. `transform` can also throw an error, which
  ///   ends the transformed sequence.
  /// - Returns: An asynchronous sequence that contains, in order, the elements
  ///   produced by the `transform` closure.
  @preconcurrency @inlinable __consuming func map<Transformed>(_ transform: @escaping @Sendable (Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncSequence {
  /// Returns an asynchronous sequence, containing the initial, consecutive
  /// elements of the base sequence that satisfy the given error-throwing
  /// predicate.
  ///
  /// Use `prefix(while:)` to produce values while elements from the base
  /// sequence meet a condition you specify. The modified sequence ends when
  /// the predicate closure returns `false` or throws an error.
  ///
  /// In this example, an asynchronous sequence called `Counter` produces `Int`
  /// values from `1` to `10`. The `prefix(_:)` method causes the modified
  /// sequence to pass through values less than `8`, but throws an
  /// error when it receives a value that's divisible by `5`:
  ///
  ///     do {
  ///         let stream = try Counter(howHigh: 10)
  ///             .prefix {
  ///                 if $0 % 5 == 0 {
  ///                     throw MyError()
  ///                 }
  ///                 return $0 < 8
  ///             }
  ///         for try await number in stream {
  ///             print(number, terminator: " ")
  ///         }
  ///     } catch {
  ///         print("Error: \(error)")
  ///     }
  ///     // Prints "1 2 3 4 Error: MyError()"
  ///
  /// - Parameter predicate: A error-throwing closure that takes an element of
  ///   the asynchronous sequence as its argument and returns a Boolean value
  ///   that indicates whether to include the element in the modified sequence.
  /// - Returns: An asynchronous sequence that contains, in order, the elements
  ///   of the base sequence that satisfy the given predicate. If the predicate
  ///   throws an error, the sequence contains only values produced prior to
  ///   the error.
  @preconcurrency @inlinable __consuming func prefix(while predicate: @escaping @Sendable (Self.Element) async throws -> Bool) rethrows -> AsyncThrowingPrefixWhileSequence<Self>
}

/// An asynchronous sequence generated from a closure that calls a continuation
/// to produce new elements.
///
/// `AsyncStream` conforms to `AsyncSequence`, providing a convenient way to
/// create an asynchronous sequence without manually implementing an
/// asynchronous iterator. In particular, an asynchronous stream is well-suited
/// to adapt callback- or delegation-based APIs to participate with
/// `async`-`await`.
///
/// You initialize an `AsyncStream` with a closure that receives an
/// `AsyncStream.Continuation`. Produce elements in this closure, then provide
/// them to the stream by calling the continuation's `yield(_:)` method. When
/// there are no further elements to produce, call the continuation's
/// `finish()` method. This causes the sequence iterator to produce a `nil`,
/// which terminates the sequence. The continuation conforms to `Sendable`, which permits
/// calling it from concurrent contexts external to the iteration of the
/// `AsyncStream`.
///
/// An arbitrary source of elements can produce elements faster than they are
/// consumed by a caller iterating over them. Because of this, `AsyncStream`
/// defines a buffering behavior, allowing the stream to buffer a specific
/// number of oldest or newest elements. By default, the buffer limit is
/// `Int.max`, which means the value is unbounded.
///
/// ### Adapting Existing Code to Use Streams
///
/// To adapt existing callback code to use `async`-`await`, use the callbacks
/// to provide values to the stream, by using the continuation's `yield(_:)`
/// method.
///
/// Consider a hypothetical `QuakeMonitor` type that provides callers with
/// `Quake` instances every time it detects an earthquake. To receive callbacks,
/// callers set a custom closure as the value of the monitor's
/// `quakeHandler` property, which the monitor calls back as necessary.
///
///     class QuakeMonitor {
///         var quakeHandler: ((Quake) -> Void)?
///
///         func startMonitoring() {â€¦}
///         func stopMonitoring() {â€¦}
///     }
///
/// To adapt this to use `async`-`await`, extend the `QuakeMonitor` to add a
/// `quakes` property, of type `AsyncStream<Quake>`. In the getter for this
/// property, return an `AsyncStream`, whose `build` closure -- called at
/// runtime to create the stream -- uses the continuation to perform the
/// following steps:
///
/// 1. Creates a `QuakeMonitor` instance.
/// 2. Sets the monitor's `quakeHandler` property to a closure that receives
/// each `Quake` instance and forwards it to the stream by calling the
/// continuation's `yield(_:)` method.
/// 3. Sets the continuation's `onTermination` property to a closure that
/// calls `stopMonitoring()` on the monitor.
/// 4. Calls `startMonitoring` on the `QuakeMonitor`.
///
/// ```
/// extension QuakeMonitor {
///
///     static var quakes: AsyncStream<Quake> {
///         AsyncStream { continuation in
///             let monitor = QuakeMonitor()
///             monitor.quakeHandler = { quake in
///                 continuation.yield(quake)
///             }
///             continuation.onTermination = { @Sendable _ in
///                  monitor.stopMonitoring()
///             }
///             monitor.startMonitoring()
///         }
///     }
/// }
/// ```
///
/// Because the stream is an `AsyncSequence`, the call point can use the
/// `for`-`await`-`in` syntax to process each `Quake` instance as the stream
/// produces it:
///
///     for await quake in QuakeMonitor.quakes {
///         print("Quake: \(quake.date)")
///     }
///     print("Stream finished.")
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncStream<Element> {
  /// A mechanism to interface between synchronous code and an asynchronous
  /// stream.
  ///
  /// The closure you provide to the `AsyncStream` in
  /// `init(_:bufferingPolicy:_:)` receives an instance of this type when
  /// invoked. Use this continuation to provide elements to the stream by
  /// calling one of the `yield` methods, then terminate the stream normally by
  /// calling the `finish()` method.
  ///
  /// - Note: Unlike other continuations in Swift, `AsyncStream.Continuation`
  /// supports escaping.
  struct Continuation : Sendable {
    /// A type that indicates how the stream terminated.
    ///
    /// The `onTermination` closure receives an instance of this type.
    enum Termination {
      /// The stream finished as a result of calling the continuation's
      ///  `finish` method.
      case finished
      /// The stream finished as a result of cancellation.
      case cancelled
      static func == (a: AsyncStream<Element>.Continuation.Termination, b: AsyncStream<Element>.Continuation.Termination) -> Bool
      func hash(into hasher: inout Hasher)
      var hashValue: Int { get }
    }
    /// A type that indicates the result of yielding a value to a client, by
    /// way of the continuation.
    ///
    /// The various `yield` methods of `AsyncStream.Continuation` return this
    /// type to indicate the success or failure of yielding an element to the
    /// continuation.
    enum YieldResult {
      /// The stream successfully enqueued the element.
      ///
      /// This value represents the successful enqueueing of an element, whether
      /// the stream buffers the element or delivers it immediately to a pending
      /// call to `next()`. The associated value `remaining` is a hint that
      /// indicates the number of remaining slots in the buffer at the time of
      /// the `yield` call.
      ///
      /// - Note: From a thread safety point of view, `remaining` is a lower bound
      /// on the number of remaining slots. This is because a subsequent call
      /// that uses the `remaining` value could race on the consumption of
      /// values from the stream.
      case enqueued(remaining: Int)
      /// The stream didn't enqueue the element because the buffer was full.
      ///
      /// The associated element for this case is the element dropped by the stream.
      case dropped(Element)
      /// The stream didn't enqueue the element because the stream was in a
      /// terminal state.
      ///
      /// This indicates the stream terminated prior to calling `yield`, either
      /// because the stream finished normally or through cancellation.
      case terminated
    }
    /// A strategy that handles exhaustion of a bufferâ€™s capacity.
    enum BufferingPolicy {
      /// Continue to add to the buffer, without imposing a limit on the number
      /// of buffered elements.
      case unbounded
      /// When the buffer is full, discard the newly received element.
      ///
      /// This strategy enforces keeping at most the specified number of oldest
      /// values.
      case bufferingOldest(Int)
      /// When the buffer is full, discard the oldest element in the buffer.
      ///
      /// This strategy enforces keeping at most the specified number of newest
      /// values.
      case bufferingNewest(Int)
    }
    /// Resume the task awaiting the next iteration point by having it return
    /// nomally from its suspension point with a given element.
    ///
    /// - Parameter value: The value to yield from the continuation.
    /// - Returns: A `YieldResult` that indicates the success or failure of the
    ///   yield operation.
    ///
    /// If nothing is awaiting the next value, this method attempts to buffer the
    /// result's element.
    ///
    /// This can be called more than once and returns to the caller immediately
    /// without blocking for any awaiting consumption from the iteration.
    @discardableResult
    func yield(_ value: __owned Element) -> AsyncStream<Element>.Continuation.YieldResult
    /// Resume the task awaiting the next iteration point by having it return
    /// nil, which signifies the end of the iteration.
    ///
    /// Calling this function more than once has no effect. After calling
    /// finish, the stream enters a terminal state and doesn't produces any additional
    /// elements.
    func finish()
    /// A callback to invoke when canceling iteration of an asynchronous
    /// stream.
    ///
    /// If an `onTermination` callback is set, using task cancellation to
    /// terminate iteration of an `AsyncStream` results in a call to this
    /// callback.
    ///
    /// Canceling an active iteration invokes the `onTermination` callback
    /// first, then resumes by yielding `nil`. This means that you can perform
    /// needed cleanup in the cancellation handler. After reaching a terminal
    /// state as a result of cancellation, the `AsyncStream` sets the callback
    /// to `nil`.
    var onTermination: (@Sendable (AsyncStream<Element>.Continuation.Termination) -> Void)? { get nonmutating set }
  }
  /// Constructs an asynchronous stream for an element type, using the
  /// specified buffering policy and element-producing closure.
  ///
  /// - Parameters:
  ///    - elementType: The type of element the `AsyncStream` produces.
  ///    - bufferingPolicy: A `Continuation.BufferingPolicy` value to
  ///       set the stream's buffering behavior. By default, the stream buffers an
  ///       unlimited number of elements. You can also set the policy to buffer a
  ///       specified number of oldest or newest elements.
  ///    - build: A custom closure that yields values to the
  ///       `AsyncStream`. This closure receives an `AsyncStream.Continuation`
  ///       instance that it uses to provide elements to the stream and terminate the
  ///       stream when finished.
  ///
  /// The `AsyncStream.Continuation` received by the `build` closure is
  /// appropriate for use in concurrent contexts. It is thread safe to send and
  /// finish; all calls to the continuation are serialized. However, calling
  /// this from multiple concurrent contexts could result in out-of-order
  /// delivery.
  ///
  /// The following example shows an `AsyncStream` created with this
  /// initializer that produces 100 random numbers on a one-second interval,
  /// calling `yield(_:)` to deliver each element to the awaiting call point.
  /// When the `for` loop exits, the stream finishes by calling the
  /// continuation's `finish()` method.
  ///
  ///     let stream = AsyncStream<Int>(Int.self,
  ///                                   bufferingPolicy: .bufferingNewest(5)) { continuation in
  ///         Task.detached {
  ///             for _ in 0..<100 {
  ///                 await Task.sleep(1 * 1_000_000_000)
  ///                 continuation.yield(Int.random(in: 1...10))
  ///             }
  ///             continuation.finish()
  ///         }
  ///     }
  ///
  ///     // Call point:
  ///     for await random in stream {
  ///         print(random)
  ///     }
  ///
  init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncStream<Element>.Continuation) -> Void)
  /// Constructs an asynchronous stream from a given element-producing
  /// closure, with an optional closure to handle cancellation.
  ///
  /// - Parameters:
  ///   - produce: A closure that asynchronously produces elements for the
  ///     stream.
  ///   - onCancel: A closure to execute when canceling the stream's task.
  ///
  /// Use this convenience initializer when you have an asychronous function
  /// that can produce elements for the stream, and don't want to invoke
  /// a continuation manually. This initializer "unfolds" your closure into
  /// an asynchronous stream. The created stream handles conformance
  /// to the `AsyncSequence` protocol automatically, including termination
  /// (either by cancellation or by returning `nil` from the closure to finish
  /// iteration).
  ///
  /// The following example shows an `AsyncStream` created with this
  /// initializer that produces random numbers on a one-second interval. This
  /// example uses the Swift multiple trailing closure syntax, which omits
  /// the `unfolding` parameter label.
  ///
  ///     let stream = AsyncStream<Int> {
  ///         await Task.sleep(1 * 1_000_000_000)
  ///         return Int.random(in: 1...10)
  ///     } onCancel: { @Sendable () in print("Canceled.") }
  ///
  ///     // Call point:
  ///     for await random in stream {
  ///         print(random)
  ///     }
  ///
  ///
  init(unfolding produce: @escaping () async -> Element?, onCancel: (@Sendable () -> Void)? = nil)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncStream : AsyncSequence {
  /// The asynchronous iterator for iterating an asynchronous stream.
  ///
  /// This type doesn't conform to `Sendable`. Don't use it from multiple
  /// concurrent contexts. It is a programmer error to invoke `next()` from a
  /// concurrent context that contends with another such call, which
  /// results in a call to `fatalError()`.
  struct Iterator : AsyncIteratorProtocol {
    /// The next value from the asynchronous stream.
    ///
    /// When `next()` returns `nil`, this signifies the end of the
    /// `AsyncStream`.
    ///
    /// It is a programmer error to invoke `next()` from a
    /// concurrent context that contends with another such call, which
    /// results in a call to `fatalError()`.
    ///
    /// If you cancel the task this iterator is running in while `next()` is
    /// awaiting a value, the `AsyncStream` terminates. In this case, `next()`
    /// might return `nil` immediately, or return `nil` on subsequent calls.
    mutating func next() async -> Element?
    typealias Element = Element
  }
  /// Creates the asynchronous iterator that produces elements of this
  /// asynchronous sequence.
  func makeAsyncIterator() -> AsyncStream<Element>.Iterator
  typealias AsyncIterator = AsyncStream<Element>.Iterator
  typealias Element = Element
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncStream : @unchecked Sendable where Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncStream.Continuation {
  /// Resume the task awaiting the next iteration point by having it return
  /// normally from its suspension point with a given result's success value.
  ///
  /// - Parameter result: A result to yield from the continuation.
  /// - Returns: A `YieldResult` that indicates the success or failure of the
  ///   yield operation.
  ///
  /// If nothing is awaiting the next value, the method attempts to buffer the
  /// result's element.
  ///
  /// If you call this method repeatedly, each call returns immediately, without
  /// blocking for any awaiting consumption from the iteration.
  @discardableResult
  func yield(with result: Result<Element, Never>) -> AsyncStream<Element>.Continuation.YieldResult
  /// Resume the task awaiting the next iteration point by having it return
  /// normally from its suspension point.
  ///
  /// - Returns: A `YieldResult` that indicates the success or failure of the
  ///   yield operation.
  ///
  /// Use this method with `AsyncStream` instances whose `Element` type is
  /// `Void`. In this case, the `yield()` call unblocks the awaiting
  /// iteration; there is no value to return.
  ///
  /// If you call this method repeatedly, each call returns immediately, without
  /// blocking for any awaiting consumption from the iteration.
  @discardableResult
  func yield() -> AsyncStream<Element>.Continuation.YieldResult where Element == ()
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncStream.Continuation.Termination : Equatable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncStream.Continuation.Termination : Hashable {
}

/// An asynchronous sequence that maps an error-throwing closure over the base
/// sequenceâ€™s elements, omitting results that don't return a value.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingCompactMapSequence<Base, ElementOfResult> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async throws -> ElementOfResult?
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingCompactMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The compact map sequence produces whatever type of element its
  /// transforming closure produces.
  typealias Element = ElementOfResult
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator
  /// The iterator that produces elements of the compact map sequence.
  struct Iterator : AsyncIteratorProtocol {
    typealias Element = ElementOfResult
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async throws -> ElementOfResult?
    @usableFromInline
    var finished: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> ElementOfResult?)
    /// Produces the next element in the compact map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns `nil`. Otherwise, `next()` calls the
    /// transforming closure on the received element, returning it if the
    /// transform returns a non-`nil` value. If the transform returns `nil`,
    /// this method continues to wait for further elements until it gets one
    /// that transforms to a non-`nil` value. If calling the closure throws an
    /// error, the sequence ends and `next()` rethrows the error.
    @inlinable mutating func next() async throws -> ElementOfResult?
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingCompactMapSequence<Base, ElementOfResult>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingCompactMapSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingCompactMapSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence which omits elements from the base sequence until a
/// given error-throwing closure returns false, after which it passes through
/// all remaining elements.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingDropWhileSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let predicate: (Base.Element) async throws -> Bool
  @usableFromInline
  init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingDropWhileSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The drop-while sequence produces whatever type of element its base
  /// sequence produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingDropWhileSequence<Base>.Iterator
  /// The iterator that produces elements of the drop-while sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let predicate: (Base.Element) async throws -> Bool
    @usableFromInline
    var finished: Bool
    @usableFromInline
    var doneDropping: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Bool)
    /// Produces the next element in the drop-while sequence.
    ///
    /// This iterator calls `next()` on its base iterator and evaluates the
    /// result with the `predicate` closure. As long as the predicate returns
    /// `true`, this method returns `nil`. After the predicate returns `false`,
    /// for a value received from the base iterator, this method returns that
    /// value. After that, the iterator returns values received from its
    /// base iterator as-is, and never executes the predicate closure again.
    /// If calling the closure throws an error, the sequence ends and `next()`
    /// rethrows the error.
    @inlinable mutating func next() async throws -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingDropWhileSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingDropWhileSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingDropWhileSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence that contains, in order, the elements of
/// the base sequence that satisfy the given error-throwing predicate.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingFilterSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let isIncluded: (AsyncThrowingFilterSequence<Base>.Element) async throws -> Bool
  @usableFromInline
  init(_ base: Base, isIncluded: @escaping (Base.Element) async throws -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFilterSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The filter sequence produces whatever type of element its base
  /// sequence produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingFilterSequence<Base>.Iterator
  /// The iterator that produces elements of the filter sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let isIncluded: (Base.Element) async throws -> Bool
    @usableFromInline
    var finished: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, isIncluded: @escaping (Base.Element) async throws -> Bool)
    /// Produces the next element in the filter sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns nil. Otherwise, `next()` evaluates the
    /// result with the `predicate` closure. If the closure returns `true`,
    /// `next()` returns the received element; otherwise it awaits the next
    /// element from the base iterator. If calling the closure throws an error,
    /// the sequence ends and `next()` rethrows the error.
    @inlinable mutating func next() async throws -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingFilterSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFilterSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFilterSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence that concatenates the results of calling a given
/// error-throwing transformation with each element of this sequence.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingFlatMapSequence<Base, SegmentOfResult> where Base : AsyncSequence, SegmentOfResult : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async throws -> SegmentOfResult
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFlatMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The flat map sequence produces the type of element in the asynchronous
  /// sequence produced by the `transform` closure.
  typealias Element = SegmentOfResult.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator
  /// The iterator that produces elements of the flat map sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async throws -> SegmentOfResult
    @usableFromInline
    var currentIterator: SegmentOfResult.AsyncIterator?
    @usableFromInline
    var finished: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> SegmentOfResult)
    /// Produces the next element in the flat map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns `nil`. Otherwise, `next()` calls the
    /// transforming closure on the received element, takes the resulting
    /// asynchronous sequence, and creates an asynchronous iterator from it.
    /// `next()` then consumes values from this iterator until it terminates.
    /// At this point, `next()` is ready to receive the next value from the base
    /// sequence. If `transform` throws an error, the sequence terminates.
    @inlinable mutating func next() async throws -> SegmentOfResult.Element?
    typealias Element = SegmentOfResult.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingFlatMapSequence<Base, SegmentOfResult>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFlatMapSequence : @unchecked Sendable where Base : Sendable, SegmentOfResult : Sendable, Base.Element : Sendable, SegmentOfResult.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingFlatMapSequence.Iterator : @unchecked Sendable where SegmentOfResult : Sendable, Base.AsyncIterator : Sendable, Base.Element : Sendable, SegmentOfResult.AsyncIterator : Sendable, SegmentOfResult.Element : Sendable {
}

/// An asynchronous sequence that maps the given error-throwing closure over the
/// asynchronous sequenceâ€™s elements.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingMapSequence<Base, Transformed> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let transform: (Base.Element) async throws -> Transformed
  @usableFromInline
  init(_ base: Base, transform: @escaping (Base.Element) async throws -> Transformed)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingMapSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The map sequence produces whatever type of element its the transforming
  /// closure produces.
  typealias Element = Transformed
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingMapSequence<Base, Transformed>.Iterator
  /// The iterator that produces elements of the map sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let transform: (Base.Element) async throws -> Transformed
    @usableFromInline
    var finished: Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, transform: @escaping (Base.Element) async throws -> Transformed)
    /// Produces the next element in the map sequence.
    ///
    /// This iterator calls `next()` on its base iterator; if this call returns
    /// `nil`, `next()` returns nil. Otherwise, `next()` returns the result of
    /// calling the transforming closure on the received element. If calling
    /// the closure throws an error, the sequence ends and `next()` rethrows
    /// the error.
    @inlinable mutating func next() async throws -> Transformed?
    typealias Element = Transformed
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingMapSequence<Base, Transformed>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingMapSequence : @unchecked Sendable where Base : Sendable, Transformed : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingMapSequence.Iterator : @unchecked Sendable where Transformed : Sendable, Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence, containing the initial, consecutive
/// elements of the base sequence that satisfy the given error-throwing
/// predicate.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingPrefixWhileSequence<Base> where Base : AsyncSequence {
  @usableFromInline
  let base: Base
  @usableFromInline
  let predicate: (Base.Element) async throws -> Bool
  @usableFromInline
  init(_ base: Base, predicate: @escaping (Base.Element) async throws -> Bool)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingPrefixWhileSequence : AsyncSequence {
  /// The type of element produced by this asynchronous sequence.
  ///
  /// The prefix-while sequence produces whatever type of element its base
  /// iterator produces.
  typealias Element = Base.Element
  /// The type of iterator that produces elements of the sequence.
  typealias AsyncIterator = AsyncThrowingPrefixWhileSequence<Base>.Iterator
  /// The iterator that produces elements of the prefix-while sequence.
  struct Iterator : AsyncIteratorProtocol {
    @usableFromInline
    var predicateHasFailed: Bool
    @usableFromInline
    var baseIterator: Base.AsyncIterator
    @usableFromInline
    let predicate: (Base.Element) async throws -> Bool
    @usableFromInline
    init(_ baseIterator: Base.AsyncIterator, predicate: @escaping (Base.Element) async throws -> Bool)
    /// Produces the next element in the prefix-while sequence.
    ///
    /// If the predicate hasn't failed yet, this method gets the next element
    /// from the base sequence and calls the predicate with it. If this call
    /// succeeds, this method passes along the element. Otherwise, it returns
    /// `nil`, ending the sequence. If calling the predicate closure throws an
    /// error, the sequence ends and `next()` rethrows the error.
    @inlinable mutating func next() async throws -> Base.Element?
    typealias Element = Base.Element
  }
  @inlinable __consuming func makeAsyncIterator() -> AsyncThrowingPrefixWhileSequence<Base>.Iterator
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingPrefixWhileSequence : @unchecked Sendable where Base : Sendable, Base.Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingPrefixWhileSequence.Iterator : @unchecked Sendable where Base.AsyncIterator : Sendable, Base.Element : Sendable {
}

/// An asynchronous sequence generated from an error-throwing closure that
/// calls a continuation to produce new elements.
///
/// `AsyncThrowingStream` conforms to `AsyncSequence`, providing a convenient
/// way to create an asynchronous sequence without manually implementing an
/// asynchronous iterator. In particular, an asynchronous stream is well-suited
/// to adapt callback- or delegation-based APIs to participate with
/// `async`-`await`.
///
/// In contrast to `AsyncStream`, this type can throw an error from the awaited
/// `next()`, which terminates the stream with the thrown error.
///
/// You initialize an `AsyncThrowingStream` with a closure that receives an
/// `AsyncThrowingStream.Continuation`. Produce elements in this closure, then
/// provide them to the stream by calling the continuation's `yield(_:)` method.
/// When there are no further elements to produce, call the continuation's
/// `finish()` method. This causes the sequence iterator to produce a `nil`,
/// which terminates the sequence. If an error occurs, call the continuation's
/// `finish(throwing:)` method, which causes the iterator's `next()` method to
/// throw the error to the awaiting call point. The continuation is `Sendable`,
/// which permits calling it from concurrent contexts external to the iteration
/// of the `AsyncThrowingStream`.
///
/// An arbitrary source of elements can produce elements faster than they are
/// consumed by a caller iterating over them. Because of this, `AsyncThrowingStream`
/// defines a buffering behavior, allowing the stream to buffer a specific
/// number of oldest or newest elements. By default, the buffer limit is
/// `Int.max`, which means it's unbounded.
///
/// ### Adapting Existing Code to Use Streams
///
/// To adapt existing callback code to use `async`-`await`, use the callbacks
/// to provide values to the stream, by using the continuation's `yield(_:)`
/// method.
///
/// Consider a hypothetical `QuakeMonitor` type that provides callers with
/// `Quake` instances every time it detects an earthquake. To receive callbacks,
/// callers set a custom closure as the value of the monitor's
/// `quakeHandler` property, which the monitor calls back as necessary. Callers
/// can also set an `errorHandler` to receive asychronous error notifications,
/// such as the monitor service suddenly becoming unavailable.
///
///     class QuakeMonitor {
///         var quakeHandler: ((Quake) -> Void)?
///         var errorHandler: ((Error) -> Void)?
///
///         func startMonitoring() {â€¦}
///         func stopMonitoring() {â€¦}
///     }
///
/// To adapt this to use `async`-`await`, extend the `QuakeMonitor` to add a
/// `quakes` property, of type `AsyncThrowingStream<Quake>`. In the getter for
/// this property, return an `AsyncThrowingStream`, whose `build` closure --
/// called at runtime to create the stream -- uses the continuation to
/// perform the following steps:
///
/// 1. Creates a `QuakeMonitor` instance.
/// 2. Sets the monitor's `quakeHandler` property to a closure that receives
/// each `Quake` instance and forwards it to the stream by calling the
/// continuation's `yield(_:)` method.
/// 3. Sets the monitor's `errorHandler` property to a closure that receives
/// any error from the monitor and forwards it to the stream by calling the
/// continuation's `finish(throwing:)` method. This causes the stream's
/// iterator to throw the error and terminate the stream.
/// 4. Sets the continuation's `onTermination` property to a closure that
/// calls `stopMonitoring()` on the monitor.
/// 5. Calls `startMonitoring` on the `QuakeMonitor`.
///
/// ```
/// extension QuakeMonitor {
///
///     static var throwingQuakes: AsyncThrowingStream<Quake, Error> {
///         AsyncThrowingStream { continuation in
///             let monitor = QuakeMonitor()
///             monitor.quakeHandler = { quake in
///                  continuation.yield(quake)
///             }
///             monitor.errorHandler = { error in
///                 continuation.finish(throwing: error)
///             }
///             continuation.onTermination = { @Sendable _ in
///                 monitor.stopMonitoring()
///             }
///             monitor.startMonitoring()
///         }
///     }
/// }
/// ```
///
///
/// Because the stream is an `AsyncSequence`, the call point uses the
/// `for`-`await`-`in` syntax to process each `Quake` instance as produced by the stream:
///
///     do {
///         for try await quake in quakeStream {
///             print("Quake: \(quake.date)")
///         }
///         print("Stream done.")
///     } catch {
///         print("Error: \(error)")
///     }
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct AsyncThrowingStream<Element, Failure> where Failure : Error {
  /// A mechanism to interface between synchronous code and an asynchronous
  /// stream.
  ///
  /// The closure you provide to the `AsyncThrowingStream` in
  /// `init(_:bufferingPolicy:_:)` receives an instance of this type when
  /// invoked. Use this continuation to provide elements to the stream by
  /// calling one of the `yield` methods, then terminate the stream normally by
  /// calling the `finish()` method. You can also use the continuation's
  /// `finish(throwing:)` method to terminate the stream by throwing an error.
  ///
  /// - Note: Unlike other continuations in Swift,
  /// `AsyncThrowingStream.Continuation` supports escaping.
  struct Continuation : Sendable {
    /// A type that indicates how the stream terminated.
    ///
    /// The `onTermination` closure receives an instance of this type.
    enum Termination {
      /// The stream finished as a result of calling the continuation's
      ///  `finish` method.
      ///
      ///  The associated `Failure` value provides the error that terminated
      ///  the stream. If no error occurred, this value is `nil`.
      case finished(Failure?)
      /// The stream finished as a result of cancellation.
      case cancelled
    }
    /// A type that indicates the result of yielding a value to a client, by
    /// way of the continuation.
    ///
    /// The various `yield` methods of `AsyncThrowingStream.Continuation` return
    /// this type to indicate the success or failure of yielding an element to
    /// the continuation.
    enum YieldResult {
      /// The stream successfully enqueued the element.
      ///
      /// This value represents the successful enqueueing of an element, whether
      /// the stream buffers the element or delivers it immediately to a pending
      /// call to `next()`. The associated value `remaining` is a hint that
      /// indicates the number of remaining slots in the buffer at the time of
      /// the `yield` call.
      ///
      /// - Note: From a thread safety perspective, `remaining` is a lower bound
      /// on the number of remaining slots. This is because a subsequent call
      /// that uses the `remaining` value could race on the consumption of
      /// values from the stream.
      case enqueued(remaining: Int)
      /// The stream didn't enqueue the element because the buffer was full.
      ///
      /// The associated element for this case is the element that the stream
      /// dropped.
      case dropped(Element)
      /// The stream didn't enqueue the element because the stream was in a
      /// terminal state.
      ///
      /// This indicates the stream terminated prior to calling `yield`, either
      /// because the stream finished normally or through cancellation, or
      /// it threw an error.
      case terminated
    }
    /// A strategy that handles exhaustion of a bufferâ€™s capacity.
    enum BufferingPolicy {
      /// Continue to add to the buffer, treating its capacity as infinite.
      case unbounded
      /// When the buffer is full, discard the newly received element.
      ///
      /// This strategy enforces keeping the specified amount of oldest values.
      case bufferingOldest(Int)
      /// When the buffer is full, discard the oldest element in the buffer.
      ///
      /// This strategy enforces keeping the specified amount of newest values.
      case bufferingNewest(Int)
    }
    /// Resume the task awaiting the next iteration point by having it return
    /// nomally from its suspension point with a given element.
    ///
    /// - Parameter value: The value to yield from the continuation.
    /// - Returns: A `YieldResult` that indicates the success or failure of the
    ///   yield operation.
    ///
    /// If nothing is awaiting the next value, the method attempts to buffer the
    /// result's element.
    ///
    /// This can be called more than once and returns to the caller immediately
    /// without blocking for any awaiting consumption from the iteration.
    @discardableResult
    func yield(_ value: __owned Element) -> AsyncThrowingStream<Element, Failure>.Continuation.YieldResult
    /// Resume the task awaiting the next iteration point by having it return
    /// nil, which signifies the end of the iteration.
    ///
    /// - Parameter error: The error to throw, or `nil`, to finish normally.
    ///
    /// Calling this function more than once has no effect. After calling
    /// finish, the stream enters a terminal state and doesn't produce any additional
    /// elements.
    func finish(throwing error: __owned Failure? = nil)
    /// A callback to invoke when canceling iteration of an asynchronous
    /// stream.
    ///
    /// If an `onTermination` callback is set, using task cancellation to
    /// terminate iteration of an `AsyncThrowingStream` results in a call to this
    /// callback.
    ///
    /// Canceling an active iteration invokes the `onTermination` callback
    /// first, and then resumes by yielding `nil` or throwing an error from the
    /// iterator. This means that you can perform needed cleanup in the
    ///  cancellation handler. After reaching a terminal state, the
    ///  `AsyncThrowingStream` disposes of the callback.
    var onTermination: (@Sendable (AsyncThrowingStream<Element, Failure>.Continuation.Termination) -> Void)? { get nonmutating set }
  }
  /// Constructs an asynchronous stream for an element type, using the
  /// specified buffering policy and element-producing closure.
  ///
  /// - Parameters:
  ///   - elementType: The type of element the `AsyncThrowingStream`
  ///   produces.
  ///   - limit: The maximum number of elements to
  ///   hold in the buffer. By default, this value is unlimited. Use a
  ///   `Continuation.BufferingPolicy` to buffer a specified number of oldest
  ///   or newest elements.
  ///   - build: A custom closure that yields values to the
  ///   `AsyncThrowingStream`. This closure receives an
  ///   `AsyncThrowingStream.Continuation` instance that it uses to provide
  ///   elements to the stream and terminate the stream when finished.
  ///
  /// The `AsyncStream.Continuation` received by the `build` closure is
  /// appopriate for use in concurrent contexts. It is thread safe to send and
  /// finish; all calls are to the continuation are serialized. However, calling
  /// this from multiple concurrent contexts could result in out-of-order
  /// delivery.
  ///
  /// The following example shows an `AsyncStream` created with this
  /// initializer that produces 100 random numbers on a one-second interval,
  /// calling `yield(_:)` to deliver each element to the awaiting call point.
  /// When the `for` loop exits, the stream finishes by calling the
  /// continuation's `finish()` method. If the random number is divisble by 5
  /// with no remainder, the stream throws a `MyRandomNumberError`.
  ///
  ///     let stream = AsyncThrowingStream<Int, Error>(Int.self,
  ///                                                  bufferingPolicy: .bufferingNewest(5)) { continuation in
  ///         Task.detached {
  ///             for _ in 0..<100 {
  ///                 await Task.sleep(1 * 1_000_000_000)
  ///                 let random = Int.random(in: 1...10)
  ///                 if random % 5 == 0 {
  ///                     continuation.finish(throwing: MyRandomNumberError())
  ///                     return
  ///                 } else {
  ///                     continuation.yield(random)
  ///                 }
  ///             }
  ///             continuation.finish()
  ///         }
  ///     }
  ///
  ///     // Call point:
  ///     do {
  ///         for try await random in stream {
  ///             print(random)
  ///         }
  ///     } catch {
  ///         print(error)
  ///     }
  ///
  init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncThrowingStream<Element, Failure>.Continuation) -> Void) where Failure == Error
  /// Constructs an asynchronous throwing stream from a given element-producing
  /// closure.
  ///
  /// - Parameters:
  ///   - produce: A closure that asynchronously produces elements for the
  ///    stream.
  ///
  /// Use this convenience initializer when you have an asychronous function
  /// that can produce elements for the stream, and don't want to invoke
  /// a continuation manually. This initializer "unfolds" your closure into
  /// a full-blown asynchronous stream. The created stream handles adherence to
  /// the `AsyncSequence` protocol automatically. To terminate the stream with
  /// an error, throw the error from your closure.
  ///
  /// The following example shows an `AsyncThrowingStream` created with this
  /// initializer that produces random numbers on a one-second interval. If the
  /// random number is divisble by 5 with no remainder, the stream throws a
  /// `MyRandomNumberError`.
  ///
  ///     let stream = AsyncThrowingStream<Int, Error> {
  ///         await Task.sleep(1 * 1_000_000_000)
  ///         let random = Int.random(in: 1...10)
  ///         if random % 5 == 0 {
  ///             throw MyRandomNumberError()
  ///         }
  ///         return random
  ///     }
  ///
  ///     // Call point:
  ///     do {
  ///         for try await random in stream {
  ///             print(random)
  ///         }
  ///     } catch {
  ///         print(error)
  ///     }
  ///
  init(unfolding produce: @escaping () async throws -> Element?) where Failure == Error
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingStream : AsyncSequence {
  /// The asynchronous iterator for iterating an asynchronous stream.
  ///
  /// This type is not `Sendable`. Don't use it from multiple
  /// concurrent contexts. It is a programmer error to invoke `next()` from a
  /// concurrent context that contends with another such call, which
  /// results in a call to `fatalError()`.
  struct Iterator : AsyncIteratorProtocol {
    /// The next value from the asynchronous stream.
    ///
    /// When `next()` returns `nil`, this signifies the end of the
    /// `AsyncThrowingStream`.
    ///
    /// It is a programmer error to invoke `next()` from a concurrent context
    /// that contends with another such call, which results in a call to
    ///  `fatalError()`.
    ///
    /// If you cancel the task this iterator is running in while `next()` is
    /// awaiting a value, the `AsyncThrowingStream` terminates. In this case,
    /// `next()` may return `nil` immediately, or else return `nil` on
    /// subsequent calls.
    mutating func next() async throws -> Element?
    typealias Element = Element
  }
  /// Creates the asynchronous iterator that produces elements of this
  /// asynchronous sequence.
  func makeAsyncIterator() -> AsyncThrowingStream<Element, Failure>.Iterator
  typealias AsyncIterator = AsyncThrowingStream<Element, Failure>.Iterator
  typealias Element = Element
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingStream : @unchecked Sendable where Element : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension AsyncThrowingStream.Continuation {
  /// Resume the task awaiting the next iteration point by having it return
  /// normally or throw, based on a given result.
  ///
  /// - Parameter result: A result to yield from the continuation. In the
  ///   `.success(_:)` case, this returns the associated value from the
  ///   iterator's `next()` method. If the result is the `failure(_:)` case,
  ///   this call terminates the stream with the result's error, by calling
  ///   `finish(throwing:)`.
  /// - Returns: A `YieldResult` that indicates the success or failure of the
  ///   yield operation.
  ///
  /// If nothing is awaiting the next value and the result is success, this call
  /// attempts to buffer the result's element.
  ///
  /// If you call this method repeatedly, each call returns immediately, without
  /// blocking for any awaiting consumption from the iteration.
  @discardableResult
  func yield(with result: Result<Element, Failure>) -> AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Failure == Error
  /// Resume the task awaiting the next iteration point by having it return
  /// nomally from its suspension point.
  ///
  /// - Returns: A `YieldResult` that indicates the success or failure of the
  ///   yield operation.
  ///
  /// Use this method with `AsyncThrowingStream` instances whose `Element`
  /// type is `Void`. In this case, the `yield()` call unblocks the
  /// awaiting iteration; there is no value to return.
  ///
  /// If you call this method repeatedly, each call returns immediately,
  /// without blocking for any awaiting consumption from the iteration.
  @discardableResult
  func yield() -> AsyncThrowingStream<Element, Failure>.Continuation.YieldResult where Element == ()
}

/// An error that indicates a task was canceled.
///
/// This error is also thrown automatically by `Task.checkCancellation()`,
/// if the current task has been canceled.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct CancellationError : Error {
  init()
}

/// A mechanism to interface
/// between synchronous and asynchronous code,
/// logging correctness violations.
///
/// A *continuation* is an opaque representation of program state.
/// To create a continuation in asynchronous code,
/// call the `withUnsafeContinuation(function:_:)` or
/// `withUnsafeThrowingContinuation(function:_:)` function.
/// To resume the asynchronous task,
/// call the `resume(returning:)`,
/// `resume(throwing:)`,
/// `resume(with:)`,
/// or `resume()` method.
///
/// - Important: You must call a resume method exactly once
///   on every execution path throughout the program.
///
/// Resuming from a continuation more than once is undefined behavior.
/// Never resuming leaves the task in a suspended state indefinitely,
/// and leaks any associated resources.
/// `CheckedContinuation` logs a message
/// if either of these invariants is violated.
///
/// `CheckedContinuation` performs runtime checks
/// for missing or multiple resume operations.
/// `UnsafeContinuation` avoids enforcing these invariants at runtime
/// because it aims to be a low-overhead mechanism
/// for interfacing Swift tasks with
/// event loops, delegate methods, callbacks,
/// and other non-`async` scheduling mechanisms.
/// However, during development, the ability to verify that the
/// invariants are being upheld in testing is important.
/// Because both types have the same interface,
/// you can replace one with the other in most circumstances,
/// without making other changes.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct CheckedContinuation<T, E> : Sendable where E : Error {
  /// Creates a checked continuation from an unsafe continuation.
  ///
  /// Instead of calling this initializer,
  /// most code calls the `withCheckedContinuation(function:_:)` or
  /// `withCheckedThrowingContinuation(function:_:)` function instead.
  /// You only need to initialize
  /// your own `CheckedContinuation<T, E>` if you already have an
  /// `UnsafeContinuation` you want to impose checking on.
  ///
  /// - Parameters:
  ///   - continuation: An instance of `UnsafeContinuation`
  ///     that hasn't yet been resumed.
  ///     After passing the unsafe continuation to this initializer,
  ///     don't use it outside of this object.
  ///   - function: A string identifying the declaration that is the notional
  ///     source for the continuation, used to identify the continuation in
  ///     runtime diagnostics related to misuse of this continuation.
  init(continuation: UnsafeContinuation<T, E>, function: String = #function)
  /// Resume the task awaiting the continuation by having it return normally
  /// from its suspension point.
  ///
  /// - Parameter value: The value to return from the continuation.
  ///
  /// A continuation must be resumed exactly once. If the continuation has
  /// already been resumed through this object, then the attempt to resume
  /// the continuation will trap.
  ///
  /// After `resume` enqueues the task, control immediately returns to
  /// the caller. The task continues executing when its executor is
  /// able to reschedule it.
  func resume(returning value: __owned T)
  /// Resume the task awaiting the continuation by having it throw an error
  /// from its suspension point.
  ///
  /// - Parameter error: The error to throw from the continuation.
  ///
  /// A continuation must be resumed exactly once. If the continuation has
  /// already been resumed through this object, then the attempt to resume
  /// the continuation will trap.
  ///
  /// After `resume` enqueues the task, control immediately returns to
  /// the caller. The task continues executing when its executor is
  /// able to reschedule it.
  func resume(throwing error: __owned E)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CheckedContinuation {
  /// Resume the task awaiting the continuation by having it either
  /// return normally or throw an error based on the state of the given
  /// `Result` value.
  ///
  /// - Parameter result: A value to either return or throw from the
  ///   continuation.
  ///
  /// A continuation must be resumed exactly once. If the continuation has
  /// already been resumed through this object, then the attempt to resume
  /// the continuation will trap.
  ///
  /// After `resume` enqueues the task, control immediately returns to
  /// the caller. The task continues executing when its executor is
  /// able to reschedule it.
  @_alwaysEmitIntoClient func resume<Er>(with result: Result<T, Er>) where E == Error, Er : Error
  /// Resume the task awaiting the continuation by having it either
  /// return normally or throw an error based on the state of the given
  /// `Result` value.
  ///
  /// - Parameter result: A value to either return or throw from the
  ///   continuation.
  ///
  /// A continuation must be resumed exactly once. If the continuation has
  /// already been resumed through this object, then the attempt to resume
  /// the continuation will trap.
  ///
  /// After `resume` enqueues the task, control immediately returns to
  /// the caller. The task continues executing when its executor is
  /// able to reschedule it.
  @_alwaysEmitIntoClient func resume(with result: Result<T, E>)
  /// Resume the task awaiting the continuation by having it return normally
  /// from its suspension point.
  ///
  /// A continuation must be resumed exactly once. If the continuation has
  /// already been resumed through this object, then the attempt to resume
  /// the continuation will trap.
  ///
  /// After `resume` enqueues the task, control immediately returns to
  /// the caller. The task continues executing when its executor is
  /// able to reschedule it.
  @_alwaysEmitIntoClient func resume() where T == ()
}

/// A mechanism in which to measure time, and delay work until a given point 
/// in time.
///
/// Types that conform to the `Clock` protocol define a concept of "now" which 
/// is the specific instant in time that property is accessed. Any pair of calls
/// to the `now` property may have a minimum duration between them - this
/// minimum resolution is exposed by the `minimumResolution` property to inform
/// any user of the type the expected granularity of accuracy. 
///
/// One of the primary uses for clocks is to schedule task sleeping. This method
/// resumes the calling task after a given deadline has been met or passed with
/// a given tolerance value. The tolerance is expected as a leeway around the 
/// deadline. The clock may reschedule tasks within the tolerance to ensure 
/// efficient execution of resumptions by reducing potential operating system
/// wake-ups. If no tolerance is specified (i.e. nil is passed in) the sleep
/// function is expected to schedule with a default tolerance strategy. 
///
/// For more information about specific clocks see `ContinuousClock` and 
/// `SuspendingClock`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
protocol Clock<Duration> : Sendable {
  associatedtype Duration where Self.Duration == Self.Instant.Duration
  associatedtype Instant : InstantProtocol
  var now: Self.Instant { get }
  var minimumResolution: Self.Duration { get }
  func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Clock {
  /// Measure the elapsed time to execute a closure.
  ///
  ///       let clock = ContinuousClock()
  ///       let elapsed = clock.measure {
  ///          someWork()
  ///       }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func measure(_ work: () throws -> Void) rethrows -> Self.Instant.Duration
  /// Measure the elapsed time to execute an asynchronous closure.
  ///
  ///       let clock = ContinuousClock()
  ///       let elapsed = await clock.measure {
  ///          await someWork()
  ///       }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func measure(_ work: () async throws -> Void) async rethrows -> Self.Instant.Duration
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Clock where Self == ContinuousClock {
  /// A clock that measures time that always increments but does not stop 
  /// incrementing while the system is asleep. 
  ///
  ///       try await Task.sleep(until: .now + .seconds(3), clock: .continuous)
  ///
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static var continuous: ContinuousClock { get }
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Clock where Self == SuspendingClock {
  /// A clock that measures time that always increments but stops incrementing 
  /// while the system is asleep. 
  ///
  ///       try await Task.sleep(until: .now + .seconds(3), clock: .suspending)
  ///
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static var suspending: SuspendingClock { get }
}

/// A clock that measures time that always increments but does not stop 
/// incrementing while the system is asleep. 
///
/// `ContinuousClock` can be considered as a stopwatch style time. The frame of
/// reference of the `Instant` may be bound to process launch, machine boot or
/// some other locally defined reference point. This means that the instants are
/// only comparable locally during the execution of a program.
///
/// This clock is suitable for high resolution measurements of execution.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
struct ContinuousClock {
  /// A continuous point in time used for `ContinuousClock`.
  struct Instant : Codable, Sendable {
    func encode(to encoder: Encoder) throws
    init(from decoder: Decoder) throws
  }
  init()
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension ContinuousClock : Clock {
  /// The current continuous instant.
  var now: ContinuousClock.Instant { get }
  /// The minimum non-zero resolution between any two calls to `now`.
  var minimumResolution: Duration { get }
  /// The current continuous instant.
  static var now: ContinuousClock.Instant { get }
  /// Suspend task execution until a given deadline within a tolerance.
  /// If no tolerance is specified then the system may adjust the deadline
  /// to coalesce CPU wake-ups to more efficiently process the wake-ups in
  /// a more power efficient manner.
  ///
  /// If the task is canceled before the time ends, this function throws 
  /// `CancellationError`.
  ///
  /// This function doesn't block the underlying thread.
  func sleep(until deadline: ContinuousClock.Instant, tolerance: Duration? = nil) async throws
  typealias Duration = Duration
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension ContinuousClock.Instant : InstantProtocol {
  static var now: ContinuousClock.Instant { get }
  func advanced(by duration: Duration) -> ContinuousClock.Instant
  func duration(to other: ContinuousClock.Instant) -> Duration
  func hash(into hasher: inout Hasher)
  static func == (lhs: ContinuousClock.Instant, rhs: ContinuousClock.Instant) -> Bool
  static func < (lhs: ContinuousClock.Instant, rhs: ContinuousClock.Instant) -> Bool
  @_alwaysEmitIntoClient @inlinable static func + (lhs: ContinuousClock.Instant, rhs: Duration) -> ContinuousClock.Instant
  @_alwaysEmitIntoClient @inlinable static func += (lhs: inout ContinuousClock.Instant, rhs: Duration)
  @_alwaysEmitIntoClient @inlinable static func - (lhs: ContinuousClock.Instant, rhs: Duration) -> ContinuousClock.Instant
  @_alwaysEmitIntoClient @inlinable static func -= (lhs: inout ContinuousClock.Instant, rhs: Duration)
  @_alwaysEmitIntoClient @inlinable static func - (lhs: ContinuousClock.Instant, rhs: ContinuousClock.Instant) -> Duration
  typealias Duration = Duration
  var hashValue: Int { get }
}

/// A service that can execute jobs.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
protocol Executor : AnyObject, Sendable {
  func enqueue(_ job: UnownedJob)
}

/// A type that represents a globally-unique actor that can be used to isolate
/// various declarations anywhere in the program.
///
/// A type that conforms to the `GlobalActor` protocol and is marked with
/// the `@globalActor` attribute can be used as a custom attribute. Such types
/// are called global actor types, and can be applied to any declaration to
/// specify that such types are isolated to that global actor type. When using
/// such a declaration from another actor (or from nonisolated code),
/// synchronization is performed through the shared actor instance to ensure
/// mutually-exclusive access to the declaration.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
protocol GlobalActor {
  /// The type of the shared actor instance that will be used to provide
  /// mutually-exclusive access to declarations annotated with the given global
  /// actor type.
  associatedtype ActorType : Actor
  /// The shared actor instance that will be used to provide mutually-exclusive
  /// access to declarations annotated with the given global actor type.
  ///
  /// The value of this property must always evaluate to the same actor
  /// instance.
  static var shared: Self.ActorType { get }
  /// The shared executor instance that will be used to provide
  /// mutually-exclusive access for the global actor.
  ///
  /// The value of this property must be equivalent to `shared.unownedExecutor`.
  static var sharedUnownedExecutor: UnownedSerialExecutor { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension GlobalActor {
  static var sharedUnownedExecutor: UnownedSerialExecutor { get }
}

/// A singleton actor whose executor is equivalent to the main
/// dispatch queue.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@globalActor final actor MainActor : GlobalActor {
  static let shared: MainActor
  @inlinable nonisolated final var unownedExecutor: UnownedSerialExecutor { get }
  @inlinable static var sharedUnownedExecutor: UnownedSerialExecutor { get }
  @inlinable nonisolated final func enqueue(_ job: UnownedJob)
  typealias ActorType = MainActor
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension MainActor {
  /// Execute the given body closure on the main actor.
  ///
  /// Historical ABI entry point, superceded by the Sendable version that is
  /// also inlined to back-deploy a semantic fix where this operation would
  /// not hop back at the end.
  @usableFromInline
  static func run<T>(resultType: T.Type = T.self, body: @MainActor @Sendable () throws -> T) async rethrows -> T
  /// Execute the given body closure on the main actor.
  @_alwaysEmitIntoClient static func run<T>(resultType: T.Type = T.self, body: @MainActor @Sendable () throws -> T) async rethrows -> T where T : Sendable
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "UnownedJob")
typealias PartialAsyncTask = UnownedJob

/// A service that executes jobs.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
protocol SerialExecutor : Executor {
  func enqueue(_ job: UnownedJob)
  /// Convert this executor value to the optimized form of borrowed
  /// executor references.
  func asUnownedSerialExecutor() -> UnownedSerialExecutor
}

/// A clock that measures time that always increments but stops incrementing 
/// while the system is asleep. 
///
/// `SuspendingClock` can be considered as a system awake time clock. The frame 
/// of reference of the `Instant` may be bound machine boot or some other 
/// locally defined reference point. This means that the instants are
/// only comparable on the same machine in the same booted session.
///
/// This clock is suitable for high resolution measurements of execution.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
struct SuspendingClock {
  struct Instant : Codable, Sendable {
    func encode(to encoder: Encoder) throws
    init(from decoder: Decoder) throws
  }
  init()
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension SuspendingClock : Clock {
  /// The current instant accounting for machine suspension.
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  var now: SuspendingClock.Instant { get }
  /// The current instant accounting for machine suspension.
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static var now: SuspendingClock.Instant { get }
  /// The minimum non-zero resolution between any two calls to `now`.
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  var minimumResolution: Duration { get }
  /// Suspend task execution until a given deadline within a tolerance.
  /// If no tolerance is specified then the system may adjust the deadline
  /// to coalesce CPU wake-ups to more efficiently process the wake-ups in
  /// a more power efficient manner.
  ///
  /// If the task is canceled before the time ends, this function throws 
  /// `CancellationError`.
  ///
  /// This function doesn't block the underlying thread.
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func sleep(until deadline: SuspendingClock.Instant, tolerance: Duration? = nil) async throws
  typealias Duration = Duration
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension SuspendingClock.Instant : InstantProtocol {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static var now: SuspendingClock.Instant { get }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func advanced(by duration: Duration) -> SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func duration(to other: SuspendingClock.Instant) -> Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  func hash(into hasher: inout Hasher)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func == (lhs: SuspendingClock.Instant, rhs: SuspendingClock.Instant) -> Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func < (lhs: SuspendingClock.Instant, rhs: SuspendingClock.Instant) -> Bool
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func + (lhs: SuspendingClock.Instant, rhs: Duration) -> SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func += (lhs: inout SuspendingClock.Instant, rhs: Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func - (lhs: SuspendingClock.Instant, rhs: Duration) -> SuspendingClock.Instant
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func -= (lhs: inout SuspendingClock.Instant, rhs: Duration)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func - (lhs: SuspendingClock.Instant, rhs: SuspendingClock.Instant) -> Duration
  typealias Duration = Duration
  var hashValue: Int { get }
}

/// A unit of asynchronous work.
///
/// When you create an instance of `Task`,
/// you provide a closure that contains the work for that task to perform.
/// Tasks can start running immediately after creation;
/// you don't explicitly start or schedule them.
/// After creating a task, you use the instance to interact with it ---
/// for example, to wait for it to complete or to cancel it.
/// It's not a programming error to discard a reference to a task
/// without waiting for that task to finish or canceling it.
/// A task runs regardless of whether you keep a reference to it.
/// However, if you discard the reference to a task,
/// you give up the ability
/// to wait for that task's result or cancel the task.
///
/// To support operations on the current task,
/// which can be either a detached task or child task,
/// `Task` also exposes class methods like `yield()`.
/// Because these methods are asynchronous,
/// they're always invoked as part of an existing task.
///
/// Only code that's running as part of the task can interact with that task.
/// To interact with the current task,
/// you call one of the static methods on `Task`.
///
/// A task's execution can be seen as a series of periods where the task ran.
/// Each such period ends at a suspension point or the
/// completion of the task.
/// These periods of execution are represented by instances of `PartialAsyncTask`.
/// Unless you're implementing a custom executor,
/// you don't directly interact with partial tasks.
///
/// For information about the language-level concurrency model that `Task` is part of,
/// see [Concurrency][concurrency] in [The Swift Programming Language][tspl].
///
/// [concurrency]: https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html
/// [tspl]: https://docs.swift.org/swift-book/
///
/// Task Cancellation
/// =================
///
/// Tasks include a shared mechanism for indicating cancellation,
/// but not a shared implementation for how to handle cancellation.
/// Depending on the work you're doing in the task,
/// the correct way to stop that work varies.
/// Likewise,
/// it's the responsibility of the code running as part of the task
/// to check for cancellation whenever stopping is appropriate.
/// In a long-task that includes multiple pieces,
/// you might need to check for cancellation at several points,
/// and handle cancellation differently at each point.
/// If you only need to throw an error to stop the work,
/// call the `Task.checkCancellation()` function to check for cancellation.
/// Other responses to cancellation include
/// returning the work completed so far, returning an empty result, or returning `nil`.
///
/// Cancellation is a purely Boolean state;
/// there's no way to include additional information
/// like the reason for cancellation.
/// This reflects the fact that a task can be canceled for many reasons,
/// and additional reasons can accrue during the cancellation process.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct Task<Success, Failure> : Sendable where Success : Sendable, Failure : Error {
  @usableFromInline
  let _task: Builtin.NativeObject
  @_alwaysEmitIntoClient init(_ task: Builtin.NativeObject)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "Task.Priority has been removed; use TaskPriority")
  typealias Priority = TaskPriority
  @available(*, deprecated, message: "Task.Handle has been removed; use Task")
  typealias Handle = Task
  @available(*, deprecated, message: "Task.CancellationError has been removed; use CancellationError")
  @_alwaysEmitIntoClient static func CancellationError() -> CancellationError
  @available(*, deprecated, renamed: "yield()")
  @_alwaysEmitIntoClient static func suspend() async
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "`Task.withCancellationHandler` has been replaced by `withTaskCancellationHandler` and will be removed shortly.")
  @_alwaysEmitIntoClient static func withCancellationHandler<T>(handler: @Sendable () -> Void, operation: () async throws -> T) async rethrows -> T
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Error {
  @discardableResult
  @available(*, deprecated, message: "`Task.runDetached` was replaced by `Task.detached` and will be removed shortly.")
  @_alwaysEmitIntoClient static func runDetached(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> Task<Success, Failure>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, message: "`Task.Group` was replaced by `ThrowingTaskGroup` and `TaskGroup` and will be removed shortly.")
  typealias Group<TaskResult> = ThrowingTaskGroup<TaskResult, Error> where TaskResult : Sendable
  @available(*, deprecated, message: "`Task.withGroup` was replaced by `withThrowingTaskGroup` and `withTaskGroup` and will be removed shortly.")
  @_alwaysEmitIntoClient static func withGroup<TaskResult, BodyResult>(resultType: TaskResult.Type, returning returnType: BodyResult.Type = BodyResult.self, body: (inout Task<Success, Failure>.Group<TaskResult>) async throws -> BodyResult) async rethrows -> BodyResult where TaskResult : Sendable
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient func get() async throws -> Success
  @available(*, deprecated, message: "getResult() has been replaced by .result")
  @_alwaysEmitIntoClient func getResult() async -> Result<Success, Failure>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Never {
  @available(*, deprecated, message: "get() has been replaced by .value")
  @_alwaysEmitIntoClient func get() async -> Success
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task {
  /// The result from a throwing task, after it completes.
  ///
  /// If the task hasn't completed,
  /// accessing this property waits for it to complete
  /// and its priority increases to that of the current task.
  /// Note that this might not be as effective as
  /// creating the task with the correct priority,
  /// depending on the executor's scheduling details.
  ///
  /// If the task throws an error, this property propagates that error.
  /// Tasks that respond to cancellation by throwing `CancellationError`
  /// have that error propagated here upon cancellation.
  ///
  /// - Returns: The task's result.
  var value: Success { get async throws }
  /// The result or error from a throwing task, after it completes.
  ///
  /// If the task hasn't completed,
  /// accessing this property waits for it to complete
  /// and its priority increases to that of the current task.
  /// Note that this might not be as effective as
  /// creating the task with the correct priority,
  /// depending on the executor's scheduling details.
  ///
  /// - Returns: If the task succeeded,
  ///   `.success` with the task's result as the associated value;
  ///   otherwise, `.failure` with the error as the associated value.
  var result: Result<Success, Failure> { get async }
  /// Indicates that the task should stop running.
  ///
  /// Task cancellation is cooperative:
  /// a task that supports cancellation
  /// checks whether it has been canceled at various points during its work.
  ///
  /// Calling this method on a task that doesn't support cancellation
  /// has no effect.
  /// Likewise, if the task has already run
  /// past the last point where it would stop early,
  /// calling this method has no effect.
  ///
  /// - SeeAlso: `Task.checkCancellation()`
  func cancel()
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Never {
  /// The result from a nonthrowing task, after it completes.
  ///
  /// If the task hasn't completed yet,
  /// accessing this property waits for it to complete
  /// and its priority increases to that of the current task.
  /// Note that this might not be as effective as
  /// creating the task with the correct priority,
  /// depending on the executor's scheduling details.
  ///
  /// Tasks that never throw an error can still check for cancellation,
  /// but they need to use an approach like returning `nil`
  /// instead of throwing an error.
  var value: Success { get async }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task : Hashable {
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task : Equatable {
  static func == (lhs: Task<Success, Failure>, rhs: Task<Success, Failure>) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  /// The current task's priority.
  ///
  /// If you access this property outside of any task,
  /// this queries the system to determine the
  /// priority at which the current function is running.
  /// If the system can't provide a priority,
  /// this property's value is `Priority.default`.
  static var currentPriority: TaskPriority { get }
  /// The current task's base priority.
  ///
  /// If you access this property outside of any task, this returns nil
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static var basePriority: TaskPriority? { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Never {
  /// Runs the given nonthrowing operation asynchronously
  /// as part of a new top-level task on behalf of the current actor.
  ///
  /// Use this function when creating asynchronous work
  /// that operates on behalf of the synchronous function that calls it.
  /// Like `Task.detached(priority:operation:)`,
  /// this function creates a separate, top-level task.
  /// Unlike `Task.detached(priority:operation:)`,
  /// the task created by `Task.init(priority:operation:)`
  /// inherits the priority and actor context of the caller,
  /// so the operation is treated more like an asynchronous extension
  /// to the synchronous operation.
  ///
  /// You need to keep a reference to the task
  /// if you want to cancel it by calling the `Task.cancel()` method.
  /// Discarding your reference to a detached task
  /// doesn't implicitly cancel that task,
  /// it only makes it impossible for you to explicitly cancel the task.
  ///
  /// - Parameters:
  ///   - priority: The priority of the task.
  ///     Pass `nil` to use the priority from `Task.currentPriority`.
  ///   - operation: The operation to perform.
  @discardableResult
  @_alwaysEmitIntoClient init(priority: TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> Success)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Error {
  /// Runs the given throwing operation asynchronously
  /// as part of a new top-level task on behalf of the current actor.
  ///
  /// Use this function when creating asynchronous work
  /// that operates on behalf of the synchronous function that calls it.
  /// Like `Task.detached(priority:operation:)`,
  /// this function creates a separate, top-level task.
  /// Unlike `detach(priority:operation:)`,
  /// the task created by `Task.init(priority:operation:)`
  /// inherits the priority and actor context of the caller,
  /// so the operation is treated more like an asynchronous extension
  /// to the synchronous operation.
  ///
  /// You need to keep a reference to the task
  /// if you want to cancel it by calling the `Task.cancel()` method.
  /// Discarding your reference to a detached task
  /// doesn't implicitly cancel that task,
  /// it only makes it impossible for you to explicitly cancel the task.
  ///
  /// - Parameters:
  ///   - priority: The priority of the task.
  ///     Pass `nil` to use the priority from `Task.currentPriority`.
  ///   - operation: The operation to perform.
  @discardableResult
  @_alwaysEmitIntoClient init(priority: TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> Success)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Never {
  /// Runs the given nonthrowing operation asynchronously
  /// as part of a new top-level task.
  ///
  /// Don't use a detached task if it's possible
  /// to model the operation using structured concurrency features like child tasks.
  /// Child tasks inherit the parent task's priority and task-local storage,
  /// and canceling a parent task automatically cancels all of its child tasks.
  /// You need to handle these considerations manually with a detached task.
  ///
  /// You need to keep a reference to the detached task
  /// if you want to cancel it by calling the `Task.cancel()` method.
  /// Discarding your reference to a detached task
  /// doesn't implicitly cancel that task,
  /// it only makes it impossible for you to explicitly cancel the task.
  ///
  /// - Parameters:
  ///   - priority: The priority of the task.
  ///   - operation: The operation to perform.
  ///
  /// - Returns: A reference to the task.
  @discardableResult
  @_alwaysEmitIntoClient static func detached(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> Success) -> Task<Success, Failure>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Failure == Error {
  /// Runs the given throwing operation asynchronously
  /// as part of a new top-level task.
  ///
  /// If the operation throws an error, this method propagates that error.
  ///
  /// Don't use a detached task if it's possible
  /// to model the operation using structured concurrency features like child tasks.
  /// Child tasks inherit the parent task's priority and task-local storage,
  /// and canceling a parent task automatically cancels all of its child tasks.
  /// You need to handle these considerations manually with a detached task.
  ///
  /// You need to keep a reference to the detached task
  /// if you want to cancel it by calling the `Task.cancel()` method.
  /// Discarding your reference to a detached task
  /// doesn't implicitly cancel that task,
  /// it only makes it impossible for you to explicitly cancel the task.
  ///
  /// - Parameters:
  ///   - priority: The priority of the task.
  ///   - operation: The operation to perform.
  ///
  /// - Returns: A reference to the task.
  @discardableResult
  @_alwaysEmitIntoClient static func detached(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> Success) -> Task<Success, Failure>
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  /// Suspends the current task and allows other tasks to execute.
  ///
  /// A task can voluntarily suspend itself
  /// in the middle of a long-running operation
  /// that doesn't contain any suspension points,
  /// to let other tasks run for a while
  /// before execution returns to this task.
  ///
  /// If this task is the highest-priority task in the system,
  /// the executor immediately resumes execution of the same task.
  /// As such,
  /// this method isn't necessarily a way to avoid resource starvation.
  static func yield() async
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task {
  /// A Boolean value that indicates whether the task should stop executing.
  ///
  /// After the value of this property becomes `true`, it remains `true` indefinitely.
  /// There is no way to uncancel a task.
  ///
  /// - SeeAlso: `checkCancellation()`
  @_transparent var isCancelled: Bool { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  /// A Boolean value that indicates whether the task should stop executing.
  ///
  /// After the value of this property becomes `true`, it remains `true` indefinitely.
  /// There is no way to uncancel a task.
  ///
  /// - SeeAlso: `checkCancellation()`
  static var isCancelled: Bool { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  /// Throws an error if the task was canceled.
  ///
  /// The error is always an instance of `CancellationError`.
  ///
  /// - SeeAlso: `isCancelled()`
  static func checkCancellation() throws
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Task where Success == Never, Failure == Never {
  @available(*, deprecated, renamed: "Task.sleep(nanoseconds:)")
  static func sleep(_ duration: UInt64) async
  /// Suspends the current task for at least the given duration
  /// in nanoseconds.
  ///
  /// If the task is canceled before the time ends,
  /// this function throws `CancellationError`.
  ///
  /// This function doesn't block the underlying thread.
  static func sleep(nanoseconds duration: UInt64) async throws
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Task where Success == Never, Failure == Never {
  /// Suspends the current task until the given deadline within a tolerance.
  ///
  /// If the task is canceled before the time ends, this function throws 
  /// `CancellationError`.
  ///
  /// This function doesn't block the underlying thread.
  ///
  ///       try await Task.sleep(until: .now + .seconds(3), clock: .continuous)
  ///
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  static func sleep<C>(until deadline: C.Instant, tolerance: C.Instant.Duration? = nil, clock: C) async throws where C : Clock
  /// Suspends the current task for the given duration on a continuous clock.
  ///
  /// If the task is cancelled before the time ends, this function throws 
  /// `CancellationError`.
  ///
  /// This function doesn't block the underlying thread.
  ///
  ///       try await Task.sleep(for: .seconds(3))
  ///
  /// - Parameter duration: The duration to wait.
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient static func sleep(for duration: Duration) async throws
}

/// A group that contains dynamically created child tasks.
///
/// To create a task group,
/// call the `withTaskGroup(of:returning:body:)` method.
///
/// Don't use a task group from outside the task where you created it.
/// In most cases,
/// the Swift type system prevents a task group from escaping like that
/// because adding a child task to a task group is a mutating operation,
/// and mutation operations can't be performed
/// from a concurrent execution context like a child task.
///
/// For information about the language-level concurrency model that `TaskGroup` is part of,
/// see [Concurrency][concurrency] in [The Swift Programming Language][tspl].
///
/// [concurrency]: https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html
/// [tspl]: https://docs.swift.org/swift-book/
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct TaskGroup<ChildTaskResult> where ChildTaskResult : Sendable {
  /// Group task into which child tasks offer their results,
  /// and the `next()` function polls those results from.
  @usableFromInline
  let _group: Builtin.RawPointer
  @inlinable init(group: Builtin.RawPointer)
  /// Adds a child task to the group.
  ///
  /// - Parameters:
  ///   - overridingPriority: The priority of the operation task.
  ///     Omit this parameter or pass `.unspecified`
  ///     to set the child task's priority to the priority of the group.
  ///   - operation: The operation to execute as part of the task group.
  @_alwaysEmitIntoClient mutating func addTask(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult)
  /// Adds a child task to the group, unless the group has been canceled.
  ///
  /// - Parameters:
  ///   - overridingPriority: The priority of the operation task.
  ///     Omit this parameter or pass `.unspecified`
  ///     to set the child task's priority to the priority of the group.
  ///   - operation: The operation to execute as part of the task group.
  /// - Returns: `true` if the child task was added to the group;
  ///   otherwise `false`.
  @_alwaysEmitIntoClient mutating func addTaskUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Bool
  /// Wait for the next child task to complete,
  /// and return the value it returned.
  ///
  /// The values returned by successive calls to this method
  /// appear in the order that the tasks *completed*,
  /// not in the order that those tasks were added to the task group.
  /// For example:
  ///
  ///     group.addTask { 1 }
  ///     group.addTask { 2 }
  ///
  ///     print(await group.next())
  ///     // Prints either "2" or "1".
  ///
  /// If there aren't any pending tasks in the task group,
  /// this method returns `nil`,
  /// which lets you write the following
  /// to wait for a single task to complete:
  ///
  ///     if let first = try await group.next() {
  ///        return first
  ///     }
  ///
  /// It also lets you write code like the following
  /// to wait for all the child tasks to complete,
  /// collecting the values they returned:
  ///
  ///     while let first = try await group.next() {
  ///        collected += value
  ///     }
  ///     return collected
  ///
  /// Awaiting on an empty group
  /// immediate returns `nil` without suspending.
  ///
  /// You can also use a `for`-`await`-`in` loop to collect results of a task group:
  ///
  ///     for await try value in group {
  ///         collected += value
  ///     }
  ///
  /// Don't call this method from outside the task
  /// where you created this task group.
  /// In most cases, the Swift type system prevents this mistake.
  /// For example, because the `add(priority:operation:)` method is mutating,
  /// that method can't be called from a concurrent execution context like a child task.
  ///
  /// - Returns: The value returned by the next child task that completes.
  mutating func next() async -> ChildTaskResult?
  /// Await all of the remaining tasks on this group.
  @usableFromInline
  mutating func awaitAllRemainingTasks() async
  /// Wait for all of the group's remaining tasks to complete.
  @_alwaysEmitIntoClient mutating func waitForAll() async
  /// A Boolean value that indicates whether the group has any remaining tasks.
  ///
  /// At the start of the body of a `withTaskGroup(of:returning:body:)` call,
  /// the task group is always empty.
  /// It`s guaranteed to be empty when returning from that body
  /// because a task group waits for all child tasks to complete before returning.
  ///
  /// - Returns: `true` if the group has no pending tasks; otherwise `false`.
  var isEmpty: Bool { get }
  /// Cancel all of the remaining tasks in the group.
  ///
  /// After cancellation,
  /// any new results from the tasks in this group
  /// are silently discarded.
  ///
  /// If you add a task to a group after canceling the group,
  /// that task is canceled immediately after being added to the group.
  ///
  /// This method can only be called by the parent task that created the task
  /// group.
  ///
  /// - SeeAlso: `Task.isCancelled`
  /// - SeeAlso: `TaskGroup.isCancelled`
  func cancelAll()
  /// A Boolean value that indicates whether the group was canceled.
  ///
  /// To cancel a group, call the `TaskGroup.cancelAll()` method.
  ///
  /// If the task that's currently running this group is canceled,
  /// the group is also implicitly canceled,
  /// which is also reflected in this property's value.
  var isCancelled: Bool { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskGroup {
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func add(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) async -> Bool
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func spawn(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult)
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient mutating func spawnUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Bool
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func async(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult)
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient mutating func asyncUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> ChildTaskResult) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension TaskGroup : Sendable {
}

/// ==== TaskGroup: AsyncSequence ----------------------------------------------
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskGroup : AsyncSequence {
  typealias AsyncIterator = TaskGroup<ChildTaskResult>.Iterator
  typealias Element = ChildTaskResult
  func makeAsyncIterator() -> TaskGroup<ChildTaskResult>.Iterator
  /// A type that provides an iteration interface
  /// over the results of tasks added to the group.
  ///
  /// The elements returned by this iterator
  /// appear in the order that the tasks *completed*,
  /// not in the order that those tasks were added to the task group.
  ///
  /// This iterator terminates after all tasks have completed.
  /// After iterating over the results of each task,
  /// it's valid to make a new iterator for the task group,
  /// which you can use to iterate over the results of new tasks you add to the group.
  /// For example:
  ///
  ///     group.addTask { 1 }
  ///     for await r in group { print(r) }
  ///
  ///     // Add a new child task and iterate again.
  ///     group.addTask { 2 }
  ///     for await r in group { print(r) }
  ///
  /// - SeeAlso: `TaskGroup.next()`
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  struct Iterator : AsyncIteratorProtocol {
    typealias Element = ChildTaskResult
    @usableFromInline
    var group: TaskGroup<ChildTaskResult>
    @usableFromInline
    var finished: Bool
    /// Advances to and returns the result of the next child task.
    ///
    /// The elements returned from this method
    /// appear in the order that the tasks *completed*,
    /// not in the order that those tasks were added to the task group.
    /// After this method returns `nil`,
    /// this iterator is guaranteed to never produce more values.
    ///
    /// For more information about the iteration order and semantics,
    /// see `TaskGroup.next()`.
    ///
    /// - Returns: The value returned by the next child task that completes,
    ///   or `nil` if there are no remaining child tasks,
    mutating func next() async -> TaskGroup<ChildTaskResult>.Iterator.Element?
    mutating func cancel()
  }
}

/// Property wrapper that defines a task-local value key.
///
/// A task-local value is a value that can be bound and read in the context of a
/// `Task`. It is implicitly carried with the task, and is accessible by any
/// child tasks the task creates (such as TaskGroup or `async let` created tasks).
///
/// ### Task-local declarations
///
/// Task locals must be declared as static properties (or global properties,
/// once property wrappers support these), like this:
///
///     enum TracingExample {
///         @TaskLocal
///         static let traceID: TraceID?
///     }
///
/// ### Default values
/// Task local values of optional types default to `nil`. It is possible to define
/// not-optional task-local values, and an explicit default value must then be
/// defined instead.
///
/// The default value is returned whenever the task-local is read
/// from a context which either: has no task available to read the value from
/// (e.g. a synchronous function, called without any asynchronous function in its call stack),
///
///
/// ### Reading task-local values
/// Reading task local values is simple and looks the same as-if reading a normal
/// static property:
///
///     guard let traceID = TracingExample.traceID else {
///       print("no trace id")
///       return
///     }
///     print(traceID)
///
/// It is possible to perform task-local value reads from either asynchronous
/// or synchronous functions. Within asynchronous functions, as a "current" task
/// is always guaranteed to exist, this will perform the lookup in the task local context.
///
/// A lookup made from the context of a synchronous function, that is not called
/// from an asynchronous function (!), will immediately return the task-local's
/// default value.
///
/// ### Binding task-local values
/// Task local values cannot be `set` directly and must instead be bound using
/// the scoped `$traceID.withValue() { ... }` operation. The value is only bound
/// for the duration of that scope, and is available to any child tasks which
/// are created within that scope.
///
/// Detached tasks do not inherit task-local values, however tasks created using
/// the `Task { ... }` initializer do inherit task-locals by copying them to the
/// new asynchronous task, even though it is an un-structured task.
///
/// ### Examples
///
///     @TaskLocal
///     static var traceID: TraceID?
///
///     print("traceID: \(traceID)") // traceID: nil
///
///     $traceID.withValue(1234) { // bind the value
///       print("traceID: \(traceID)") // traceID: 1234
///       call() // traceID: 1234
///
///       Task { // unstructured tasks do inherit task locals by copying
///         call() // traceID: 1234
///       }
///
///       Task.detached { // detached tasks do not inherit task-local values
///         call() // traceID: nil
///       }
///     }
///
///     func call() {
///       print("traceID: \(traceID)") // 1234
///     }
///
/// This type must be a `class` so it has a stable identity, that is used as key
/// value for lookups in the task local storage.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@propertyWrapper final class TaskLocal<Value> : Sendable, CustomStringConvertible where Value : Sendable {
  init(wrappedValue defaultValue: Value)
  /// Gets the value currently bound to this task-local from the current task.
  ///
  /// If no current task is available in the context where this call is made,
  /// or if the task-local has no value bound, this will return the `defaultValue`
  /// of the task local.
  final func get() -> Value
  /// Binds the task-local to the specific value for the duration of the asynchronous operation.
  ///
  /// The value is available throughout the execution of the operation closure,
  /// including any `get` operations performed by child-tasks created during the
  /// execution of the operation closure.
  ///
  /// If the same task-local is bound multiple times, be it in the same task, or
  /// in specific child tasks, the more specific (i.e. "deeper") binding is
  /// returned when the value is read.
  ///
  /// If the value is a reference type, it will be retained for the duration of
  /// the operation closure.
  @discardableResult
  final func withValue<R>(_ valueDuringOperation: Value, operation: () async throws -> R, file: String = #fileID, line: UInt = #line) async rethrows -> R
  /// Binds the task-local to the specific value for the duration of the
  /// synchronous operation.
  ///
  /// The value is available throughout the execution of the operation closure,
  /// including any `get` operations performed by child-tasks created during the
  /// execution of the operation closure.
  ///
  /// If the same task-local is bound multiple times, be it in the same task, or
  /// in specific child tasks, the "more specific" binding is returned when the
  /// value is read.
  ///
  /// If the value is a reference type, it will be retained for the duration of
  /// the operation closure.
  @discardableResult
  final func withValue<R>(_ valueDuringOperation: Value, operation: () throws -> R, file: String = #fileID, line: UInt = #line) rethrows -> R
  final var projectedValue: TaskLocal<Value>
  @available(*, unavailable, message: "property wrappers cannot be instance members")
  static subscript(_enclosingInstance object: Never, wrapped wrappedKeyPath: ReferenceWritableKeyPath<Never, Value>, storage storageKeyPath: ReferenceWritableKeyPath<Never, TaskLocal<Value>>) -> Value { get }
  final var wrappedValue: Value { get }
  final var description: String { get }
}

/// The priority of a task.
///
/// The executor determines how priority information affects the way tasks are scheduled.
/// The behavior varies depending on the executor currently being used.
/// Typically, executors attempt to run tasks with a higher priority
/// before tasks with a lower priority.
/// However, the semantics of how priority is treated are left up to each
/// platform and `Executor` implementation.
///
/// Child tasks automatically inherit their parent task's priority.
/// Detached tasks created by `detach(priority:operation:)` don't inherit task priority
/// because they aren't attached to the current task.
///
/// In some situations the priority of a task is elevated ---
/// that is, the task is treated as it if had a higher priority,
/// without actually changing the priority of the task:
///
/// - If a task runs on behalf of an actor,
///   and a new higher-priority task is enqueued to the actor,
///   then the actor's current task is temporarily elevated
///   to the priority of the enqueued task.
///   This priority elevation allows the new task
///   to be processed at the priority it was enqueued with.
/// - If a a higher-priority task calls the `get()` method,
///   then the priority of this task increases until the task completes.
///
/// In both cases, priority elevation helps you prevent a low-priority task
/// from blocking the execution of a high priority task,
/// which is also known as *priority inversion*.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct TaskPriority : RawRepresentable, Sendable {
  typealias RawValue = UInt8
  var rawValue: UInt8
  init(rawValue: UInt8)
  static let high: TaskPriority
  @_alwaysEmitIntoClient static var medium: TaskPriority { get }
  static let low: TaskPriority
  static let userInitiated: TaskPriority
  static let utility: TaskPriority
  static let background: TaskPriority
  @available(*, deprecated, renamed: "medium")
  static let `default`: TaskPriority
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskPriority {
  @available(*, deprecated, message: "unspecified priority will be removed; use nil")
  @_alwaysEmitIntoClient static var unspecified: TaskPriority { get }
  @available(*, deprecated, message: "userInteractive priority will be removed")
  @_alwaysEmitIntoClient static var userInteractive: TaskPriority { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskPriority : Equatable {
  static func == (lhs: TaskPriority, rhs: TaskPriority) -> Bool
  static func != (lhs: TaskPriority, rhs: TaskPriority) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskPriority : Comparable {
  static func < (lhs: TaskPriority, rhs: TaskPriority) -> Bool
  static func <= (lhs: TaskPriority, rhs: TaskPriority) -> Bool
  static func > (lhs: TaskPriority, rhs: TaskPriority) -> Bool
  static func >= (lhs: TaskPriority, rhs: TaskPriority) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension TaskPriority : Codable {
}

/// A group that contains throwing, dynamically created child tasks.
///
/// To create a throwing task group,
/// call the `withThrowingTaskGroup(of:returning:body:)` method.
///
/// Don't use a task group from outside the task where you created it.
/// In most cases,
/// the Swift type system prevents a task group from escaping like that
/// because adding a child task to a task group is a mutating operation,
/// and mutation operations can't be performed
/// from concurrent execution contexts like a child task.
///
/// For information about the language-level concurrency model that `ThrowingTaskGroup` is part of,
/// see [Concurrency][concurrency] in [The Swift Programming Language][tspl].
///
/// [concurrency]: https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html
/// [tspl]: https://docs.swift.org/swift-book/
///
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct ThrowingTaskGroup<ChildTaskResult, Failure> where ChildTaskResult : Sendable, Failure : Error {
  /// Group task into which child tasks offer their results,
  /// and the `next()` function polls those results from.
  @usableFromInline
  let _group: Builtin.RawPointer
  @inlinable init(group: Builtin.RawPointer)
  /// Await all the remaining tasks on this group.
  @usableFromInline
  mutating func awaitAllRemainingTasks() async
  @usableFromInline
  mutating func _waitForAll() async throws
  /// Wait for all of the group's remaining tasks to complete.
  @_alwaysEmitIntoClient mutating func waitForAll() async throws
  /// Adds a child task to the group.
  ///
  /// This method doesn't throw an error, even if the child task does.
  /// Instead, the corresponding call to `ThrowingTaskGroup.next()` rethrows that error.
  ///
  ///   - overridingPriority: The priority of the operation task.
  ///     Omit this parameter or pass `.unspecified`
  ///     to set the child task's priority to the priority of the group.
  ///   - operation: The operation to execute as part of the task group.
  @_alwaysEmitIntoClient mutating func addTask(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult)
  /// Adds a child task to the group, unless the group has been canceled.
  ///
  /// This method doesn't throw an error, even if the child task does.
  /// Instead, the corresponding call to `ThrowingTaskGroup.next()` rethrows that error.
  ///
  /// - Parameters:
  ///   - overridingPriority: The priority of the operation task.
  ///     Omit this parameter or pass `.unspecified`
  ///     to set the child task's priority to the priority of the group.
  ///   - operation: The operation to execute as part of the task group.
  /// - Returns: `true` if the child task was added to the group;
  ///   otherwise `false`.
  @_alwaysEmitIntoClient mutating func addTaskUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Bool
  /// Wait for the next child task to complete,
  /// and return the value it returned or rethrow the error it threw.
  ///
  /// The values returned by successive calls to this method
  /// appear in the order that the tasks *completed*,
  /// not in the order that those tasks were added to the task group.
  /// For example:
  ///
  ///     group.addTask { 1 }
  ///     group.addTask { 2 }
  ///
  ///     print(await group.next())
  ///     // Prints either "2" or "1".
  ///
  /// If there aren't any pending tasks in the task group,
  /// this method returns `nil`,
  /// which lets you write the following
  /// to wait for a single task to complete:
  ///
  ///     if let first = try await group.next() {
  ///        return first
  ///     }
  ///
  /// It also lets you write code like the following
  /// to wait for all the child tasks to complete,
  /// collecting the values they returned:
  ///
  ///     while let first = try await group.next() {
  ///        collected += value
  ///     }
  ///     return collected
  ///
  /// Awaiting on an empty group
  /// immediate returns `nil` without suspending.
  ///
  /// You can also use a `for`-`await`-`in` loop to collect results of a task group:
  ///
  ///     for await try value in group {
  ///         collected += value
  ///     }
  ///
  /// If the next child task throws an error
  /// and you propagate that error from this method
  /// out of the body of a call to the
  /// `ThrowingTaskGroup.withThrowingTaskGroup(of:returning:body:)` method,
  /// then all remaining child tasks in that group are implicitly canceled.
  ///
  /// Don't call this method from outside the task
  /// where this task group was created.
  /// In most cases, the Swift type system prevents this mistake;
  /// for example, because the `add(priority:operation:)` method is mutating,
  /// that method can't be called from a concurrent execution context like a child task.
  ///
  /// - Returns: The value returned by the next child task that completes.
  ///
  /// - Throws: The error thrown by the next child task that completes.
  ///
  /// - SeeAlso: `nextResult()`
  mutating func next() async throws -> ChildTaskResult?
  @_silgen_name("$sScg10nextResults0B0Oyxq_GSgyYaKF")
  @usableFromInline
  mutating func nextResultForABI() async throws -> Result<ChildTaskResult, Failure>?
  /// Wait for the next child task to complete,
  /// and return a result containing either
  /// the value that the child task returned or the error that it threw.
  ///
  /// The values returned by successive calls to this method
  /// appear in the order that the tasks *completed*,
  /// not in the order that those tasks were added to the task group.
  /// For example:
  ///
  ///     group.addTask { 1 }
  ///     group.addTask { 2 }
  ///
  ///     guard let result = await group.nextResult() else {
  ///         return  // No task to wait on, which won't happen in this example.
  ///     }
  ///     
  ///     switch result { 
  ///     case .success(let value): print(value)
  ///     case .failure(let error): print("Failure: \(error)")
  ///     }
  ///     // Prints either "2" or "1".
  ///
  /// If the next child task throws an error
  /// and you propagate that error from this method
  /// out of the body of a call to the
  /// `ThrowingTaskGroup.withThrowingTaskGroup(of:returning:body:)` method,
  /// then all remaining child tasks in that group are implicitly canceled.
  ///
  /// - Returns: A `Result.success` value
  ///   containing the value that the child task returned,
  ///   or a `Result.failure` value
  ///   containing the error that the child task threw.
  ///
  /// - SeeAlso: `next()`
  @_alwaysEmitIntoClient mutating func nextResult() async -> Result<ChildTaskResult, Failure>?
  /// A Boolean value that indicates whether the group has any remaining tasks.
  ///
  /// At the start of the body of a `withThrowingTaskGroup(of:returning:body:)` call,
  /// the task group is always empty.
  /// It's guaranteed to be empty when returning from that body
  /// because a task group waits for all child tasks to complete before returning.
  ///
  /// - Returns: `true` if the group has no pending tasks; otherwise `false`.
  var isEmpty: Bool { get }
  /// Cancel all of the remaining tasks in the group.
  ///
  /// After cancellation,
  /// any new results or errors from the tasks in this group
  /// are silently discarded.
  ///
  /// If you add a task to a group after canceling the group,
  /// that task is canceled immediately after being added to the group.
  ///
  /// There are no restrictions on where you can call this method.
  /// Code inside a child task or even another task can cancel a group.
  ///
  /// - SeeAlso: `Task.isCancelled`
  /// - SeeAlso: `ThrowingTaskGroup.isCancelled`
  func cancelAll()
  /// A Boolean value that indicates whether the group was canceled.
  ///
  /// To cancel a group, call the `ThrowingTaskGroup.cancelAll()` method.
  ///
  /// If the task that's currently running this group is canceled,
  /// the group is also implicitly canceled,
  /// which is also reflected in this property's value.
  var isCancelled: Bool { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension ThrowingTaskGroup {
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func add(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) async -> Bool
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func spawn(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult)
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient mutating func spawnUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Bool
  @available(*, deprecated, renamed: "addTask(priority:operation:)")
  @_alwaysEmitIntoClient mutating func async(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult)
  @available(*, deprecated, renamed: "addTaskUnlessCancelled(priority:operation:)")
  @_alwaysEmitIntoClient mutating func asyncUnlessCancelled(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> ChildTaskResult) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension ThrowingTaskGroup : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension ThrowingTaskGroup : AsyncSequence {
  typealias AsyncIterator = ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  typealias Element = ChildTaskResult
  func makeAsyncIterator() -> ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator
  /// A type that provides an iteration interface
  /// over the results of tasks added to the group.
  ///
  /// The elements returned by this iterator
  /// appear in the order that the tasks *completed*,
  /// not in the order that those tasks were added to the task group.
  ///
  /// This iterator terminates after all tasks have completed successfully,
  /// or after any task completes by throwing an error.
  /// If a task completes by throwing an error,
  /// it doesn't return any further task results.
  /// After iterating over the results of each task,
  /// it's valid to make a new iterator for the task group,
  /// which you can use to iterate over the results of new tasks you add to the group.
  /// You can also make a new iterator to resume iteration
  /// after a child task thows an error.
  /// For example:
  ///
  ///     group.addTask { 1 }
  ///     group.addTask { throw SomeError }
  ///     group.addTask { 2 }
  ///     
  ///     do { 
  ///         // Assuming the child tasks complete in order, this prints "1"
  ///         // and then throws an error.
  ///         for try await r in group { print(r) }
  ///     } catch {
  ///         // Resolve the error.
  ///     }
  ///     
  ///     // Assuming the child tasks complete in order, this prints "2".
  ///     for try await r in group { print(r) }
  ///
  /// - SeeAlso: `ThrowingTaskGroup.next()`
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  struct Iterator : AsyncIteratorProtocol {
    typealias Element = ChildTaskResult
    @usableFromInline
    var group: ThrowingTaskGroup<ChildTaskResult, Failure>
    @usableFromInline
    var finished: Bool
    /// Advances to and returns the result of the next child task.
    ///
    /// The elements returned from this method
    /// appear in the order that the tasks *completed*,
    /// not in the order that those tasks were added to the task group.
    /// After this method returns `nil`,
    /// this iterator is guaranteed to never produce more values.
    ///
    /// For more information about the iteration order and semantics,
    /// see `ThrowingTaskGroup.next()` 
    ///
    /// - Throws: The error thrown by the next child task that completes.
    ///
    /// - Returns: The value returned by the next child task that completes,
    ///   or `nil` if there are no remaining child tasks,
    mutating func next() async throws -> ThrowingTaskGroup<ChildTaskResult, Failure>.Iterator.Element?
    mutating func cancel()
  }
}

/// A unit of scheduleable work.
///
/// Unless you're implementing a scheduler,
/// you don't generally interact with jobs directly.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct UnownedJob : Sendable {
  var context: Builtin.Job
  @_alwaysEmitIntoClient @inlinable func _runSynchronously(on executor: UnownedSerialExecutor)
}

/// An unowned reference to a serial executor (a `SerialExecutor`
/// value).
///
/// This is an optimized type used internally by the core scheduling
/// operations.  It is an unowned reference to avoid unnecessary
/// reference-counting work even when working with actors abstractly.
/// Generally there are extra constraints imposed on core operations
/// in order to allow this.  For example, keeping an actor alive must
/// also keep the actor's associated executor alive; if they are
/// different objects, the executor must be referenced strongly by the
/// actor.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct UnownedSerialExecutor : Sendable {
  @usableFromInline
  var executor: Builtin.Executor
  @inlinable init(_ executor: Builtin.Executor)
  @inlinable init<E>(ordinary executor: __shared E) where E : SerialExecutor
}

/// A mechanism to interface
/// between synchronous and asynchronous code,
/// without correctness checking.
///
/// A *continuation* is an opaque representation of program state.
/// To create a continuation in asynchronous code,
/// call the `withUnsafeContinuation(_:)` or
/// `withUnsafeThrowingContinuation(_:)` function.
/// To resume the asynchronous task,
/// call the `resume(returning:)`,
/// `resume(throwing:)`,
/// `resume(with:)`,
/// or `resume()` method.
///
/// - Important: You must call a resume method exactly once
///   on every execution path throughout the program.
///   Resuming from a continuation more than once is undefined behavior.
///   Never resuming leaves the task in a suspended state indefinitely,
///   and leaks any associated resources.
///
/// `CheckedContinuation` performs runtime checks
/// for missing or multiple resume operations.
/// `UnsafeContinuation` avoids enforcing these invariants at runtime
/// because it aims to be a low-overhead mechanism
/// for interfacing Swift tasks with
/// event loops, delegate methods, callbacks,
/// and other non-`async` scheduling mechanisms.
/// However, during development, the ability to verify that the
/// invariants are being upheld in testing is important.
/// Because both types have the same interface,
/// you can replace one with the other in most circumstances,
/// without making other changes.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@frozen struct UnsafeContinuation<T, E> : Sendable where E : Error {
  @usableFromInline
  var context: Builtin.RawUnsafeContinuation
  @_alwaysEmitIntoClient init(_ context: Builtin.RawUnsafeContinuation)
  /// Resume the task that's awaiting the continuation
  /// by returning the given value.
  ///
  /// - Parameter value: The value to return from the continuation.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume(returning value: __owned T) where E == Never
  /// Resume the task that's awaiting the continuation
  /// by returning the given value.
  ///
  /// - Parameter value: The value to return from the continuation.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume(returning value: __owned T)
  /// Resume the task that's awaiting the continuation
  /// by throwing the given error.
  ///
  /// - Parameter error: The error to throw from the continuation.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume(throwing error: __owned E)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension UnsafeContinuation {
  /// Resume the task that's awaiting the continuation
  /// by returning or throwing the given result value.
  ///
  /// - Parameter result: The result.
  ///   If it contains a `.success` value,
  ///   the continuation returns that value;
  ///   otherwise, it throws the `.error` value.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume<Er>(with result: Result<T, Er>) where E == Error, Er : Error
  /// Resume the task that's awaiting the continuation
  /// by returning or throwing the given result value.
  ///
  /// - Parameter result: The result.
  ///   If it contains a `.success` value,
  ///   the continuation returns that value;
  ///   otherwise, it throws the `.error` value.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume(with result: Result<T, E>)
  /// Resume the task that's awaiting the continuation by returning.
  ///
  /// A continuation must be resumed exactly once.
  /// If the continuation has already resumed,
  /// then calling this method results in undefined behavior.
  ///
  /// After calling this method,
  /// control immediately returns to the caller.
  /// The task continues executing
  /// when its executor schedules it.
  @_alwaysEmitIntoClient func resume() where T == ()
}

/// An unsafe reference to the current task.
///
/// To get an instance of `UnsafeCurrentTask` for the current task,
/// call the `withUnsafeCurrentTask(body:)` method.
/// Don't store an unsafe task reference
/// for use outside that method's closure.
/// Storing an unsafe reference doesn't affect the task's actual life cycle,
/// and the behavior of accessing an unsafe task reference
/// outside of the `withUnsafeCurrentTask(body:)` method's closure isn't defined.
///
/// Only APIs on `UnsafeCurrentTask` that are also part of `Task`
/// are safe to invoke from a task other than
/// the task that this `UnsafeCurrentTask` instance refers to.
/// Calling other APIs from another task is undefined behavior,
/// breaks invariants in other parts of the program running on this task,
/// and may lead to crashes or data loss.
///
/// For information about the language-level concurrency model that `UnsafeCurrentTask` is part of,
/// see [Concurrency][concurrency] in [The Swift Programming Language][tspl].
///
/// [concurrency]: https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html
/// [tspl]: https://docs.swift.org/swift-book/
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
struct UnsafeCurrentTask {
  /// A Boolean value that indicates whether the current task was canceled.
  ///
  /// After the value of this property becomes `true`, it remains `true` indefinitely.
  /// There is no way to uncancel a task.
  ///
  /// - SeeAlso: `checkCancellation()`
  var isCancelled: Bool { get }
  /// The current task's priority.
  ///
  /// - SeeAlso: `TaskPriority`
  /// - SeeAlso: `Task.currentPriority`
  var priority: TaskPriority { get }
  /// Cancel the current task.
  func cancel()
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, unavailable)
extension UnsafeCurrentTask : Sendable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension UnsafeCurrentTask : Hashable {
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension UnsafeCurrentTask : Equatable {
  static func == (lhs: UnsafeCurrentTask, rhs: UnsafeCurrentTask) -> Bool
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "please use UnsafeContinuation<..., Error>")
typealias UnsafeThrowingContinuation<T> = UnsafeContinuation<T, Error>

/// A hack to mark an SDK that supports swift_continuation_await.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient func _abiEnableAwaitContinuation()

/// DEPRECATED. use _asyncLet_finish instead
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_end")
func _asyncLetEnd(asyncLet: Builtin.RawPointer)

/// DEPRECATED. use _asyncLet_get instead
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait")
func _asyncLetGet<T>(asyncLet: Builtin.RawPointer) async -> T

/// DEPRECATED. use _asyncLet_get_throwing instead
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_wait_throwing")
func _asyncLetGetThrowing<T>(asyncLet: Builtin.RawPointer) async throws -> T

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_start")
func _asyncLetStart<T>(asyncLet: Builtin.RawPointer, options: Builtin.RawPointer?, operation: @Sendable () async throws -> T)

/// Wait if necessary and then tear down the async let task
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_finish")
func _asyncLet_finish(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async

/// Wait if necessary and then project the result value of an async let
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get")
func _asyncLet_get(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async -> Builtin.RawPointer

/// Wait if necessary and then project the result value of an async let that throws
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_asyncLet_get_throwing")
func _asyncLet_get_throwing(_ asyncLet: Builtin.RawPointer, _ resultBuffer: Builtin.RawPointer) async throws -> Builtin.RawPointer

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_asyncMainDrainQueue")
func _asyncMainDrainQueue() -> Never

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_transparent func _checkExpectedExecutor(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _executor: Builtin.Executor)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
func _checkIllegalTaskLocalBindingWithinWithTaskGroup(file: String, line: UInt)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) func _contains<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Bool) async rethrows -> Bool where Source : AsyncSequence

/// Called to destroy the default actor instance in an actor.
/// The implementation will call this within the actor's deinit.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_destroy")
func _defaultActorDestroy(_ actor: AnyObject)

/// Called to initialize the default actor instance in an actor.
/// The implementation will call this within the actor's initializer.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_defaultActor_initialize")
func _defaultActorInitialize(_ actor: AnyObject)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobal")
@usableFromInline
func _enqueueJobGlobal(_ task: Builtin.Job)

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDeadline")
@usableFromInline
func _enqueueJobGlobalWithDeadline(_ seconds: Int64, _ nanoseconds: Int64, _ toleranceSec: Int64, _ toleranceNSec: Int64, _ clock: Int32, _ task: Builtin.Job)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueGlobalWithDelay")
@usableFromInline
func _enqueueJobGlobalWithDelay(_ delay: UInt64, _ task: Builtin.Job)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_enqueueMainExecutor")
@usableFromInline
func _enqueueOnMain(_ job: UnownedJob)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@inlinable @inline(__always) func _first<Source>(_ self: Source, where predicate: (Source.Element) async throws -> Bool) async rethrows -> Source.Element? where Source : AsyncSequence

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_getMainExecutor")
func _getMainExecutor() -> Builtin.Executor

@_alwaysEmitIntoClient @_transparent func _internalInvariant(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String(), file: StaticString = #fileID, line: UInt = #line)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportIllegalTaskLocalBindingWithinWithTaskGroup")
func _reportIllegalTaskLocalBindingWithinWithTaskGroup(_ _filenameStart: UnsafePointer<Int8>, _ _filenameLength: Int, _ _filenameIsASCII: Bool, _ _line: UInt)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_reportUnexpectedExecutor")
func _reportUnexpectedExecutor(_ _filenameStart: Builtin.RawPointer, _ _filenameLength: Builtin.Word, _ _filenameIsASCII: Builtin.Int1, _ _line: Builtin.Word, _ _executor: Builtin.Executor)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient func _resumeUnsafeContinuation<T>(_ continuation: UnsafeContinuation<T, Never>, _ value: __owned T)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient func _resumeUnsafeThrowingContinuation<T>(_ continuation: UnsafeContinuation<T, Error>, _ value: __owned T)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient func _resumeUnsafeThrowingContinuationWithError<T>(_ continuation: UnsafeContinuation<T, Error>, _ error: __owned Error)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@preconcurrency func _runAsyncMain(_ asyncFun: @escaping @Sendable () async throws -> ())

/// Intrinsic used by SILGen to launch a task for bridging a Swift async method
/// which was called through its ObjC-exported completion-handler-based API.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_alwaysEmitIntoClient func _runTaskForBridgedAsyncMethod(@_inheritActorContext _ body: __owned @escaping @Sendable () async -> Void)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_job_run")
@usableFromInline
func _swiftJobRun(_ job: UnownedJob, _ executor: UnownedSerialExecutor)

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait")
func _taskFutureGet<T>(_ task: Builtin.NativeObject) async -> T

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_future_wait_throwing")
func _taskFutureGetThrowing<T>(_ task: Builtin.NativeObject) async throws -> T

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_taskGroup_addPending")
@usableFromInline
func _taskGroupAddPendingTask(group: Builtin.RawPointer, unconditionally: Bool) -> Bool

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_task_isCancelled")
@usableFromInline
func _taskIsCancelled(_ task: Builtin.NativeObject) -> Bool

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@usableFromInline
@_silgen_name("swift_task_isCurrentExecutor")
func _taskIsCurrentExecutor(_ executor: Builtin.Executor) -> Bool

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient func async<T>(priority: TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> Task<T, Never> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, message: "`async` was replaced by `Task.init` and will be removed shortly.")
@discardableResult
@_alwaysEmitIntoClient func async<T>(priority: TaskPriority? = nil, @_inheritActorContext @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> Task<T, Error> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient func asyncDetached<T>(priority: TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async -> T) -> Task<T, Never> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`asyncDetached` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient func asyncDetached<T>(priority: TaskPriority? = nil, @_implicitSelfCapture operation: __owned @escaping @Sendable () async throws -> T) -> Task<T, Error> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient func detach<T>(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async -> T) -> Task<T, Never> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@discardableResult
@available(*, deprecated, message: "`detach` was replaced by `Task.detached` and will be removed shortly.")
@_alwaysEmitIntoClient func detach<T>(priority: TaskPriority? = nil, operation: __owned @escaping @Sendable () async throws -> T) -> Task<T, Error> where T : Sendable

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("swift_deletedAsyncMethodError")
func swift_deletedAsyncMethodError() async

/// Form task creation flags for use with the createAsyncTask builtins.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_alwaysEmitIntoClient func taskCreateFlags(priority: TaskPriority?, isChildTask: Bool, copyTaskLocals: Bool, inheritContext: Bool, enqueueJob: Bool, addPendingGroupTaskUnconditionally: Bool) -> Int

/// Suspends the current task,
/// then calls the given closure with a checked continuation for the current task.
///
/// - Parameters:
///   - function: A string identifying the declaration that is the notional
///     source for the continuation, used to identify the continuation in
///     runtime diagnostics related to misuse of this continuation.
///   - body: A closure that takes a `CheckedContinuation` parameter.
///     You must resume the continuation exactly once.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable func withCheckedContinuation<T>(function: String = #function, _ body: (CheckedContinuation<T, Never>) -> Void) async -> T

/// Suspends the current task,
/// then calls the given closure with a checked throwing continuation for the current task.
///
/// - Parameters:
///   - function: A string identifying the declaration that is the notional
///     source for the continuation, used to identify the continuation in
///     runtime diagnostics related to misuse of this continuation.
///   - body: A closure that takes a `CheckedContinuation` parameter.
///     You must resume the continuation exactly once.
///
/// If `resume(throwing:)` is called on the continuation,
/// this function throws that error.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @inlinable func withCheckedThrowingContinuation<T>(function: String = #function, _ body: (CheckedContinuation<T, Error>) -> Void) async throws -> T

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@available(*, deprecated, renamed: "withTaskCancellationHandler(operation:onCancel:)")
@_alwaysEmitIntoClient func withTaskCancellationHandler<T>(handler: @Sendable () -> Void, operation: () async throws -> T) async rethrows -> T

/// Execute an operation with a cancellation handler that's immediately
/// invoked if the current task is canceled.
///
/// This differs from the operation cooperatively checking for cancellation
/// and reacting to it in that the cancellation handler is _always_ and
/// _immediately_ invoked when the task is canceled. For example, even if the
/// operation is running code that never checks for cancellation, a cancellation
/// handler still runs and provides a chance to run some cleanup code.
///
/// Doesn't check for cancellation, and always executes the passed `operation`.
///
/// This function returns immediately and never suspends.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
func withTaskCancellationHandler<T>(operation: () async throws -> T, onCancel handler: @Sendable () -> Void) async rethrows -> T

/// Starts a new scope that can contain a dynamic number of child tasks.
///
/// A group waits for all of its child tasks
/// to complete or be canceled before it returns.
/// After this function returns, the task group is always empty.
///
/// To collect the results of the group's child tasks,
/// you can use a `for`-`await`-`in` loop:
///
///     var sum = 0
///     for await result in group {
///         sum += result
///     }
///
/// If you need more control or only a few results,
/// you can call `next()` directly:
///
///     guard let first = await group.next() else {
///         group.cancelAll()
///         return 0
///     }
///     let second = await group.next() ?? 0
///     group.cancelAll()
///     return first + second
///
/// Task Group Cancellation
/// =======================
///
/// You can cancel a task group and all of its child tasks
/// by calling the `cancellAll()` method on the task group,
/// or by canceling the task in which the group is running.
///
/// If you call `async(priority:operation:)` to create a new task in a canceled group,
/// that task is immediately canceled after creation.
/// Alternatively, you can call `asyncUnlessCancelled(priority:operation:)`,
/// which doesn't create the task if the group has already been canceled
/// Choosing between these two functions
/// lets you control how to react to cancellation within a group:
/// some child tasks need to run regardless of cancellation,
/// but other tasks are better not even being created
/// when you know they can't produce useful results.
///
/// Because the tasks you add to a group with this method are nonthrowing,
/// those tasks can't respond to cancellation by throwing `CancellationError`.
/// The tasks must handle cancellation in some other way,
/// such as returning the work completed so far, returning an empty result, or returning `nil`.
/// For tasks that need to handle cancellation by throwing an error,
/// use the `withThrowingTaskGroup(of:returning:body:)` method instead.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss13withTaskGroup2of9returning4bodyq_xm_q_mq_ScGyxGzYaXEtYar0_lF")
@_unsafeInheritExecutor @inlinable func withTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout TaskGroup<ChildTaskResult>) async -> GroupResult) async -> GroupResult where ChildTaskResult : Sendable

/// Starts a new scope that can contain a dynamic number of throwing child tasks.
///
/// A group waits for all of its child tasks
/// to complete, throw an error, or be canceled before it returns.
/// After this function returns, the task group is always empty.
///
/// To collect the results of the group's child tasks,
/// you can use a `for`-`await`-`in` loop:
///
///     var sum = 0
///     for await result in group {
///         sum += result
///     }
///
/// If you need more control or only a few results,
/// you can call `next()` directly:
///
///     guard let first = await group.next() else {
///         group.cancelAll()
///         return 0
///     }
///     let second = await group.next() ?? 0
///     group.cancelAll()
///     return first + second
///
/// Task Group Cancellation
/// =======================
///
/// You can cancel a task group and all of its child tasks
/// by calling the `cancellAll()` method on the task group,
/// or by canceling the task in which the group is running.
///
/// If you call `async(priority:operation:)` to create a new task in a canceled group,
/// that task is immediately canceled after creation.
/// Alternatively, you can call `asyncUnlessCancelled(priority:operation:)`,
/// which doesn't create the task if the group has already been canceled
/// Choosing between these two functions
/// lets you control how to react to cancellation within a group:
/// some child tasks need to run regardless of cancellation,
/// but other tasks are better not even being created
/// when you know they can't produce useful results.
///
/// Throwing an error in one of the tasks of a task group
/// doesn't immediately cancel the other tasks in that group.
/// However,
/// if you call `next()` in the task group and propagate its error,
/// all other tasks are canceled.
/// For example, in the code below,
/// nothing is canceled and the group doesn't throw an error:
///
///     withThrowingTaskGroup { group in
///         group.addTask { throw SomeError() }
///     }
///
/// In contrast, this example throws `SomeError`
/// and cancels all of the tasks in the group:
///
///     withThrowingTaskGroup { group in
///         group.addTask { throw SomeError() }
///         try group.next()
///     }
///
/// An individual task throws its error
/// in the corresponding call to `Group.next()`,
/// which gives you a chance to handle the individual error
/// or to let the group rethrow the error.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_silgen_name("$ss21withThrowingTaskGroup2of9returning4bodyq_xm_q_mq_Scgyxs5Error_pGzYaKXEtYaKr0_lF")
@_unsafeInheritExecutor @inlinable func withThrowingTaskGroup<ChildTaskResult, GroupResult>(of childTaskResultType: ChildTaskResult.Type, returning returnType: GroupResult.Type = GroupResult.self, body: (inout ThrowingTaskGroup<ChildTaskResult, Error>) async throws -> GroupResult) async rethrows -> GroupResult where ChildTaskResult : Sendable

/// Suspends the current task,
/// then calls the given closure with an unsafe continuation for the current task.
///
/// - Parameter fn: A closure that takes an `UnsafeContinuation` parameter.
/// You must resume the continuation exactly once.
///
/// - Returns: The value passed to the continuation by the closure.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient func withUnsafeContinuation<T>(_ fn: (UnsafeContinuation<T, Never>) -> Void) async -> T

/// Calls a closure with an unsafe reference to the current task.
///
/// If you call this function from the body of an asynchronous function,
/// the unsafe task handle passed to the closure is always non-`nil`
/// because an asynchronous function always runs in the context of a task.
/// However, if you call this function from the body of a synchronous function,
/// and that function isn't executing in the context of any task,
/// the unsafe task handle is `nil`.
///
/// Don't store an unsafe task reference
/// for use outside this method's closure.
/// Storing an unsafe reference doesn't affect the task's actual life cycle,
/// and the behavior of accessing an unsafe task reference
/// outside of the `withUnsafeCurrentTask(body:)` method's closure isn't defined.
/// There's no safe way to retrieve a reference to the current task
/// and save it for long-term use.
/// To query the current task without saving a reference to it,
/// use properties like `currentPriority`.
/// If you need to store a reference to a task,
/// create an unstructured task using `Task.detached(priority:operation:)` instead.
///
/// - Parameters:
///   - body: A closure that takes an `UnsafeCurrentTask` parameter.
///     If `body` has a return value,
///     that value is also used as the return value
///     for the `withUnsafeCurrentTask(body:)` function.
///
/// - Returns: The return value, if any, of the `body` closure.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
func withUnsafeCurrentTask<T>(body: (UnsafeCurrentTask?) throws -> T) rethrows -> T

/// Suspends the current task,
/// then calls the given closure with an unsafe throwing continuation for the current task.
///
/// - Parameter fn: A closure that takes an `UnsafeContinuation` parameter.
/// You must resume the continuation exactly once.
///
/// - Returns: The value passed to the continuation by the closure.
///
/// If `resume(throwing:)` is called on the continuation,
/// this function throws that error.
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
@_unsafeInheritExecutor @_alwaysEmitIntoClient func withUnsafeThrowingContinuation<T>(_ fn: (UnsafeContinuation<T, Error>) -> Void) async throws -> T

